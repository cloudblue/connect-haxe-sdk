<!-- This file can be parsed by haxe.rtti.XmlParser -->
<haxe>
	<abstract path="Any" params="" file="/home/travis/haxe/std/Any.hx">
		<from><icast field="__cast"><c path="__cast.T"/></icast></from>
		<this><d/></this>
		<to><icast field="__promote"><c path="__promote.T"/></icast></to>
		<haxe_doc>`Any` is a type that is compatible with any other in both ways.

	This means that a value of any type can be assigned to `Any`, and
	vice-versa, a value of `Any` type can be assigned to any other type.

	It's a more type-safe alternative to `Dynamic`, because it doesn't
	support field access or operators and it's bound to monomorphs. So,
	to work with the actual value, it needs to be explicitly promoted
	to another type.</haxe_doc>
		<meta><m n=":forward.variance"/></meta>
		<impl><class path="_Any.Any_Impl_" params="" file="/home/travis/haxe/std/Any.hx" private="1" module="Any" final="1">
	<__promote params="T" get="inline" set="null" line="37" static="1">
		<f a="this">
			<d/>
			<c path="__promote.T"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":to"/>
		</meta>
	</__promote>
	<__cast params="T" get="inline" set="null" line="40" static="1">
		<f a="value">
			<c path="__cast.T"/>
			<x path="Any"/>
		</f>
		<meta>
			<m n=":noCompletion"/>
			<m n=":from"/>
		</meta>
	</__cast>
	<toString get="inline" set="null" line="43" static="1">
		<f a="this">
			<d/>
			<c path="String"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</toString>
</class></impl>
	</abstract>
	<class path="_Any.Any_Impl_" params="" file="/home/travis/haxe/std/Any.hx" private="1" module="Any" final="1">
		<__promote params="T" get="inline" set="null" line="37" static="1">
			<f a="this">
				<d/>
				<c path="__promote.T"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":to"/>
			</meta>
		</__promote>
		<__cast params="T" get="inline" set="null" line="40" static="1">
			<f a="value">
				<c path="__cast.T"/>
				<x path="Any"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":from"/>
			</meta>
		</__cast>
		<toString get="inline" set="null" line="43" static="1">
			<f a="this">
				<d/>
				<c path="String"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</toString>
	</class>
	<class path="Array" params="T" file="/home/travis/haxe/std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` is less than or equals
		`pos`, the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, an empty Array [] is
		returned and `this` Array is unchanged.

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use `Std.string()` to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed accordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<contains public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whether `this` Array contains `x`.

		If `x` is found by checking standard equality, the function returns `true`, otherwise
		the function returns `false`.</haxe_doc>
		</contains>
		<indexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurrence of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurrence of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" get="inline" set="null" line="280">
			<f a=""><c path="haxe.iterators.ArrayIterator"><c path="Array.T"/></c></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="287">
			<f a=""><c path="haxe.iterators.ArrayKeyValueIterator"><c path="Array.T"/></c></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an iterator of the Array indices and values.</haxe_doc>
		</keyValueIterator>
		<map public="1" params="S" get="inline" set="null" line="298">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" get="inline" set="null" line="316">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<resize public="1" set="method">
			<f a="len">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the length of the Array.

		If `len` is shorter than the array's current size, the last
		`length - len` elements will be removed. If `len` is longer, the Array
		will be extended, with new elements set to a target-specific default
		value:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets</haxe_doc>
		</resize>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="Class" params="T" file="/home/travis/haxe/std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="/home/travis/haxe/std/Date.hx" extern="1">
		<now public="1" set="method" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" set="method" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Creates a Date from the timestamp (in milliseconds) `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Creates a Date from the formatted string `s`. The following formats are
		accepted by the function:

		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`

		The first two formats expressed a date in local time. The third is a time
		relative to the UTC epoch.</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp (in milliseconds) of `this` date.
		On cpp and neko, this function only has a second resolution, so the
		result will always be a multiple of `1000.0`, e.g. `1454698271000.0`.
		To obtain the current timestamp with better precision on cpp and neko,
		see the `Sys.time` API.

		For measuring time differences with millisecond accuracy on
		all platforms, see `haxe.Timer.stamp`.</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range) in the local timezone.</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range) in the local timezone.</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of `this` Date (0-59 range) in the local timezone.</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4 digits) in the local timezone.</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range) in the local timezone.
		Note that the month number is zero-based.</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range) in the local timezone.</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)
		in the local timezone.</haxe_doc>
		</getDay>
		<getUTCHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range) in UTC.</haxe_doc>
		</getUTCHours>
		<getUTCMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range) in UTC.</haxe_doc>
		</getUTCMinutes>
		<getUTCSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of `this` Date (0-59 range) in UTC.</haxe_doc>
		</getUTCSeconds>
		<getUTCFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4 digits) in UTC.</haxe_doc>
		</getUTCFullYear>
		<getUTCMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range) in UTC.
		Note that the month number is zero-based.</haxe_doc>
		</getUTCMonth>
		<getUTCDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range) in UTC.</haxe_doc>
		</getUTCDate>
		<getUTCDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)
		in UTC.</haxe_doc>
		</getUTCDay>
		<getTimezoneOffset public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the time zone difference of `this` Date in the current locale
		to UTC, in minutes.

		Assuming the function is executed on a machine in a UTC+2 timezone,
		`Date.now().getTimezoneOffset()` will return `-120`.</haxe_doc>
		</getTimezoneOffset>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Date in the local timezone
		using the standard format `YYYY-MM-DD HH:MM:SS`. See `DateTools.format` for
		other formatting rules.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11 (note that this is zero-based)
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There are some extra functions available in the `DateTools` class.

	In the context of Haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970 UTC.

	## Supported range

	Due to platform limitations, only dates in the range 1970 through 2038 are
	supported consistently. Some targets may support dates outside this range,
	depending on the OS at runtime. The `Date.fromTime` method will not work with
	timestamps outside the range on any target.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="EReg" params="" file="/home/travis/haxe/std/EReg.hx">
		<escape public="1" set="method" line="200" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Escape the string `s` for use as a part of regular expression.

		If `s` is null, the result is unspecified.</haxe_doc>
		</escape>
		<match public="1" set="method" line="58">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.

		This method modifies the internal state.

		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<matched public="1" set="method" line="73">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.

		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.

		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, the result is unspecified.

		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<matchedLeft public="1" set="method" line="88">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part to the left of the last matched substring.

		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.

		If the global g modifier was in place for the matching, only the
		substring to the left of the leftmost match is returned.

		The result does not include the matched part.</haxe_doc>
		</matchedLeft>
		<matchedRight public="1" set="method" line="103">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part to the right of the last matched substring.

		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.

		If the global g modifier was in place for the matching, only the
		substring to the right of the leftmost match is returned.

		The result does not include the matched part.</haxe_doc>
		</matchedRight>
		<matchedPos public="1" set="method" line="118">
			<f a=""><a>
	<pos><x path="Int"/></pos>
	<len><x path="Int"/></len>
</a></f>
			<haxe_doc>Returns the position and length of the last matched substring, within
		the String which was last used as argument to `this.match` or
		`this.matchSub`.

		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.

		If the global g modifier was in place for the matching, the position and
		length of the leftmost substring is returned.</haxe_doc>
		</matchedPos>
		<matchSub public="1" set="method" line="133">
			<f a="s:pos:?len" v="::-1">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ len : -1 }</e></m></meta>
			<haxe_doc>Tells if `this` regular expression matches a substring of String `s`.

		This function expects `pos` and `len` to describe a valid substring of
		`s`, or else the result is unspecified. To get more robust behavior,
		`this.match(s.substr(pos,len))` can be used instead.

		This method modifies the internal state.

		If `s` is null, the result is unspecified.</haxe_doc>
		</matchSub>
		<split public="1" set="method" line="155">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits String `s` at all substrings `this` EReg matches.

		If a match is found at the start of `s`, the result contains a leading
		empty String "" entry.

		If a match is found at the end of `s`, the result contains a trailing
		empty String "" entry.

		If two matching substrings appear next to each other, the result
		contains the empty String `""` between them.

		By default, this method splits `s` into two parts at the first matched
		substring. If the global g modifier is in place, `s` is split at each
		matched substring.

		If `s` is null, the result is unspecified.</haxe_doc>
		</split>
		<replace public="1" set="method" line="173">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replaces the first substring of `s` which `this` EReg matches with `by`.

		If `this` EReg does not match any substring, the result is `s`.

		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.

		If `by` contains `$1` to `$9`, the digit corresponds to number of a
		matched sub-group and its value is used instead. If no such sub-group
		exists, the replacement is unspecified. The string `$$` becomes `$`.

		If `s` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<map public="1" set="method" line="191">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>Calls the function `f` for the substring of `s` which `this` EReg matches
		and replaces that substring with the result of `f` call.

		The `f` function takes `this` EReg object as its first argument and should
		return a replacement string for the substring matched.

		If `this` EReg does not match any substring, the result is `s`.

		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.

		If `s` or `f` are null, the result is unspecified.</haxe_doc>
		</map>
		<new public="1" set="method" line="47">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.

		This is equivalent to the shorthand syntax `~/r/opt`

		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The EReg class represents regular expressions.

	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.

	EReg instances can be created by calling the constructor, or with the
	special syntax `~/pattern/modifier`

	EReg instances maintain an internal state, which is affected by several of
	its methods.

	A detailed explanation of the supported operations is available at
	<https://haxe.org/manual/std-regex.html>]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="Enum" params="T" file="/home/travis/haxe/std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/home/travis/haxe/std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
		<impl><class path="_EnumValue.EnumValue_Impl_" params="" file="/home/travis/haxe/std/EnumValue.hx" private="1" module="EnumValue" final="1"><match public="1" set="method" line="58" static="1">
	<f a="this:pattern">
		<x path="EnumValue"/>
		<d/>
		<x path="Bool"/>
	</f>
	<haxe_doc>Matches enum instance `e` against pattern `pattern`, returning `true` if
		matching succeeded and `false` otherwise.

		Example usage:

		```haxe
		if (e.match(pattern)) {
			// codeIfTrue
		} else {
			// codeIfFalse
		}
		```

		This is equivalent to the following code:

		```haxe
		switch (e) {
			case pattern:
				// codeIfTrue
			case _:
				// codeIfFalse
		}
		```

		This method is implemented in the compiler. This definition exists only
		for documentation.</haxe_doc>
</match></class></impl>
	</abstract>
	<class path="_EnumValue.EnumValue_Impl_" params="" file="/home/travis/haxe/std/EnumValue.hx" private="1" module="EnumValue" final="1"><match public="1" set="method" line="58" static="1">
	<f a="this:pattern">
		<x path="EnumValue"/>
		<d/>
		<x path="Bool"/>
	</f>
	<haxe_doc>Matches enum instance `e` against pattern `pattern`, returning `true` if
		matching succeeded and `false` otherwise.

		Example usage:

		```haxe
		if (e.match(pattern)) {
			// codeIfTrue
		} else {
			// codeIfFalse
		}
		```

		This is equivalent to the following code:

		```haxe
		switch (e) {
			case pattern:
				// codeIfTrue
			case _:
				// codeIfFalse
		}
		```

		This method is implemented in the compiler. This definition exists only
		for documentation.</haxe_doc>
</match></class>
	<class path="IntIterator" params="" file="/home/travis/haxe/std/IntIterator.hx">
		<min><x path="Int"/></min>
		<max><x path="Int"/></max>
		<hasNext public="1" get="inline" set="null" line="53">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns true if the iterator has other items, false otherwise.</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="62">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Moves to the next item of the iterator.

		If this is called while hasNext() is false, the result is unspecified.</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="45">
			<f a="min:max">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Iterates from `min` (inclusive) to `max` (exclusive).

		If `max <= min`, the iterator will not act as a countdown.]]></haxe_doc>
		</new>
		<haxe_doc>IntIterator is used for implementing interval iterations.

	It is usually not used explicitly, but through its special syntax:
	`min...max`

	While it is possible to assign an instance of IntIterator to a variable or
	field, it is worth noting that IntIterator does not reset after being used
	in a for-loop. Subsequent uses of the same instance will then have no
	effect.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</class>
	<class path="Lambda" params="" file="/home/travis/haxe/std/Lambda.hx">
		<array public="1" params="A" set="method" line="45" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>Creates an Array from Iterable `it`.

		If `it` is an Array, this function returns a copy of it.</haxe_doc>
		</array>
		<list public="1" params="A" set="method" line="57" static="1">
			<f a="it">
				<t path="Iterable"><c path="list.A"/></t>
				<c path="haxe.ds.List"><c path="list.A"/></c>
			</f>
			<haxe_doc>Creates a List form Iterable `it`.

		If `it` is a List, this function returns a copy of it.</haxe_doc>
		</list>
		<map public="1" params="A:B" get="inline" set="null" line="69" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="map.A"/></t>
				<f a="item">
					<c path="map.A"/>
					<c path="map.B"/>
				</f>
				<c path="Array"><c path="map.B"/></c>
			</f>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `it`.
		The order of elements is preserved.
		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<mapi public="1" params="A:B" get="inline" set="null" line="78" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="mapi.A"/></t>
				<f a="index:item">
					<x path="Int"/>
					<c path="mapi.A"/>
					<c path="mapi.B"/>
				</f>
				<c path="Array"><c path="mapi.B"/></c>
			</f>
			<haxe_doc>Similar to map, but also passes the index of each element to `f`.
		The order of elements is preserved.
		If `f` is null, the result is unspecified.</haxe_doc>
		</mapi>
		<flatten public="1" params="A" get="inline" set="null" line="87" static="1">
			<f a="it">
				<t path="Iterable"><t path="Iterable"><c path="flatten.A"/></t></t>
				<c path="Array"><c path="flatten.A"/></c>
			</f>
			<haxe_doc>Concatenate a list of iterables.
		The order of elements is preserved.</haxe_doc>
		</flatten>
		<flatMap public="1" params="A:B" get="inline" set="null" line="96" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="flatMap.A"/></t>
				<f a="item">
					<c path="flatMap.A"/>
					<t path="Iterable"><c path="flatMap.B"/></t>
				</f>
				<c path="Array"><c path="flatMap.B"/></c>
			</f>
			<haxe_doc>A composition of map and flatten.
		The order of elements is preserved.
		If `f` is null, the result is unspecified.</haxe_doc>
		</flatMap>
		<has public="1" params="A" set="method" line="108" static="1">
			<f a="it:elt">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `it` contains `elt`.

		This function returns true as soon as an element is found which is equal
		to `elt` according to the `==` operator.

		If no such element is found, the result is false.</haxe_doc>
		</has>
		<exists public="1" params="A" set="method" line="125" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="item">
					<c path="exists.A"/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `it` contains an element for which `f` is true.

		This function returns true as soon as an element is found for which a
		call to `f` returns true.

		If no such element is found, the result is false.

		If `f` is null, the result is unspecified.</haxe_doc>
		</exists>
		<foreach public="1" params="A" set="method" line="144" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="foreach.A"/></t>
				<f a="item">
					<c path="foreach.A"/>
					<x path="Bool"/>
				</f>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is true for all elements of `it`.

		This function returns false as soon as an element is found for which a
		call to `f` returns false.

		If no such element is found, the result is true.

		In particular, this function always returns true if `it` is empty.

		If `f` is null, the result is unspecified.</haxe_doc>
		</foreach>
		<iter public="1" params="A" set="method" line="156" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="iter.A"/></t>
				<f a="item">
					<c path="iter.A"/>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls `f` on all elements of `it`, in order.

		If `f` is null, the result is unspecified.</haxe_doc>
		</iter>
		<filter public="1" params="A" set="method" line="167" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="filter.A"/></t>
				<f a="item">
					<c path="filter.A"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="filter.A"/></c>
			</f>
			<haxe_doc>Returns a Array containing those elements of `it` for which `f` returned
		true.
		If `it` is empty, the result is the empty Array even if `f` is null.
		Otherwise if `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<fold public="1" params="A:B" set="method" line="183" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="fold.A"/></t>
				<f a="item:result">
					<c path="fold.A"/>
					<c path="fold.B"/>
					<c path="fold.B"/>
				</f>
				<c path="fold.B"/>
				<c path="fold.B"/>
			</f>
			<haxe_doc>Functional fold on Iterable `it`, using function `f` with start argument
		`first`.

		If `it` has no elements, the result is `first`.

		Otherwise the first element of `it` is passed to `f` alongside `first`.
		The result of that call is then passed to `f` with the next element of
		`it`, and so on until `it` has no more elements.

		If `it` or `f` are null, the result is unspecified.</haxe_doc>
		</fold>
		<foldi public="1" params="A:B" set="method" line="194" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="foldi.A"/></t>
				<f a="item:result:index">
					<c path="foldi.A"/>
					<c path="foldi.B"/>
					<x path="Int"/>
					<c path="foldi.B"/>
				</f>
				<c path="foldi.B"/>
				<c path="foldi.B"/>
			</f>
			<haxe_doc>Similar to fold, but also passes the index of each element to `f`.

		If `it` or `f` are null, the result is unspecified.</haxe_doc>
		</foldi>
		<count public="1" params="A" set="method" line="209" static="1">
			<f a="it:?pred">
				<t path="Iterable"><c path="count.A"/></t>
				<f a="item">
					<c path="count.A"/>
					<x path="Bool"/>
				</f>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the number of elements in `it` for which `pred` is true, or the
		total number of elements in `it` if `pred` is null.

		This function traverses all elements.</haxe_doc>
		</count>
		<empty public="1" params="T" set="method" line="224" static="1">
			<f a="it">
				<t path="Iterable"><c path="empty.T"/></t>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if Iterable `it` does not contain any element.</haxe_doc>
		</empty>
		<indexOf public="1" params="T" set="method" line="235" static="1">
			<f a="it:v">
				<t path="Iterable"><c path="indexOf.T"/></t>
				<c path="indexOf.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of the first element `v` within Iterable `it`.

		This function uses operator `==` to check for equality.

		If `v` does not exist in `it`, the result is -1.</haxe_doc>
		</indexOf>
		<find public="1" params="T" set="method" line="255" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="find.T"/></t>
				<f a="item">
					<c path="find.T"/>
					<x path="Bool"/>
				</f>
				<x path="Null"><c path="find.T"/></x>
			</f>
			<haxe_doc>Returns the first element of `it` for which `f` is true.

		This function returns as soon as an element is found for which a call to
		`f` returns true.

		If no such element is found, the result is null.

		If `f` is null, the result is unspecified.</haxe_doc>
		</find>
		<findIndex public="1" params="T" set="method" line="273" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="findIndex.T"/></t>
				<f a="item">
					<c path="findIndex.T"/>
					<x path="Bool"/>
				</f>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of the first element of `it` for which `f` is true.

		This function returns as soon as an element is found for which a call to
		`f` returns true.

		If no such element is found, the result is -1.

		If `f` is null, the result is unspecified.</haxe_doc>
		</findIndex>
		<concat public="1" params="T" set="method" line="289" static="1">
			<f a="a:b">
				<t path="Iterable"><c path="concat.T"/></t>
				<t path="Iterable"><c path="concat.T"/></t>
				<c path="Array"><c path="concat.T"/></c>
			</f>
			<haxe_doc>Returns a new Array containing all elements of Iterable `a` followed by
		all elements of Iterable `b`.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</concat>
		<haxe_doc>The `Lambda` class is a collection of methods to support functional
	programming. It is ideally used with `using Lambda` and then acts as an
	extension to Iterable types.

	On static platforms, working with the Iterable structure might be slower
	than performing the operations directly on known types, such as Array and
	List.

	If the first argument to any of the methods is null, the result is
	unspecified.

	@see https://haxe.org/manual/std-Lambda.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="List" params="T" file="/home/travis/haxe/std/List.hx"><c path="haxe.ds.List"><c path="List.T"/></c></typedef>
	<typedef path="Map" params="K:V" file="/home/travis/haxe/std/Map.hx"><x path="haxe.ds.Map">
	<c path="Map.K"/>
	<c path="Map.V"/>
</x></typedef>
	<typedef path="IMap" params="K:V" file="/home/travis/haxe/std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":deprecated"/>
		</meta>
	</typedef>
	<class path="Math" params="" file="/home/travis/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>Represents the ratio of the circumference of a circle to its diameter,
		specified by the constant, π. `PI` is approximately `3.141592653589793`.</haxe_doc>
		</PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes negative infinity.

		For example, this is the result of `-1.0 / 0.0`.

		Operations with `NEGATIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes positive infinity.

		For example, this is the result of `1.0 / 0.0`.

		Operations with `POSITIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes an invalid number.

		`NaN` stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: `Math.sqrt(-1)`.

		All further operations with `NaN` as an operand will result in `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.

		In order to test if a value is `NaN`, you should use `Math.isNaN()` function.</haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.

		- If `v` is positive or `0`, the result is unchanged. Otherwise the result is `-v`.
		- If `v` is `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.

		- If `a` or `b` are `NaN`, the result is `NaN`.
		- If `a` or `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.
		- If `a` and `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.

		- If `a` or `b` are `NaN`, the result is `NaN`.
		- If `a` or `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `a` and `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric tangent of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</tan>
		<asin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</asin>
		<acos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc cosine of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</acos>
		<atan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</atan>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent whose tangent is the quotient of
		two specified numbers, in radians.

		If parameter `x` or `y`  is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is `NaN`.</haxe_doc>
		</atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.

		`exp(1.0)` is approximately `2.718281828459`.

		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `NEGATIVE_INFINITY`, the result is `0.0`.
		- If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.

		This is the mathematical inverse operation of exp,
		i.e. `log(exp(v)) == v` always holds.

		- If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result is `NaN`.
		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `0.0`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1">
			<f a="v:exp">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a specified base `v` raised to the specified power `exp`.</haxe_doc>
		</pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.

		- If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result is `NaN`.
		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `0.0`, the result is `0.0`.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to `0.0`,
		and less than `1.0`.</haxe_doc>
		</random>
		<ffloor public="1" get="inline" set="null" line="257" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></ffloor>
		<fceil public="1" get="inline" set="null" line="261" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fceil>
		<fround public="1" get="inline" set="null" line="265" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.

		If `f` is `POSITIVE_INFINITY`, `NEGATIVE_INFINITY` or `NaN`, the result
		is `false`, otherwise the result is `true`.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.

		If `f` is `NaN`, the result is `true`, otherwise the result is `false`.
		In particular, both `POSITIVE_INFINITY` and `NEGATIVE_INFINITY` are
		not considered `NaN`.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.

	@see https://haxe.org/manual/std-math.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="Reflect" params="" file="/home/travis/haxe/std/Reflect.hx" extern="1">
		<hasField public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if structure `o` has a field named `field`.

		This is only guaranteed to work for anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</hasField>
		<field public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`.

		If `o` is not an object or has no field named `field`, the result is
		null.

		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.

		If `field` is null, the result is unspecified.</haxe_doc>
		</field>
		<setField public="1" set="method" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`.

		If `o` has no field named `field`, this function is only guaranteed to
		work for anonymous structures.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</setField>
		<getProperty public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`, taking
		property getter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.field`, but might be slower.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</getProperty>
		<setProperty public="1" set="method" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`, taking
		property setter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.setField`, but might be slower.

		If `field` is null, the result is unspecified.</haxe_doc>
		</setProperty>
		<callMethod public="1" set="method" static="1">
			<f a="o:func:args">
				<d/>
				<x path="haxe.Function"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method `func` with the given arguments `args`.

		The object `o` is ignored in most cases. It serves as the `this`-context in the following
		situations:

		* (neko) Allows switching the context to `o` in all cases.
		* (macro) Same as neko for Haxe 3. No context switching in Haxe 4.
		* (js, lua) Require the `o` argument if `func` does not, but should have a context.
			This can occur by accessing a function field natively, e.g. through `Reflect.field`
			or by using `(object : Dynamic).field`. However, if `func` has a context, `o` is
			ignored like on other targets.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `f` is a function, false otherwise.

		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compares `a` and `b`.

		If `a` is less than `b`, the result is negative. If `b` is less than
		`a`, the result is positive. If `a` and `b` are equal, the result is 0.

		This function is only defined if `a` and `b` are of the same type.

		If that type is a function, the result is unspecified and
		`Reflect.compareMethods` should be used instead.

		For all other types, the result is 0 if `a` and `b` are equal. If they
		are not equal, the result depends on the type and is negative if:

		- Numeric types: a is less than b
		- String: a is lexicographically less than b
		- Other: unspecified

		If `a` and `b` are null, the result is 0. If only one of them is null,
		the result is unspecified.</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Compares the functions `f1` and `f2`.

		If `f1` or `f2` are null, the result is false.
		If `f1` or `f2` are not functions, the result is unspecified.

		Otherwise the result is true if `f1` and the `f2` are physically equal,
		false otherwise.

		If `f1` or `f2` are member method closures, the result is true if they
		are closures of the same method on the same object value, false otherwise.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[Tells if `v` is an object.

		The result is true if `v` is one of the following:

		- class instance
		- structure
		- `Class<T>`
		- `Enum<T>`

		Otherwise, including if `v` is null, the result is false.]]></haxe_doc>
		</isObject>
		<isEnumValue public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `v` is an enum value.

		The result is true if `v` is of type EnumValue, i.e. an enum
		constructor.

		Otherwise, including if `v` is null, the result is false.</haxe_doc>
		</isEnumValue>
		<deleteField public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the field named `field` from structure `o`.

		This method is only guaranteed to work on anonymous structures.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" static="1">
			<f a="o">
				<x path="Null"><c path="copy.T"/></x>
				<x path="Null"><c path="copy.T"/></x>
			</f>
			<haxe_doc>Copies the fields of structure `o`.

		This is only guaranteed to work on anonymous structures.

		If `o` is null, the result is `null`.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
			<overloads><makeVarArgs public="1" set="method">
	<f a="f">
		<f a="">
			<c path="Array"><d/></c>
			<x path="Void"/>
		</f>
		<d/>
	</f>
	<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
</makeVarArgs></overloads>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamically through an
	abstract interface in an untyped manner. Use with care.

	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="Std" params="" file="/home/travis/haxe/std/Std.hx" extern="1">
		<is public="1" set="method" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":deprecated"><e>"Std.is is deprecated. Use Std.isOfType instead."</e></m></meta>
			<haxe_doc>DEPRECATED. Use `Std.isOfType(v, t)` instead.

		Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.

		If `t` is a class or interface with `@:generic` meta, the result is `false`.</haxe_doc>
		</is>
		<isOfType public="1" set="method" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.

		If `t` is a class or interface with `@:generic` meta, the result is `false`.</haxe_doc>
		</isOfType>
		<downcast public="1" params="T:S" set="method" static="1">
			<f a="value:c">
				<c path="downcast.T"/>
				<x path="Class"><c path="downcast.S"/></x>
				<c path="downcast.S"/>
			</f>
			<haxe_doc>Checks if object `value` is an instance of class or interface `c`.

		Compiles only if the type specified by `c` can be assigned to the type
		of `value`.

		This method checks if a downcast is possible. That is, if the runtime
		type of `value` is assignable to the type specified by `c`, `value` is
		returned. Otherwise null is returned.

		This method is not guaranteed to work with core types such as `String`,
		`Array` and `Date`.

		If `value` is null, the result is null. If `c` is null, the result is
		unspecified.</haxe_doc>
		</downcast>
		<instance public="1" params="T:S" set="method" static="1">
			<f a="value:c">
				<c path="instance.T"/>
				<x path="Class"><c path="instance.S"/></x>
				<c path="instance.S"/>
			</f>
			<meta><m n=":deprecated"><e>"Std.instance() is deprecated. Use Std.downcast() instead."</e></m></meta>
		</instance>
		<string public="1" set="method" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If `x` is null, the result is unspecified.
		If `x` cannot be parsed as integer, the result is `null`.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a `NaN` value instead of null.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[Return a random integer between 0 included and `x` excluded.

		If `x <= 1`, the result is always 0.]]></haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="Void" params="" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Null" params="T" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<from><icast><c path="Null.T"/></icast></from>
		<this><x path="Null"><c path="Null.T"/></x></this>
		<to><icast><c path="Null.T"/></icast></to>
		<haxe_doc><![CDATA[`Null<T>` is a wrapper that can be used to make the basic types `Int`,
	`Float` and `Bool` nullable on static targets.

	If null safety is enabled, only types wrapped in `Null<T>` are nullable.

	Otherwise, it has no effect on non-basic-types, but it can be useful as a way to document
	that `null` is an acceptable value for a method argument, return value or variable.

	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="Bool" params="" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterator" params="K:V" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<t path="Iterator"><a>
	<value><c path="KeyValueIterator.V"/></value>
	<key><c path="KeyValueIterator.K"/></key>
</a></t>
		<haxe_doc>A `KeyValueIterator` is an `Iterator` that has a key and a value.</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterable" params="K:V" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<a><keyValueIterator set="method"><f a=""><t path="KeyValueIterator">
	<c path="KeyValueIterable.K"/>
	<c path="KeyValueIterable.V"/>
</t></f></keyValueIterator></a>
		<haxe_doc>A `KeyValueIterable` is a data structure which has a `keyValueIterator()`
	method to iterate over key-value-pairs.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<class path="String" params="" file="/home/travis/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`.

		If `startIndex` exceeds `this.length`, -1 is returned.

		If `startIndex` is negative, the result is unspecifed.

		Otherwise the search is performed within `this` String. In either case,
		the returned position is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex + str.length`. Otherwise the search
		is performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `startIndex` is negative, the result is unspecifed.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurrence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurrence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.

	@see https://haxe.org/manual/std-String.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="StringBuf" params="" file="/home/travis/haxe/std/StringBuf.hx">
		<b><c path="String"/></b>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` StringBuf in characters.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="48"><f a=""><x path="Int"/></f></get_length>
		<add public="1" params="T" get="inline" set="null" line="61">
			<f a="x">
				<c path="add.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the representation of `x` to `this` StringBuf.

		The exact representation of `x` may vary per platform. To get more
		consistent behavior, this function should be called with
		Std.string(x).

		If `x` is null, the String "null" is appended.</haxe_doc>
		</add>
		<addChar public="1" get="inline" set="null" line="71">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the character identified by `c` to `this` StringBuf.

		If `c` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</addChar>
		<addSub public="1" get="inline" set="null" line="87">
			<f a="s:pos:?len">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends a substring of `s` to `this` StringBuf.

		This function expects `pos` and `len` to describe a valid substring of
		`s`, or else the result is unspecified. To get more robust behavior,
		`this.add(s.substr(pos,len))` can be used instead.

		If `s` or `pos` are null, the result is unspecified.

		If `len` is omitted or null, the substring ranges from `pos` to the end
		of `s`.</haxe_doc>
		</addSub>
		<toString public="1" get="inline" set="null" line="96">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the content of `this` StringBuf as String.

		The buffer is not emptied by this operation.</haxe_doc>
		</toString>
		<new public="1" get="inline" set="null" line="44">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.

		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.

	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.SysTools" params="" file="/home/travis/haxe/std/haxe/SysTools.hx">
		<winMetaCharacters final="1" public="1" set="null" expr="[&quot; &quot;.code, &quot;(&quot;.code, &quot;)&quot;.code, &quot;%&quot;.code, &quot;!&quot;.code, &quot;^&quot;.code, &quot;\&quot;&quot;.code, &quot;&lt;&quot;.code, &quot;&gt;&quot;.code, &quot;&amp;&quot;.code, &quot;|&quot;.code, &quot;\n&quot;.code, &quot;\r&quot;.code, &quot;,&quot;.code, &quot;;&quot;.code]" line="9" static="1">
			<x path="haxe.ds.ReadOnlyArray"><x path="Int"/></x>
			<meta><m n=":value"><e><![CDATA[[" ".code, "(".code, ")".code, "%".code, "!".code, "^".code, "\"".code, "<".code, ">".code, "&".code, "|".code, "\n".code, "\r".code, ",".code, ";".code]]]></e></m></meta>
			<haxe_doc>Character codes of the characters that will be escaped by `quoteWinArg(_, true)`.</haxe_doc>
		</winMetaCharacters>
		<quoteUnixArg public="1" set="method" line="18" static="1">
			<f a="argument">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a String that can be used as a single command line argument
		on Unix.
		The input will be quoted, or escaped if necessary.</haxe_doc>
		</quoteUnixArg>
		<quoteWinArg public="1" set="method" line="46" static="1">
			<f a="argument:escapeMetaCharacters">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a String that can be used as a single command line argument
		on Windows.
		The input will be quoted, or escaped if necessary, such that the output
		will be parsed as a single argument using the rule specified in
		http://msdn.microsoft.com/en-us/library/ms880421

		Examples:
		```haxe
		quoteWinArg("abc") == "abc";
		quoteWinArg("ab c") == '"ab c"';
		```</haxe_doc>
		</quoteWinArg>
	</class>
	<class path="StringTools" params="" file="/home/travis/haxe/std/StringTools.hx">
		<urlEncode public="1" get="inline" set="null" line="42" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode an URL by using the standard format.</haxe_doc>
		</urlEncode>
		<urlDecode public="1" get="inline" set="null" line="110" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Decode an URL using the standard format.</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="158" static="1">
			<f a="s:?quotes">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Escapes HTML special characters of the string `s`.

		The following replacements are made:

		- `&` becomes `&amp`;
		- `<` becomes `&lt`;
		- `>` becomes `&gt`;

		If `quotes` is true, the following characters are also replaced:

		- `"` becomes `&quot`;
		- `'` becomes `&#039`;]]></haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="193" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Unescapes HTML special characters of the string `s`.

		This is the inverse operation to htmlEscape, i.e. the following always
		holds: `htmlUnescape(htmlEscape(s)) == s`

		The replacements follow:

		- `&amp;` becomes `&`
		- `&lt;` becomes `<`
		- `&gt;` becomes `>`
		- `&quot;` becomes `"`
		- `&#039;` becomes `'`]]></haxe_doc>
		</htmlUnescape>
		<contains public="1" get="inline" set="null" line="211" static="1">
			<f a="s:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if `s` contains `value` and  `false` otherwise.

		When `value` is `null`, the result is unspecified.</haxe_doc>
		</contains>
		<startsWith public="1" set="method" line="226" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` starts with the string `start`.

		If `start` is `null`, the result is unspecified.

		If `start` is the empty String `""`, the result is true.</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="249" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the string `s` ends with the string `end`.

		If `end` is `null`, the result is unspecified.

		If `end` is the empty String `""`, the result is true.</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="278" static="1">
			<f a="s:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string `s` at position `pos` is a space.

		A character is considered to be a space character if its character code
		is 9,10,11,12,13 or 32.

		If `s` is the empty String `""`, or if pos is not a valid position within
		`s`, the result is false.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="296" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="321" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing space characters of `s`.

		This function internally calls `isSpace()` to decide which characters to
		remove.

		If `s` is the empty String `""` or consists only of space characters, the
		result is the empty String `""`.</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="343" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes leading and trailing space characters of `s`.

		This is a convenience function for `ltrim(rtrim(s))`.</haxe_doc>
		</trim>
		<lpad public="1" set="method" line="365" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Concatenates `c` to `s` until `s.length` is at least `l`.

		If `c` is the empty String `""` or if `l` does not exceed `s.length`,
		`s` is returned unchanged.

		If `c.length` is 1, the resulting String length is exactly `l`.

		Otherwise the length may exceed `l`.

		If `c` is null, the result is unspecified.</haxe_doc>
		</lpad>
		<rpad public="1" set="method" line="390" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Appends `c` to `s` until `s.length` is at least `l`.

		If `c` is the empty String `""` or if `l` does not exceed `s.length`,
		`s` is returned unchanged.

		If `c.length` is 1, the resulting String length is exactly `l`.

		Otherwise the length may exceed `l`.

		If `c` is null, the result is unspecified.</haxe_doc>
		</rpad>
		<replace public="1" set="method" line="412" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurrences of the String `sub` in the String `s` by the
		String `by`.

		If `sub` is the empty String `""`, `by` is inserted after each character
		of `s` except the last one. If `by` is also the empty String `""`, `s`
		remains unchanged.

		If `sub` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<hex public="1" set="method" line="434" static="1">
			<f a="n:?digits">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `n` into a hexadecimal representation.

		If `digits` is specified, the resulting String is padded with "0" until
		its `length` equals `digits`.</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="476" static="1">
			<f a="s:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the character code at position `index` of String `s`, or an
		end-of-file indicator at if `position` equals `s.length`.

		This method is faster than `String.charCodeAt()` on some platforms, but
		the result is unspecified if `index` is negative or greater than
		`s.length`.

		End of file status can be checked by calling `StringTools.isEof()` with
		the returned value as argument.

		This operation is not guaranteed to work if `s` contains the `\0`
		character.</haxe_doc>
		</fastCodeAt>
		<unsafeCodeAt public="1" get="inline" set="null" line="515" static="1">
			<f a="s:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the character code at position `index` of String `s`, or an
		end-of-file indicator at if `position` equals `s.length`.

		This method is faster than `String.charCodeAt()` on some platforms, but
		the result is unspecified if `index` is negative or greater than
		`s.length`.

		This operation is not guaranteed to work if `s` contains the `\0`
		character.</haxe_doc>
		</unsafeCodeAt>
		<iterator public="1" get="inline" set="null" line="550" static="1">
			<f a="s">
				<c path="String"/>
				<c path="haxe.iterators.StringIterator"/>
			</f>
			<haxe_doc>Returns an iterator of the char codes.

		Note that char codes may differ across platforms because of different
		internal encoding of strings in different runtimes.
		For the consistent cross-platform UTF8 char codes see `haxe.iterators.StringIteratorUnicode`.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="561" static="1">
			<f a="s">
				<c path="String"/>
				<c path="haxe.iterators.StringKeyValueIterator"/>
			</f>
			<haxe_doc>Returns an iterator of the char indexes and codes.

		Note that char codes may differ across platforms because of different
		internal encoding of strings in different of runtimes.
		For the consistent cross-platform UTF8 char codes see `haxe.iterators.StringKeyValueIteratorUnicode`.</haxe_doc>
		</keyValueIterator>
		<isEof public="1" get="inline" set="null" line="568" static="1">
			<f a="c">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noUsing"/></meta>
			<haxe_doc>Tells if `c` represents the end-of-file (EOF) character.</haxe_doc>
		</isEof>
		<quoteUnixArg public="1" set="method" line="589" static="1">
			<f a="argument">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":deprecated"><e>"StringTools.quoteUnixArg() is deprecated. Use haxe.SysTools.quoteUnixArg() instead."</e></m>
			</meta>
			<haxe_doc>Returns a String that can be used as a single command line argument
		on Unix.
		The input will be quoted, or escaped if necessary.</haxe_doc>
		</quoteUnixArg>
		<winMetaCharacters public="1" expr="cast haxe.SysTools.winMetaCharacters" line="598" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta>
				<m n=":value"><e>cast haxe.SysTools.winMetaCharacters</e></m>
				<m n=":noCompletion"/>
				<m n=":deprecated"><e>"StringTools.winMetaCharacters is deprecated. Use haxe.SysTools.winMetaCharacters instead."</e></m>
			</meta>
			<haxe_doc>Character codes of the characters that will be escaped by `quoteWinArg(_, true)`.</haxe_doc>
		</winMetaCharacters>
		<quoteWinArg public="1" set="method" line="615" static="1">
			<f a="argument:escapeMetaCharacters">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":deprecated"><e>"StringTools.quoteWinArg() is deprecated. Use haxe.SysTools.quoteWinArg() instead."</e></m>
			</meta>
			<haxe_doc>Returns a String that can be used as a single command line argument
		on Windows.
		The input will be quoted, or escaped if necessary, such that the output
		will be parsed as a single argument using the rule specified in
		http://msdn.microsoft.com/en-us/library/ms880421

		Examples:
		```haxe
		quoteWinArg("abc") == "abc";
		quoteWinArg("ab c") == '"ab c"';
		```</haxe_doc>
		</quoteWinArg>
		<MIN_SURROGATE_CODE_POINT get="inline" set="null" expr="65536" line="630" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>65536</e></m></meta>
		</MIN_SURROGATE_CODE_POINT>
		<utf16CodePointAt get="inline" set="null" line="632" static="1"><f a="s:index">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
</f></utf16CodePointAt>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)
	to the `String` class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="Sys" params="" file="/home/travis/haxe/std/Sys.hx" extern="1">
		<print public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Prints any value to the standard output.</haxe_doc>
		</print>
		<println public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Prints any value to the standard output, followed by a newline.
		On Windows, this function outputs a CRLF newline.
		LF newlines are printed on all other platforms.</haxe_doc>
		</println>
		<args public="1" set="method" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>Returns all the arguments that were passed in the command line.
		This does not include the interpreter or the name of the program file.

		(java)(eval) On Windows, non-ASCII Unicode arguments will not work correctly.

		(cs) Non-ASCII Unicode arguments will not work correctly.</haxe_doc>
		</args>
		<getEnv public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the value of the given environment variable, or `null` if it
		doesn't exist.</haxe_doc>
		</getEnv>
		<putEnv public="1" set="method" static="1">
			<f a="s:v">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the value of the given environment variable.

		(java) This functionality is not available on Java; calling this function will throw.</haxe_doc>
		</putEnv>
		<environment public="1" set="method" static="1">
			<f a=""><t path="Map">
	<c path="String"/>
	<c path="String"/>
</t></f>
			<haxe_doc>Returns all environment variables.</haxe_doc>
		</environment>
		<sleep public="1" set="method" static="1">
			<f a="seconds">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Suspends execution for the given length of time (in seconds).</haxe_doc>
		</sleep>
		<setTimeLocale public="1" set="method" static="1">
			<f a="loc">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Changes the current time locale, which will affect `DateTools.format` date formating.
		Returns `true` if the locale was successfully changed.</haxe_doc>
		</setTimeLocale>
		<getCwd public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Gets the current working directory (usually the one in which the program was started).</haxe_doc>
		</getCwd>
		<setCwd public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Changes the current working directory.

		(java) This functionality is not available on Java; calling this function will throw.</haxe_doc>
		</setCwd>
		<systemName public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the type of the current system. Possible values are:
		 - `"Windows"`
		 - `"Linux"`
		 - `"BSD"`
		 - `"Mac"`</haxe_doc>
		</systemName>
		<command public="1" set="method" static="1">
			<f a="cmd:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
			</f>
			<haxe_doc>Runs the given command. The command output will be printed to the same output as the current process.
		The current process will block until the command terminates.
		The return value is the exit code of the command (usually `0` indicates no error).

		Command arguments can be passed in two ways:

		 1. Using `args` to pass command arguments. Each argument will be automatically quoted and shell meta-characters will be escaped if needed.
		`cmd` should be an executable name that can be located in the `PATH` environment variable, or a full path to an executable.

		 2. When `args` is not given or is `null`, command arguments can be appended to `cmd`. No automatic quoting/escaping will be performed. `cmd` should be formatted exactly as it would be when typed at the command line.
		It can run executables, as well as shell commands that are not executables (e.g. on Windows: `dir`, `cd`, `echo` etc).

		Use the `sys.io.Process` API for more complex tasks, such as background processes, or providing input to the command.</haxe_doc>
		</command>
		<exit public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Exits the current process with the given exit code.

		(macro)(eval) Being invoked in a macro or eval context (e.g. with `-x` or `--run`) immediately terminates
		the compilation process, which also prevents the execution of any `--next` sections of compilation arguments.</haxe_doc>
		</exit>
		<time public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value available (in seconds).</haxe_doc>
		</time>
		<cpuTime public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value available (in seconds),
		but only accounts for the actual time spent running on the CPU for the current thread/process.</haxe_doc>
		</cpuTime>
		<executablePath public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":deprecated"><e>"Use programPath instead"</e></m></meta>
			<haxe_doc>Returns the path to the current executable that we are running.</haxe_doc>
		</executablePath>
		<programPath public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the absolute path to the current program file that we are running.
		Concretely, for an executable binary, it returns the path to the binary.
		For a script (e.g. a PHP file), it returns the path to the script.</haxe_doc>
		</programPath>
		<getChar public="1" set="method" static="1">
			<f a="echo">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads a single input character from the standard input and returns it.
		Setting `echo` to `true` will also display the character on the output.</haxe_doc>
		</getChar>
		<stdin public="1" set="method" static="1">
			<f a=""><c path="haxe.io.Input"/></f>
			<haxe_doc>Returns the standard input of the process, from which user input can be read.
		Usually it will block until the user sends a full input line.
		See `getChar` for an alternative.</haxe_doc>
		</stdin>
		<stdout public="1" set="method" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the standard output of the process, to which program output can be written.</haxe_doc>
		</stdout>
		<stderr public="1" set="method" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the standard error of the process, to which program errors can be written.</haxe_doc>
		</stderr>
		<haxe_doc>This class provides access to various base functions of system platforms.
	Look in the `sys` package for more system APIs.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":require"><e>sys</e></m>
		</meta>
	</class>
	<class path="Type" params="" file="/home/travis/haxe/std/Type.hx" extern="1">
		<getClass public="1" params="T" set="method" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.

		If `o` is null or of a different type, null is returned.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" static="1">
			<f a="o">
				<x path="EnumValue"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc><![CDATA[Returns the enum of enum instance `o`.

		An enum instance is the result of using an enum constructor. Given an
		`enum Color { Red; }`, `getEnum(Red)` returns `Enum<Color>`.

		If `o` is null, null is returned.

		In general, type parameter information cannot be obtained at runtime.]]></haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Returns the super-class of class `c`.

		If `c` has no super class, null is returned.

		If `c` is null, the result is unspecified.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of class `c`, including its path.

		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `c` has no package, the class name is returned.

		If `c` is null, the result is unspecified.

		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		`pack1.pack2.(...).packN.EnumName`
		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Resolves a class by name.

		If `name` is the path of an existing class, that class is returned.

		Otherwise null is returned.

		If `name` is null or the path to a different type, the result is
		unspecified.

		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc>Resolves an enum by name.

		If `name` is the path of an existing enum, that enum is returned.

		Otherwise null is returned.

		If `name` is null the result is unspecified.

		If `name` is the path to a different type, null is returned.

		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.

		This function guarantees that the class constructor is called.

		Default values of constructors arguments are not guaranteed to be
		taken into account.

		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.

		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`.

		This function guarantees that the class constructor is not called.

		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createEnum.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createEnumIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the instance fields of class `c`, including
		inherited fields.

		This only includes fields which are known at compile-time. In
		particular, using `getInstanceFields(getClass(obj))` will not include
		any fields which were added to `obj` at runtime.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of static fields of class `c`.

		This does not include static fields of parent classes.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of value `v`.

		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumParameters>
		<enumIndex public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" static="1">
			<f a="e">
				<x path="Enum"><c path="allEnums.T"/></x>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</allEnums>
		<haxe_doc>The Haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.

	@see https://haxe.org/manual/types.html
	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="ValueType" params="" file="/home/travis/haxe/std/Type.hx" module="Type">
		<TNull/>
		<TInt/>
		<TFloat/>
		<TBool/>
		<TObject/>
		<TFunction/>
		<TClass a="c"><x path="Class"><d/></x></TClass>
		<TEnum a="e"><x path="Enum"><d/></x></TEnum>
		<TUnknown/>
		<haxe_doc>The different possible runtime types of a value.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="connect.Base" params="" file="connect/Base.hx"><meta><m n=":dox"><e>hide</e></m></meta></class>
	<class path="connect.Config" params="" file="connect/Config.hx">
		<extends path="connect.Base"/>
		<getApiUrl public="1" set="method" line="31">
			<f a=""><c path="String"/></f>
			<haxe_doc>@returns Endpoint to interact with Connect API.</haxe_doc>
		</getApiUrl>
		<getApiKey public="1" set="method" line="39">
			<f a=""><c path="String"/></f>
			<haxe_doc>@returns Authorization key.</haxe_doc>
		</getApiKey>
		<hasProduct public="1" set="method" line="51">
			<f a="productId">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells whether the configuration is setup to process the specified product.

        @param productId The id of the product.
        @returns `true` if the configuration is setup to process the specified product,
        `false` otherwise.</haxe_doc>
		</hasProduct>
		<getProductsString public="1" set="method" line="62">
			<f a=""><c path="String"/></f>
			<haxe_doc>Get the entire list of products supported by this configuration, or an empty string
        if the configuration does not contain a product list.

        @returns A string with a comma-separated list of products.</haxe_doc>
		</getProductsString>
		<getData public="1" set="method" line="72">
			<f a="key">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>@returns The value of the data with the given key stored in the config. When config
            is loaded from a file, all the additional data found in the file is included
            in the config and can be retrieved with this method.</haxe_doc>
		</getData>
		<apiUrl><c path="String"/></apiUrl>
		<apiKey><c path="String"/></apiKey>
		<products><c path="connect.util.Collection"><c path="String"/></c></products>
		<data><c path="connect.util.Dictionary"/></data>
		<new public="1" set="method" line="20">
			<f a="apiUrl:apiKey:products:data">
				<c path="String"/>
				<c path="String"/>
				<c path="connect.util.Collection"><c path="String"/></c>
				<c path="connect.util.Dictionary"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Config object. You don't normally create objects of this class,
        since the SDK uses the default instance provided by `Env.getConfig()`.</haxe_doc>
		</new>
		<haxe_doc>This class contains the configuration required for communication with the Connect platform.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.util.Dictionary" params="" file="connect/util/Dictionary.hx">
		<extends path="connect.Base"/>
		<fromObject public="1" set="method" line="285" static="1">
			<f a="obj">
				<d/>
				<c path="connect.util.Dictionary"/>
			</f>
			<haxe_doc>Returns a Dictionary with the same contents as the given dynamic object.
        Dynamic object is a native Haxe feature, and can be hard to work with in the target
        languages, so this method exists so you can work with their data using the
        `Dictionary` methods.

        All arrays within the object will be converted to collections.

        Classes in the `connect.api` package work with dynamic objects.</haxe_doc>
		</fromObject>
		<toObject_r set="method" line="298" static="1"><f a="x">
	<d/>
	<x path="haxe.extern.EitherType">
		<c path="Array"><d/></c>
		<d/>
	</x>
</f></toObject_r>
		<fromObject_r set="method" line="327" static="1"><f a="x">
	<d/>
	<d/>
</f></fromObject_r>
		<clear public="1" set="method" line="28">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all keys from `this` Dictionary.</haxe_doc>
		</clear>
		<copy public="1" set="method" line="37">
			<f a=""><c path="connect.util.Dictionary"/></f>
			<haxe_doc>Returns a shallow copy of `this` Dictionary.
        The order of values is undefined.</haxe_doc>
		</copy>
		<exists public="1" set="method" line="50">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `key` has a mapping, false otherwise.
        If `key` is `null`, the result is unspecified.</haxe_doc>
		</exists>
		<get public="1" set="method" line="69">
			<f a="key">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the current mapping of `key` as an Object.

        If no such mapping exists, null is returned.

        Note that a check like `dict.get(key) == null` can hold for two reasons:

        1. The dictionary has no mapping for `key`
        2. The dictionary has a mapping with a value of `null`

        If it is important to distinguish these cases, `exists()` should be used.
        
        If `key` is null, the result is unspecified.</haxe_doc>
		</get>
		<getBool public="1" set="method" line="88">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns the current mapping of `key` as a Bool.

        If no such mapping exists, false is returned.

        Note that a check like `dict.get(key) == false` can hold for two reasons:

        1. The dictionary has no mapping for `key`
        2. The dictionary has a mapping with a value of `false`

        If it is important to distinguish these cases, `exists()` should be used.

        If `key` is null, the result is unspecified.</haxe_doc>
		</getBool>
		<getInt public="1" set="method" line="111">
			<f a="key">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the current mapping of `key` as an Int.

        If no such mapping exists, 0 is returned.

        Note that a check like `dict.get(key) == 0` can hold for two reasons:

        1. The dictionary has no mapping for `key`
        2. The dictionary has a mapping with a value of `0`

        If it is important to distinguish these cases, `exists()` should be used.
        
        If `key` is null, the result is unspecified.</haxe_doc>
		</getInt>
		<getFloat public="1" set="method" line="134">
			<f a="key">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the current mapping of `key` as a Float.

        If no such mapping exists, 0.0 is returned.

        Note that a check like `dict.get(key) == 0.0` can hold for two reasons:

        1. The dictionary has no mapping for `key`
        2. The dictionary has a mapping with a value of `0.0`

        If it is important to distinguish these cases, `exists()` should be used.
        
        If `key` is null, the result is unspecified.</haxe_doc>
		</getFloat>
		<getString public="1" set="method" line="157">
			<f a="key">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the current mapping of `key` as a String.

        If no such mapping exists, an empty string is returned.

        Note that a check like `dict.get(key) == ""` can hold for two reasons:

        1. The dictionary has no mapping for `key`
        2. The dictionary has a mapping with a value of `""`

        If it is important to distinguish these cases, `exists()` should be used.
        
        If `key` is null, the result is unspecified.</haxe_doc>
		</getString>
		<iterator public="1" set="method" line="170">
			<f a=""><t path="Iterator"><d/></t></f>
			<haxe_doc>Returns an Iterator over the values of `this` Dictionary.
        The order of values is undefined.</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="179">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an Iterator over the keys of `this` Dictionary.
        The order of keys is undefined.</haxe_doc>
		</keys>
		<isEmpty public="1" set="method" line="187">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns true if `this` Dictionary has not keys
        @return Bool</haxe_doc>
		</isEmpty>
		<remove public="1" set="method" line="196">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the mapping of `key` and returns true if such a mapping existed,
        false otherwise.
        If `key` is `null`, the result is unspecified.</haxe_doc>
		</remove>
		<set public="1" set="method" line="206">
			<f a="key:value">
				<c path="String"/>
				<d/>
				<c path="connect.util.Dictionary"/>
			</f>
			<haxe_doc>Maps `key` to a `value`.
        If `key` already has a mapping, the previous value disappears.
        If `key` is null, the result is unspecified.</haxe_doc>
		</set>
		<setBool public="1" set="method" line="217">
			<f a="key:x">
				<c path="String"/>
				<x path="Bool"/>
				<c path="connect.util.Dictionary"/>
			</f>
			<haxe_doc>Maps `key` to a Bool `value`.
        If `key` already has a mapping, the previous value disappears.
        If `key` is null, the result is unspecified.</haxe_doc>
		</setBool>
		<setInt public="1" set="method" line="227">
			<f a="key:x">
				<c path="String"/>
				<x path="Int"/>
				<c path="connect.util.Dictionary"/>
			</f>
			<haxe_doc>Maps `key` to an Int `value`.
        If `key` already has a mapping, the previous value disappears.
        If `key` is null, the result is unspecified.</haxe_doc>
		</setInt>
		<setFloat public="1" set="method" line="237">
			<f a="key:x">
				<c path="String"/>
				<x path="Float"/>
				<c path="connect.util.Dictionary"/>
			</f>
			<haxe_doc>Maps `key` to a Float `value`.
        If `key` already has a mapping, the previous value disappears.
        If `key` is null, the result is unspecified.</haxe_doc>
		</setFloat>
		<setString public="1" set="method" line="247">
			<f a="key:x">
				<c path="String"/>
				<c path="String"/>
				<c path="connect.util.Dictionary"/>
			</f>
			<haxe_doc>Maps `key` to a String `value`.
        If `key` already has a mapping, the previous value disappears.
        If `key` is null, the result is unspecified.</haxe_doc>
		</setString>
		<toString public="1" set="method" line="255">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a JSON string representation of `this` Dictionary.</haxe_doc>
		</toString>
		<toObject public="1" set="method" line="270">
			<f a=""><d/></f>
			<haxe_doc>Returns a dynamic object with the same contents as the `this` Dictionary.
        Dynamic object is a native Haxe feature, and can be hard to work with in the target
        languages, so this method exists so you can work with their data using the
        `Dictionary` methods and then convert them back to dynamic objects.

        All collections within the object will be converted to arrays.

        Classes in the `connect.api` package work with dynamic objects</haxe_doc>
		</toObject>
		<map final="1"><c path="haxe.ds.StringMap"><d/></c></map>
		<new public="1" set="method" line="20">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Dictionary.</haxe_doc>
		</new>
		<haxe_doc>A Dictionary allows mapping of String keys to arbitrary values. If the value of a key is given
    one type and then retrieved with a different type (for example, `setInt` ... `getObject`), the
    result is unspecified.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.IMap" params="K:V" file="/home/travis/haxe/std/haxe/Constraints.hx" module="haxe.Constraints" interface="1">
		<get public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<x path="Null"><c path="haxe.IMap.V"/></x>
</f></get>
		<set public="1" set="method"><f a="k:v">
	<c path="haxe.IMap.K"/>
	<c path="haxe.IMap.V"/>
	<x path="Void"/>
</f></set>
		<exists public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<x path="Bool"/>
</f></exists>
		<remove public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<x path="Bool"/>
</f></remove>
		<keys public="1" set="method"><f a=""><t path="Iterator"><c path="haxe.IMap.K"/></t></f></keys>
		<iterator public="1" set="method"><f a=""><t path="Iterator"><c path="haxe.IMap.V"/></t></f></iterator>
		<keyValueIterator public="1" set="method"><f a=""><t path="KeyValueIterator">
	<c path="haxe.IMap.K"/>
	<c path="haxe.IMap.V"/>
</t></f></keyValueIterator>
		<copy public="1" set="method"><f a=""><c path="haxe.IMap">
	<c path="haxe.IMap.K"/>
	<c path="haxe.IMap.V"/>
</c></f></copy>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
	</class>
	<class path="haxe.ds.StringMap" params="T" file="/home/travis/haxe/std/haxe/ds/StringMap.hx" extern="1">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Null"><c path="haxe.ds.StringMap.T"/></x>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" set="method">
			<f a=""><t path="KeyValueIterator">
	<c path="String"/>
	<c path="haxe.ds.StringMap.T"/>
</t></f>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method">
			<f a=""><c path="haxe.ds.StringMap"><c path="haxe.ds.StringMap.T"/></c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.Env" params="" file="connect/Env.hx">
		<extends path="connect.Base"/>
		<config static="1"><c path="connect.Config"/></config>
		<loggers expr="new Dictionary()" line="50" static="1">
			<c path="connect.util.Dictionary"/>
			<meta><m n=":value"><e>new Dictionary()</e></m></meta>
		</loggers>
		<defaultQuery static="1"><c path="connect.api.Query"/></defaultQuery>
		<apiClient static="1"><c path="connect.api.IApiClient"/></apiClient>
		<fulfillmentApi static="1"><c path="connect.api.FulfillmentApi"/></fulfillmentApi>
		<usageApi static="1"><c path="connect.api.UsageApi"/></usageApi>
		<tierApi static="1"><c path="connect.api.TierApi"/></tierApi>
		<generalApi static="1"><c path="connect.api.GeneralApi"/></generalApi>
		<marketplaceApi static="1"><c path="connect.api.MarketplaceApi"/></marketplaceApi>
		<subscriptionsApi static="1"><c path="connect.api.SubscriptionsApi"/></subscriptionsApi>
		<ROOT_LOGGER get="inline" set="null" expr="&quot;root&quot;" line="60" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"root"</e></m></meta>
		</ROOT_LOGGER>
		<initConfig public="1" set="method" line="71" static="1">
			<f a="apiUrl:apiKey:products">
				<c path="String"/>
				<c path="String"/>
				<c path="connect.util.Collection"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Initializes the configuration object. It must have not been previously configured.

        @param apiUrl Value for the apiUrl property.
        @param apiKey Value for the apiKey property.
        @param products Collection of product ids that can be processed with this configuration.
        @throws String If the configuration is already initialized.</haxe_doc>
		</initConfig>
		<loadConfig public="1" set="method" line="87" static="1">
			<f a="filename">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Initializes the configuration object using a JSON file.  It must have not been previously
        configured.

        @param filename Name of the configuration JSON file to parse.
        @throws Exception If the file cannot be parsed.
        @throws String If the configuration is already initialized.</haxe_doc>
		</loadConfig>
		<isConfigInitialized public="1" set="method" line="110" static="1">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>@returns `true` if config has already been initialized, `false` otherwise.</haxe_doc>
		</isConfigInitialized>
		<initLogger public="1" set="method" line="119" static="1">
			<f a="config">
				<c path="connect.logger.LoggerConfig"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Initializes the logger. It must have not been previously configured.

        @param config The configuration of the logger.</haxe_doc>
		</initLogger>
		<getLoggerForRequest public="1" set="method" line="130" static="1">
			<f a="request">
				<x path="Null"><c path="connect.models.IdModel"/></x>
				<c path="connect.logger.Logger"/>
			</f>
			<haxe_doc>Get logger for given request, if it doesnt exists it will be created and context specified.</haxe_doc>
		</getLoggerForRequest>
		<isLoggerInitialized public="1" set="method" line="147" static="1">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>@returns `true` if logger has already been initialized, `false` otherwise.</haxe_doc>
		</isLoggerInitialized>
		<initDefaultQuery public="1" set="method" line="156" static="1">
			<f a="query">
				<c path="connect.api.Query"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Initializes the default `Query`. This query can contain common filters and be easily
     * embedded in any other query by using the `Query.default` method.
     * @param query The default `Query`.</haxe_doc>
		</initDefaultQuery>
		<isDefaultQueryInitialized public="1" set="method" line="167" static="1">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* @returns `true` if default query has already been set, `false` otherwise;</haxe_doc>
		</isDefaultQueryInitialized>
		<getConfig public="1" set="method" line="179" static="1">
			<f a=""><c path="connect.Config"/></f>
			<haxe_doc>Returns the configuration object. If it is not initialized, it tries to initialize it from
        the file "config.json".

        @returns The environment config.
        @throws Exception If the instance is not initialized and the file "config.json" cannot be
            parsed.</haxe_doc>
		</getConfig>
		<getLogger public="1" set="method" line="192" static="1">
			<f a=""><c path="connect.logger.Logger"/></f>
			<haxe_doc>Returns the logger object. If it is not initialized, it will initialize it in the level
        `Info` with the path "logs".

        @returns The environment logger.</haxe_doc>
		</getLogger>
		<getApiClient public="1" set="method" line="203" static="1">
			<f a=""><c path="connect.api.IApiClient"/></f>
			<haxe_doc>@returns The API Client, used to make all low level Http requests to the platform.
        @throws String If a class implementing the IApiClient interface cannot be instanced.</haxe_doc>
		</getApiClient>
		<getFulfillmentApi public="1" set="method" line="211" static="1">
			<f a=""><c path="connect.api.FulfillmentApi"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</getFulfillmentApi>
		<getUsageApi public="1" set="method" line="219" static="1">
			<f a=""><c path="connect.api.UsageApi"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</getUsageApi>
		<getTierApi public="1" set="method" line="227" static="1">
			<f a=""><c path="connect.api.TierApi"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</getTierApi>
		<getGeneralApi public="1" set="method" line="235" static="1">
			<f a=""><c path="connect.api.GeneralApi"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</getGeneralApi>
		<getSubscriptionsApi public="1" set="method" line="243" static="1">
			<f a=""><c path="connect.api.SubscriptionsApi"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</getSubscriptionsApi>
		<getMarketplaceApi public="1" set="method" line="251" static="1">
			<f a=""><c path="connect.api.MarketplaceApi"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</getMarketplaceApi>
		<_reset public="1" set="method" line="259" static="1">
			<f a="?client" v="null">
				<c path="connect.api.IApiClient"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ client : null }</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_reset>
		<_getDefaultQuery public="1" set="method" line="273" static="1">
			<f a=""><c path="connect.api.Query"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_getDefaultQuery>
		<haxe_doc>In order to be able to perform their tasks, many classes in the SDK rely on the global
    availability of several objects. For example, the URL and credentials used to communicate
    with the platform are defined in an instance of the `connect.Config` class, while the
    ability to perform Http requests is performed by an instance of a class that implements
    the `connect.api.IApiClient` interface.

    Since these dependencies must be globally available, the `Env` class contains static
    methods to obtain the default instances of these classes from anywhere. To minimize the
    side-effects that can be caused by changes in the values of global objects in a program,
    all environment objects are immutable, providing a side-effect free context for the program
    to run.

    All objects returned here are lazy-initialized, meaning that they are not created until they
    are requested. In order to provide the connector configuration, a call to
    `Env.initConfig` or `Env.loadConfig` can be provided at the top of the program.
    Otherwise, the configuration will be automatically loaded from the "config.json" file.

    Likewise, the `Logger` can be initialized with a call to `Env.initLogger`, assuming it has not
    been done yet.

    Many of the objects returned by this class are defined in a public interface, with a default
    implementation provided by the environment. This is because when unit testing, these classes
    get replaced through dependency injection by mocked ones, allowing to a sandboxed unit testing
    environment.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="connect.FilterFunc" params="" file="connect/Flow.hx" module="connect.Flow">
		<f a="">
			<c path="connect.models.IdModel"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</typedef>
	<class path="connect.flow.FlowStoreDelegate" params="" file="connect/flow/FlowStoreDelegate.hx" interface="1">
		<onLoad public="1" set="method"><f a="request:firstStep:data:storageType:numAttempts">
	<c path="connect.models.IdModel"/>
	<x path="Int"/>
	<c path="connect.util.Dictionary"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onLoad>
		<onFailedLoad public="1" set="method"><f a="request">
	<c path="connect.models.IdModel"/>
	<x path="Void"/>
</f></onFailedLoad>
		<onConnectSave public="1" set="method"><f a="request">
	<c path="connect.models.IdModel"/>
	<x path="Void"/>
</f></onConnectSave>
		<onLocalSave public="1" set="method"><f a="request">
	<c path="connect.models.IdModel"/>
	<x path="Void"/>
</f></onLocalSave>
		<onFailedSave public="1" set="method"><f a="request">
	<c path="connect.models.IdModel"/>
	<x path="Void"/>
</f></onFailedSave>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</class>
	<class path="connect.flow.FlowExecutorDelegate" params="" file="connect/flow/FlowExecutorDelegate.hx" interface="1">
		<onStepBegin public="1" set="method"><f a="request:step:index">
	<c path="connect.models.IdModel"/>
	<c path="connect.flow.Step"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onStepBegin>
		<onStepEnd public="1" set="method"><f a="request:step:index">
	<c path="connect.models.IdModel"/>
	<c path="connect.flow.Step"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onStepEnd>
		<onStepFail public="1" set="method"><f a="request:step:index:msg">
	<c path="connect.models.IdModel"/>
	<c path="connect.flow.Step"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></onStepFail>
		<onStepSkip public="1" set="method"><f a="request:step:index">
	<c path="connect.models.IdModel"/>
	<c path="connect.flow.Step"/>
	<x path="Int"/>
	<x path="Void"/>
</f></onStepSkip>
		<onStepAbort public="1" set="method"><f a="request:step:index:msg">
	<c path="connect.models.IdModel"/>
	<c path="connect.flow.Step"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></onStepAbort>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</class>
	<class path="connect.Flow" params="" file="connect/Flow.hx">
		<extends path="connect.Base"/>
		<implements path="connect.flow.FlowStoreDelegate"/>
		<implements path="connect.flow.FlowExecutorDelegate"/>
		<SKIP_MSG final="1" set="null" expr="&quot;Skipping request because an exception was thrown: &quot;" line="41" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"Skipping request because an exception was thrown: "</e></m></meta>
		</SKIP_MSG>
		<filterFunc final="1"><t path="connect.FilterFunc"/></filterFunc>
		<skipRequestOnPendingMigration><x path="Bool"/></skipRequestOnPendingMigration>
		<executor final="1"><c path="connect.flow.FlowExecutor"/></executor>
		<logger final="1"><c path="connect.flow.FlowLogger"/></logger>
		<store final="1"><c path="connect.flow.FlowStore"/></store>
		<request><c path="connect.models.IdModel"/></request>
		<data><c path="connect.util.Dictionary"/></data>
		<volatileData><c path="connect.util.Dictionary"/></volatileData>
		<firstStep><x path="Int"/></firstStep>
		<lastRequestState><c path="connect.flow.ProcessedRequestInfo"/></lastRequestState>
		<stepAttempt><x path="Int"/></stepAttempt>
		<getClassName set="method" line="76"><f a=""><c path="String"/></f></getClassName>
		<setStoreRequestOnFailure public="1" set="method" line="95">
			<f a="enable">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Enables or disables storing of request data when the Flow fails execution. Defaults to true.</haxe_doc>
		</setStoreRequestOnFailure>
		<storesRequestOnFailure public="1" set="method" line="102">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Tells if the flow stores request data when Flow execution fails.</haxe_doc>
		</storesRequestOnFailure>
		<setStoreNumAttempts public="1" set="method" line="110">
			<f a="enable">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Enables or disables storing the number of execution attempts when storing request data. If
        `setStoreRequestOnFailure` is set to `false`, this is ignored.</haxe_doc>
		</setStoreNumAttempts>
		<storesNumAttempts public="1" set="method" line="118">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Tells if the number of execution attempts is stored with the rest of request data. If
        `storesRequestOnFailure` is set to `false`, this is ignored.</haxe_doc>
		</storesNumAttempts>
		<setSkipRequestOnPendingMigration public="1" set="method" line="125">
			<f a="enable">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Enables or disables skipping the request when it is pending migration. Defaults to true.</haxe_doc>
		</setSkipRequestOnPendingMigration>
		<skipsRequestOnPendingMigration public="1" set="method" line="132">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Tells if requests are automatically skipped when they are pending migration.</haxe_doc>
		</skipsRequestOnPendingMigration>
		<setup public="1" set="method" line="146">
			<f a=""><x path="Void"/></f>
			<haxe_doc>The setup function is always called before executing the steps, independently of what is
        the first step that will be run. If you need some initialization tasks that you always
        need to perform independently of whether you are resuming from a previous execution
        or not, you can override this method and write your initialization tasks.

        If you are resuming from a previous execution and this method writes information with
        `Flow.setData`, that information will be overridden with the one restored from the
        previous execution.</haxe_doc>
		</setup>
		<step public="1" set="method" line="156">
			<f a="description:func">
				<c path="String"/>
				<t path="connect.flow.StepFunc"/>
				<c path="connect.Flow"/>
			</f>
			<haxe_doc>Defines a step of `this` Flow. Steps are executed sequentially by the Flow
        when its `run` method is invoked.

        @param description Description of what the step does, so the Flow can indicate it in the log.
        @param func The function to execute for this step. It receives `this` Flow as argument, and it cannot return a value.
        @returns `this` Flow, so calls to this method can be chained.</haxe_doc>
		</step>
		<getAssetRequest public="1" set="method" line="168">
			<f a=""><c path="connect.models.AssetRequest"/></f>
			<haxe_doc>This can be called within your steps to get the request being processed, as long as it
        is of the `AssetRequest` type.

        @returns The `AssetRequest` being processed, or `null` if current request is not of
        Fulfillment api.</haxe_doc>
		</getAssetRequest>
		<getListing public="1" set="method" line="179">
			<f a=""><c path="connect.models.Listing"/></f>
			<haxe_doc>This can be called within your steps to get the element being processed, as long as it
        is of the `Listing` type.

        @returns The `Listing` being processed, or `null` if current element is not of
        Listing api.</haxe_doc>
		</getListing>
		<getTierConfigRequest public="1" set="method" line="190">
			<f a=""><c path="connect.models.TierConfigRequest"/></f>
			<haxe_doc>This can be called within your steps to get the request being processed, as long as it
        is of the `TierConfigRequest` type.

        @returns The `TierConfigRequest` being processed, or `null` if current request is not of
        Tier api.</haxe_doc>
		</getTierConfigRequest>
		<getUsageFile public="1" set="method" line="201">
			<f a=""><c path="connect.models.UsageFile"/></f>
			<haxe_doc>This can be called within your steps to get the request being processed, as long as it
        is of the `UsageFile` type.

        @returns The `UsageFile` being processed, or `null` if current request is not of
        Usage api.</haxe_doc>
		</getUsageFile>
		<setData public="1" set="method" line="220">
			<f a="key:value">
				<c path="String"/>
				<d/>
				<c path="connect.Flow"/>
			</f>
			<haxe_doc>Steps can pass data to the next one using the return value, but this data could be lost if
        we need to access it several steps later. For this reason, every Flow has a dictionary
        of keys and values to store custom data, that can be set with this method and retreived
        later on with `getData`. It is VERY important for the correct function of the Flow
        to only rely on the data set using this mechanism, and NEVER add additional properties
        when creating a subclass of Flow, since this data would not be automatically saved
        to support resuming in case processing fails.

        @param key The name of the key that will be used to identify this data.
        @param value The value to store. It is recommended to use primitive types, strings,
        instances of `Model`, or other classes that implement a `toString` method so they
        can be serialized.
        @returns `this` Flow, so calls to this method can be chained.</haxe_doc>
		</setData>
		<setVolatileData public="1" set="method" line="233">
			<f a="key:value">
				<c path="String"/>
				<d/>
				<c path="connect.Flow"/>
			</f>
			<haxe_doc>This method follows the same goal as `setData`, but the data established with
        this method never gets saved in case processing fails. So this is ideal
        for storing data that can be safely recomputed on next execution, and we do
        not need to retrieve from saved data. If we store a value with both `setVolatileData`
        and `setData`, then `getData` will retrieve the persistent version set with `setData`,
        so be careful about that behaviour.</haxe_doc>
		</setVolatileData>
		<getData public="1" set="method" line="245">
			<f a="key">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Retrieves Flow data previously set with `setData` or `setVolatileData`.
        If the data has been set both as persistent as volatile, the persistent
        version is obtained.
        @param key The name of the key that identifies the data to be obtained.
        @returns The value of the data, or `null` if the key does not exist.</haxe_doc>
		</getData>
		<getDataKeys public="1" set="method" line="256">
			<f a=""><c path="connect.util.Collection"><c path="String"/></c></f>
			<haxe_doc><![CDATA[* @return Collection<String> The keys of all the data stored in the Flow.]]></haxe_doc>
		</getDataKeys>
		<approveByTemplate public="1" set="method" line="268">
			<f a="id">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Changes the status of the request being processed to "approved", sending the id
        of a Template to render on the portal.

        When using the Flow, this method should be used instead of `AssetRequest.approveByTemplate()` or
        `TierConfigRequest.approveByTemplate()`, since this take care of cleaning the stored step
        information, and automatically skips any further steps.</haxe_doc>
		</approveByTemplate>
		<approveByTile public="1" set="method" line="292">
			<f a="text">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Changes the status of the request being processed to "approved", rendering a tile on
        the portal with the given Markdown `text`.

        When using the Flow, this method should be used instead of `AssetRequest.approveByTile()` or
        `TierConfigRequest.approveByTile()`, since this take care of cleaning the stored step
        information, and automatically skips any further steps.</haxe_doc>
		</approveByTile>
		<fail public="1" set="method" line="309">
			<f a="reason">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Changes the status of the request being processed to "failed".

        When using the Flow, this method should be used instead of `AssetRequest.fail()` or
        `TierConfigRequest.fail()`, since this takes care of cleaning the stored step
        information, and automatically skips any further steps.</haxe_doc>
		</fail>
		<inquire public="1" set="method" line="338">
			<f a="templateId:params">
				<c path="String"/>
				<c path="connect.util.Collection"><c path="connect.models.Param"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Changes the status of the request being processed to "inquiring".

        When using the Flow, this method should be used instead of `AssetRequest.inquire()` or
        `TierConfigRequest.inquire()`, since this take care of cleaning the stored step
        information, and automatically skips any further steps. Also, this method calls `update`
        on the request before changing its status.

        @param templateId Id of the template to use in the portal, or `null` to not use any. This
        is only used for AssetRequests.
        @param params A collection of parameters to update. If `null` is passed, then the
        parameters that have changed in the request will be updated.</haxe_doc>
		</inquire>
		<pend public="1" set="method" line="361">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Changes the status of the request being processed to "pending".

        When using the Flow, this method should be used instead of `AssetRequest.pend()` or
        `TierConfigRequest.pend()`, since this take care of cleaning the stored step
        information, and automatically skips any further steps.</haxe_doc>
		</pend>
		<skip set="method" line="381">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Skips processing of the current request. Pending steps for the request will not be executed,
        and step data will be stored so it can be resumed in the next execution.</haxe_doc>
		</skip>
		<abort set="method" line="389">
			<f a="message">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Aborts processing of the current request. Pending steps for the request will not be executed,
        and `message` is printed if it is not an empty string or `null`.</haxe_doc>
		</abort>
		<_run public="1" params="T" set="method" line="394">
			<f a="list">
				<c path="connect.util.Collection"><c path="_run.T"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_run>
		<filterRequests params="T" set="method" line="401"><f a="list">
	<c path="connect.util.Collection"><c path="filterRequests.T"/></c>
	<c path="connect.util.Collection"><c path="filterRequests.T"/></c>
</f></filterRequests>
		<callRequestFilter params="T" set="method" line="407"><f a="m">
	<c path="callRequestFilter.T"/>
	<x path="Bool"/>
</f></callRequestFilter>
		<runRequest set="method" line="417"><f a="request">
	<c path="connect.models.IdModel"/>
	<x path="Void"/>
</f></runRequest>
		<prepareRequest set="method" line="430"><f a="request">
	<c path="connect.models.IdModel"/>
	<x path="Bool"/>
</f></prepareRequest>
		<processSetup set="method" line="442"><f a=""><x path="Bool"/></f></processSetup>
		<getCurrentAttempt public="1" set="method" line="464">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Provide current step attempt.
     * @return Int Number of times that this step has been executed</haxe_doc>
		</getCurrentAttempt>
		<onStepBegin public="1" set="method" line="469">
			<f a="request:step:index">
				<c path="connect.models.IdModel"/>
				<c path="connect.flow.Step"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</onStepBegin>
		<onStepEnd public="1" set="method" line="475">
			<f a="request:step:index">
				<c path="connect.models.IdModel"/>
				<c path="connect.flow.Step"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</onStepEnd>
		<onStepFail public="1" set="method" line="482">
			<f a="request:step:index:msg">
				<c path="connect.models.IdModel"/>
				<c path="connect.flow.Step"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</onStepFail>
		<onStepSkip public="1" set="method" line="492">
			<f a="request:step:index">
				<c path="connect.models.IdModel"/>
				<c path="connect.flow.Step"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</onStepSkip>
		<onStepAbort public="1" set="method" line="499">
			<f a="request:step:index:msg">
				<c path="connect.models.IdModel"/>
				<c path="connect.flow.Step"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</onStepAbort>
		<onLoad public="1" set="method" line="507">
			<f a="request:firstStep:data:storageType:numAttempts">
				<c path="connect.models.IdModel"/>
				<x path="Int"/>
				<c path="connect.util.Dictionary"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</onLoad>
		<onFailedLoad public="1" set="method" line="516">
			<f a="request">
				<c path="connect.models.IdModel"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</onFailedLoad>
		<onConnectSave public="1" set="method" line="520">
			<f a="request">
				<c path="connect.models.IdModel"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</onConnectSave>
		<onLocalSave public="1" set="method" line="525">
			<f a="request">
				<c path="connect.models.IdModel"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</onLocalSave>
		<onFailedSave public="1" set="method" line="530">
			<f a="request">
				<c path="connect.models.IdModel"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</onFailedSave>
		<new public="1" set="method" line="62">
			<f a="filterFunc">
				<t path="connect.FilterFunc"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Flow.

        @param filterFunc A function which is executed for every request listed by the `Processor`
        to which `this` Flow is attached. All requests for which the function returns `true` will
        be processed by `this` Flow when the Processor runs.</haxe_doc>
		</new>
		<haxe_doc>A Flow represents a set of steps within a `Processor` which are executed for all requests
    that return `true` for a given function. If `null` is passed, all requests will be processed.</haxe_doc>
	</class>
	<class path="connect.Inflection" params="" file="connect/Inflection.hx">
		<toCamelCase public="1" set="method" line="19" static="1">
			<f a="text:?capitalizeFirst" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ capitalizeFirst : false }</e></m></meta>
			<haxe_doc>Returns a string with the given text converted from snake_case to camelCase.

        If `capitalizeFirst` is true, then the string is returned as UpperCamelCase.</haxe_doc>
		</toCamelCase>
		<toSingular public="1" set="method" line="38" static="1">
			<f a="text">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string the trailing "s" removed from the given text, if it has one.</haxe_doc>
		</toSingular>
		<toSnakeCase public="1" set="method" line="51" static="1">
			<f a="text">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string with the given text converted from camelCase or UpperCamelCase to
        snake_case.</haxe_doc>
		</toSnakeCase>
		<haxe_doc>This class provides static methods for string transformation. For example,
    to change casing (snake_case, camelCase, UpperCamelCase), or to singularize a word.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="connect.Processor" params="" file="connect/Processor.hx">
		<extends path="connect.Base"/>
		<flows><c path="Array"><c path="connect.Flow"/></c></flows>
		<flow public="1" set="method" line="57">
			<f a="flow">
				<c path="connect.Flow"/>
				<c path="connect.Processor"/>
			</f>
			<haxe_doc>Defines a flow of `this` Processor. Steps in the are executed sequentially by the Processor
        when its `run` method is invoked for all the requests that return `true` in the filter
        function passed in the creation of the flow.

        @param flow The flow to add to the processor.
        @returns `this` Processor, so calls to this method can be chained.</haxe_doc>
		</flow>
		<processAssetRequests public="1" set="method" line="69">
			<f a="filters">
				<c path="connect.api.Query"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Processes all `AssetRequest` objects that match the given filters,
        executing in sequence all the flows defined for them.

        @param filters Filters to be used for listing requests. It can contain
        any of the filters specified for the `AssetRequest.list` method.</haxe_doc>
		</processAssetRequests>
		<processListings public="1" set="method" line="80">
			<f a="filters">
				<c path="connect.api.Query"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Processes all `Listing` objects that match the given filters,
        executing in sequence all the flows defined for them.

        @param filters Filters to be used for listing requests. It can contain
        any of the filters specified for the `Listing.list` method.</haxe_doc>
		</processListings>
		<processTierConfigRequests public="1" set="method" line="91">
			<f a="filters">
				<c path="connect.api.Query"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Processes all `TierConfigRequest` objects that match the given filters,
        executing in sequence all the flows defined for them.

        @param filters Filters to be used for listing requests. It can contain
        any of the filters specified for the `TierConfigRequest.list` method.</haxe_doc>
		</processTierConfigRequests>
		<processUsageFiles public="1" set="method" line="102">
			<f a="filters">
				<c path="connect.api.Query"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Processes all `UsageFile` objects that match the given filters,
        executing in sequence all the flows defined for them.

        @param filters Filters to be used for listing requests. It can contain
        any of the filters specified for the `UsageFile.list` method.</haxe_doc>
		</processUsageFiles>
		<run params="T" set="method" line="106">
			<f a="modelClass:filters">
				<x path="Class"><c path="run.T"/></x>
				<c path="connect.api.Query"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</run>
		<new public="1" set="method" line="45"><f a=""><x path="Void"/></f></new>
		<haxe_doc>The Processor helps automating the task of processing a list of requests, and updates the log
    automatically with all operations performed.

    A Processor splits the processing of requests into different flows. Each `Flow` will process
    the requests that return true for a given filter function that is specified when creating the
    flow. For example, you can create one flow for requests of type "purchase", another for the
    ones of type "cancel", etc.

    Then, each flow consist of a series of steps, where each step is a function that receives
    the flow itself as argument (so you can subclass `Flow` and add steps as instance methods).

    Once all flows have been defined, you must call the `Processor.processRequests`,
    `Processor.processUsageFiles`, or `Processor.processTierConfigRequests` method to process
    requests, depending on the type you want to process.

    If an exception is thrown on any step, the rest of the steps will be skipped, and the next
    time the Processor runs, the request will be processed again. If the `Asset` of the request has
    a parameter with the id "__sdk_processor_step" (without quotes), the data about the state of
    the processing will be stored in Connect, and when the request is processed again, it will
    resume from the step that failed, keeping all the data that was processed up until that point.

    You can check the `examples` folder of the SDK to check how to use the Processor in the
    supported target languages.</haxe_doc>
	</class>
	<class path="connect.api.ConnectHelper" params="" file="connect/api/ConnectHelper.hx">
		<logger static="1"><c path="connect.logger.Logger"/></logger>
		<setLogger public="1" set="method" line="17" static="1"><f a="logger">
	<c path="connect.logger.Logger"/>
	<x path="Void"/>
</f></setLogger>
		<getLogger public="1" set="method" line="22" static="1"><f a=""><c path="connect.logger.Logger"/></f></getLogger>
		<get public="1" set="method" line="42" static="1">
			<f a="resource:?id:?suffix:?params:?rqlParams:?logLevel" v="::::false:">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="connect.api.Query"/>
				<x path="Bool"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ rqlParams : false }</e></m></meta>
			<haxe_doc>Get a Connect resource if 'id' is specified, or a list of reosurces otherwise.

        @param resource Resource path (e.g. "requests" for the Fulfillment API).
        @param id Optional id of the resource to get.
        @param suffix Optional path suffix (i.e. "approve").
        @param params Query params.
        @param rqlParams Indicates whether params should be sent as SQL (query params otherwise).
        @param logLevel Log level to use.
        @returns A string with the response.
        @throws String if the request fails.</haxe_doc>
		</get>
		<put public="1" set="method" line="59" static="1">
			<f a="resource:id:suffix:body:?logLevel">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Put data to one Connect resource.

        @param resource Resource path (e.g. "requests" for the Fulfillment API).
        @param id Id of the resource to put data on.
        @param suffix Optional path suffix (i.e. "approve").
        @param body The body to put (normally the modified resource).
        @param logLevel Log level to use.
        @returns A string with the response.
        @throws String if the request fails.</haxe_doc>
		</put>
		<post public="1" set="method" line="76" static="1">
			<f a="resource:?id:?suffix:?body:?logLevel">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Post data to Connect.

        @param resource Resource path (e.g. "requests" for the Fulfillment API).
        @param id Optional id of the resource to post data to.
        @param suffix Optional path suffix (i.e. "approve").
        @param body The body to post.
        @param logLevel Log level to use.
        @returns An object.
        @throws String if the request fails.</haxe_doc>
		</post>
		<postFile public="1" set="method" line="95" static="1">
			<f a="resource:?id:?suffix:fileArg:fileName:fileContents:?logLevel">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="connect.util.Blob"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>Post a file to Connect using the Content-Type "multipart/form-data".

        @param resource Resource path (e.g. "requests" for the Fulfillment API).
        @param id Optional id of the resource to post data to.
        @param suffix Optional path suffix (i.e. "approve").
        @param argname Argument name in the request.
        @param filename Name of the file to send.
        @param contents Contents of the file.
        @param logLevel Log level to use.
        @returns An object.
        @throws String if the request fails.</haxe_doc>
		</postFile>
		<delete public="1" set="method" line="110" static="1">
			<f a="resource:id:?suffix:?logLevel">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Delete Connect resource.

        @param resource Resource path (e.g. "requests" for the Fulfillment API).
        @param id Id of the resource to delete.
        @param suffix Optional path suffix (i.e. "delete").
        @param logLevel Log level to use.
        @returns A string with the response.
        @throws String if the request fails.</haxe_doc>
		</delete>
		<connectSyncRequest set="method" line="118" static="1"><f a="method:path:headers:params:rqlParams:data:fileArg:fileName:fileContent:logLevel">
	<c path="String"/>
	<c path="String"/>
	<c path="connect.util.Dictionary"/>
	<x path="Null"><c path="connect.api.Query"/></x>
	<x path="Bool"/>
	<x path="Null"><c path="String"/></x>
	<x path="Null"><c path="String"/></x>
	<x path="Null"><c path="String"/></x>
	<x path="Null"><c path="connect.util.Blob"/></x>
	<x path="Null"><x path="Int"/></x>
	<c path="connect.api.Response"/>
</f></connectSyncRequest>
		<parsePath set="method" line="127" static="1"><f a="resource:?id:?suffix">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></parsePath>
		<getHeaders set="method" line="133" static="1">
			<f a="?addContentType" v="true">
				<x path="Bool"/>
				<c path="connect.util.Dictionary"/>
			</f>
			<meta><m n=":value"><e>{ addContentType : true }</e></m></meta>
		</getHeaders>
		<checkResponse set="method" line="144" static="1"><f a="response">
	<c path="connect.api.Response"/>
	<c path="String"/>
</f></checkResponse>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="connect.api.FulfillmentApi" params="" file="connect/api/FulfillmentApi.hx">
		<extends path="connect.Base"/>
		<REQUESTS_PATH final="1" set="null" expr="&quot;requests&quot;" line="11" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"requests"</e></m></meta>
		</REQUESTS_PATH>
		<TEMPLATES_PATH final="1" set="null" expr="&quot;templates&quot;" line="12" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"templates"</e></m></meta>
		</TEMPLATES_PATH>
		<ASSETS_PATH final="1" set="null" expr="&quot;assets&quot;" line="13" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"assets"</e></m></meta>
		</ASSETS_PATH>
		<listRequests public="1" set="method" line="18"><f a="filters">
	<c path="connect.api.Query"/>
	<c path="String"/>
</f></listRequests>
		<getRequest public="1" set="method" line="22"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getRequest>
		<createRequest public="1" set="method" line="26"><f a="body">
	<c path="String"/>
	<c path="String"/>
</f></createRequest>
		<updateRequest public="1" set="method" line="30"><f a="id:request">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></updateRequest>
		<changeRequestStatus public="1" set="method" line="34"><f a="id:status:data">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></changeRequestStatus>
		<assignRequest public="1" set="method" line="38"><f a="id:assignee">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></assignRequest>
		<renderTemplate public="1" set="method" line="42"><f a="id:requestId">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></renderTemplate>
		<listAssets public="1" set="method" line="47"><f a="filters">
	<c path="connect.api.Query"/>
	<c path="String"/>
</f></listAssets>
		<getAsset public="1" set="method" line="51"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getAsset>
		<getAssetRequests public="1" set="method" line="55"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getAssetRequests>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.api.GeneralApi" params="" file="connect/api/GeneralApi.hx">
		<extends path="connect.Base"/>
		<ACCOUNTS_PATH final="1" set="null" expr="&quot;accounts&quot;" line="11" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"accounts"</e></m></meta>
		</ACCOUNTS_PATH>
		<CONVERSATIONS_PATH final="1" set="null" expr="&quot;conversations&quot;" line="12" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"conversations"</e></m></meta>
		</CONVERSATIONS_PATH>
		<PRODUCTS_PATH final="1" set="null" expr="&quot;products&quot;" line="13" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"products"</e></m></meta>
		</PRODUCTS_PATH>
		<CATEGORIES_PATH final="1" set="null" expr="&quot;categories&quot;" line="14" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"categories"</e></m></meta>
		</CATEGORIES_PATH>
		<listAccounts public="1" set="method" line="19"><f a="filters">
	<c path="connect.api.Query"/>
	<c path="String"/>
</f></listAccounts>
		<createAccount public="1" set="method" line="23"><f a=""><c path="String"/></f></createAccount>
		<getAccount public="1" set="method" line="27"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getAccount>
		<listAccountUsers public="1" set="method" line="31"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></listAccountUsers>
		<getAccountUser public="1" set="method" line="35"><f a="id:userId">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></getAccountUser>
		<listConversations public="1" set="method" line="39"><f a="filters">
	<c path="connect.api.Query"/>
	<c path="String"/>
</f></listConversations>
		<createConversation public="1" set="method" line="43"><f a="data">
	<c path="String"/>
	<c path="String"/>
</f></createConversation>
		<getConversation public="1" set="method" line="47"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getConversation>
		<createConversationMessage public="1" set="method" line="51"><f a="id:data">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></createConversationMessage>
		<listProducts public="1" set="method" line="55"><f a="filters">
	<c path="connect.api.Query"/>
	<c path="String"/>
</f></listProducts>
		<getProduct public="1" set="method" line="59"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getProduct>
		<listProductActions public="1" set="method" line="63"><f a="id:filters">
	<c path="String"/>
	<c path="connect.api.Query"/>
	<c path="String"/>
</f></listProductActions>
		<getProductAction public="1" set="method" line="67"><f a="id:actionId">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></getProductAction>
		<getProductActionLink public="1" set="method" line="71"><f a="id:actionId">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></getProductActionLink>
		<getProductConnections public="1" set="method" line="77"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getProductConnections>
		<listProductItems public="1" set="method" line="81"><f a="id:filters">
	<c path="String"/>
	<c path="connect.api.Query"/>
	<c path="String"/>
</f></listProductItems>
		<listProductParameters public="1" set="method" line="85"><f a="id:filters">
	<c path="String"/>
	<c path="connect.api.Query"/>
	<c path="String"/>
</f></listProductParameters>
		<getProductParameter public="1" set="method" line="89"><f a="id:paramId">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></getProductParameter>
		<createProductParameter public="1" set="method" line="93"><f a="id:data">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></createProductParameter>
		<updateProductParameter public="1" set="method" line="97"><f a="id:paramId:data">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></updateProductParameter>
		<deleteProductParameter public="1" set="method" line="101"><f a="id:paramId">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></deleteProductParameter>
		<getProductTemplates public="1" set="method" line="105"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getProductTemplates>
		<getProductVersions public="1" set="method" line="109"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getProductVersions>
		<getProductVersion public="1" set="method" line="113"><f a="id:version">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
</f></getProductVersion>
		<getProductVersionActions public="1" set="method" line="117"><f a="id:version">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
</f></getProductVersionActions>
		<getProductVersionAction public="1" set="method" line="123"><f a="id:version:actionId">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></getProductVersionAction>
		<getProductVersionActionLink public="1" set="method" line="129"><f a="id:version:actionId">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></getProductVersionActionLink>
		<getProductVersionItems public="1" set="method" line="135"><f a="id:version">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
</f></getProductVersionItems>
		<getProductVersionParameters public="1" set="method" line="140"><f a="id:version">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
</f></getProductVersionParameters>
		<getProductVersionTemplates public="1" set="method" line="145"><f a="id:version">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
</f></getProductVersionTemplates>
		<listProductConfigurations public="1" set="method" line="150"><f a="id:filters">
	<c path="String"/>
	<c path="connect.api.Query"/>
	<c path="String"/>
</f></listProductConfigurations>
		<setProductConfigurationParam public="1" set="method" line="155"><f a="id:param">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></setProductConfigurationParam>
		<listProductAgreements public="1" set="method" line="159"><f a="id:filters">
	<c path="String"/>
	<c path="connect.api.Query"/>
	<c path="String"/>
</f></listProductAgreements>
		<listProductMedia public="1" set="method" line="163"><f a="id:filters">
	<c path="String"/>
	<c path="connect.api.Query"/>
	<c path="String"/>
</f></listProductMedia>
		<createProductMedia public="1" set="method" line="167"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></createProductMedia>
		<getProductMedia public="1" set="method" line="171"><f a="id:mediaId">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></getProductMedia>
		<updateProductMedia public="1" set="method" line="175"><f a="id:mediaId:media">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></updateProductMedia>
		<deleteProductMedia public="1" set="method" line="179"><f a="id:mediaId">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></deleteProductMedia>
		<listCategories public="1" set="method" line="183"><f a="filters">
	<c path="connect.api.Query"/>
	<c path="String"/>
</f></listCategories>
		<getCategory public="1" set="method" line="187"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getCategory>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.api.IApiClient" params="" file="connect/api/IApiClient.hx" interface="1">
		<syncRequest public="1" set="method">
			<f a="method:url:headers:body:fileArg:fileName:fileContent:certificate">
				<c path="String"/>
				<c path="String"/>
				<c path="connect.util.Dictionary"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="connect.util.Blob"/>
				<c path="String"/>
				<c path="connect.api.Response"/>
			</f>
			<haxe_doc>Sends a synchronous request.

        @param method The REST method to use (i.e. "GET", "POST", "PUT", "DELETE").
        @param url The full URL to send the request to, including query params.
        @param headers A `Dictionary` with the headers to use.
        @param body String encoded post body or `null`.
        @param fileArg Argument name of file to send in multipart requests, or `null`.
        @param fileName File name of file to send in multipart requests, or `null`.
        @param fileContent File content of file to send in multipart requests, or `null`.
        @param certificate Certificate to send in the request, or `null`.
        @returns A `Response` object.</haxe_doc>
		</syncRequest>
		<syncRequestWithLogger public="1" set="method">
			<f a="method:url:headers:body:fileArg:fileName:fileContent:certificate:logger:logLevel">
				<c path="String"/>
				<c path="String"/>
				<c path="connect.util.Dictionary"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="connect.util.Blob"/>
				<c path="String"/>
				<c path="connect.logger.Logger"/>
				<x path="Null"><x path="Int"/></x>
				<c path="connect.api.Response"/>
			</f>
			<haxe_doc>Same as `syncRequest`, but also allows configure `logger` and `logLevel` to use.</haxe_doc>
		</syncRequestWithLogger>
	</class>
	<class path="connect.api.MarketplaceApi" params="" file="connect/api/MarketplaceApi.hx">
		<AGREEMENTS_PATH final="1" public="1" set="null" expr="&quot;agreements&quot;" line="12" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"agreements"</e></m></meta>
		</AGREEMENTS_PATH>
		<LISTINGS_PATH final="1" public="1" set="null" expr="&quot;listings&quot;" line="13" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"listings"</e></m></meta>
		</LISTINGS_PATH>
		<LISTINGREQUESTS_PATH final="1" public="1" set="null" expr="&quot;listing-requests&quot;" line="14" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"listing-requests"</e></m></meta>
		</LISTINGREQUESTS_PATH>
		<MARKETPLACES_PATH final="1" public="1" set="null" expr="&quot;marketplaces&quot;" line="15" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"marketplaces"</e></m></meta>
		</MARKETPLACES_PATH>
		<listAgreements public="1" set="method" line="20"><f a="filters">
	<c path="connect.api.Query"/>
	<c path="String"/>
</f></listAgreements>
		<createAgreement public="1" set="method" line="24"><f a="body">
	<c path="String"/>
	<c path="String"/>
</f></createAgreement>
		<getAgreement public="1" set="method" line="28"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getAgreement>
		<updateAgreement public="1" set="method" line="32"><f a="id:body">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></updateAgreement>
		<removeAgreement public="1" set="method" line="36"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></removeAgreement>
		<listAgreementVersions public="1" set="method" line="40"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></listAgreementVersions>
		<newAgreementVersion public="1" set="method" line="44"><f a="id:body">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></newAgreementVersion>
		<getAgreementVersion public="1" set="method" line="48"><f a="id:version">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></getAgreementVersion>
		<removeAgreementVersion public="1" set="method" line="52"><f a="id:version">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></removeAgreementVersion>
		<listAgreementSubAgreements public="1" set="method" line="56"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></listAgreementSubAgreements>
		<createAgreementSubAgreement public="1" set="method" line="60"><f a="id:body">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></createAgreementSubAgreement>
		<listListings public="1" set="method" line="64"><f a="filters">
	<c path="connect.api.Query"/>
	<c path="String"/>
</f></listListings>
		<getListing public="1" set="method" line="68"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getListing>
		<putListing public="1" set="method" line="72"><f a="id:body">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></putListing>
		<listListingRequests public="1" set="method" line="76"><f a="filters">
	<c path="connect.api.Query"/>
	<c path="String"/>
</f></listListingRequests>
		<getListingRequest public="1" set="method" line="80"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getListingRequest>
		<createListingRequest public="1" set="method" line="84"><f a="body">
	<c path="String"/>
	<c path="String"/>
</f></createListingRequest>
		<assignListingRequest public="1" set="method" line="88"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></assignListingRequest>
		<unassignListingRequest public="1" set="method" line="92"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></unassignListingRequest>
		<changeListingRequestToDraft public="1" set="method" line="96"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></changeListingRequestToDraft>
		<changeListingRequestToDeploying public="1" set="method" line="100"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></changeListingRequestToDeploying>
		<changeListingRequestToCompleted public="1" set="method" line="104"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></changeListingRequestToCompleted>
		<changeListingRequestToCanceled public="1" set="method" line="108"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></changeListingRequestToCanceled>
		<changeListingRequestToReviewing public="1" set="method" line="112"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></changeListingRequestToReviewing>
		<listMarketplaces public="1" set="method" line="116"><f a="filters">
	<c path="connect.api.Query"/>
	<c path="String"/>
</f></listMarketplaces>
		<createMarketplace public="1" set="method" line="120"><f a="body">
	<c path="String"/>
	<c path="String"/>
</f></createMarketplace>
		<getMarketplace public="1" set="method" line="124"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getMarketplace>
		<updateMarketplace public="1" set="method" line="128"><f a="id:body">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></updateMarketplace>
		<setMarketplaceIcon public="1" set="method" line="132"><f a="id:data">
	<c path="String"/>
	<c path="connect.util.Blob"/>
	<x path="Void"/>
</f></setMarketplaceIcon>
		<deleteMarketplace public="1" set="method" line="136"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></deleteMarketplace>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.api.Query" params="" file="connect/api/Query.hx">
		<extends path="connect.Base"/>
		<fromObject public="1" set="method" line="408" static="1"><f a="obj">
	<d/>
	<c path="connect.api.Query"/>
</f></fromObject>
		<fromJson public="1" set="method" line="473" static="1"><f a="json">
	<c path="String"/>
	<c path="connect.api.Query"/>
</f></fromJson>
		<stringMapToObject set="method" line="497" static="1"><f a="map">
	<c path="haxe.ds.StringMap"><d/></c>
	<d/>
</f></stringMapToObject>
		<valueToObject set="method" line="504" static="1"><f a="value">
	<d/>
	<d/>
</f></valueToObject>
		<arrayToObject set="method" line="515" static="1"><f a="arr">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
</f></arrayToObject>
		<sortStringArray set="method" line="519" static="1"><f a="arr">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><c path="String"/></c>
</f></sortStringArray>
		<in__><c path="haxe.ds.StringMap"><c path="Array"><c path="String"/></c></c></in__>
		<out_><c path="haxe.ds.StringMap"><c path="Array"><c path="String"/></c></c></out_>
		<limit_><x path="Null"><x path="Int"/></x></limit_>
		<orderBy_><c path="String"/></orderBy_>
		<offset_><x path="Null"><x path="Int"/></x></offset_>
		<ordering_><c path="Array"><c path="String"/></c></ordering_>
		<like_><c path="haxe.ds.StringMap"><c path="String"/></c></like_>
		<ilike_><c path="haxe.ds.StringMap"><c path="String"/></c></ilike_>
		<select_><c path="Array"><c path="String"/></c></select_>
		<relOps><c path="haxe.ds.StringMap"><c path="Array"><c path="connect.api._Query.KeyValue"/></c></c></relOps>
		<forceRql_><x path="Bool"/></forceRql_>
		<copy public="1" set="method" line="34"><f a=""><c path="connect.api.Query"/></f></copy>
		<default_ public="1" set="method" line="56">
			<f a=""><c path="connect.api.Query"/></f>
			<haxe_doc>* Embeds the filters in the query defined by `Env.initDefaultQuery` in this one.
     * If the query already has an specific filter set, it is not overriden by the default
     * value.
     * @return Query</haxe_doc>
		</default_>
		<in_ public="1" set="method" line="101">
			<f a="property:array">
				<c path="String"/>
				<c path="connect.util.Collection"><c path="String"/></c>
				<c path="connect.api.Query"/>
			</f>
			<haxe_doc>* Select objects where the specified property value is in the provided array.
     * @param property
     * @param array
     * @return Query</haxe_doc>
		</in_>
		<out public="1" set="method" line="112">
			<f a="property:array">
				<c path="String"/>
				<c path="connect.util.Collection"><c path="String"/></c>
				<c path="connect.api.Query"/>
			</f>
			<haxe_doc>* Select objects where the specified property value is not in the provided array.
     * @param property 
     * @param array 
     * @return Query</haxe_doc>
		</out>
		<limit public="1" set="method" line="122">
			<f a="amount">
				<x path="Int"/>
				<c path="connect.api.Query"/>
			</f>
			<haxe_doc>* Indicates the given number of objects from the start position.
     * @param amount 
     * @return Query</haxe_doc>
		</limit>
		<orderBy public="1" set="method" line="132">
			<f a="property">
				<c path="String"/>
				<c path="connect.api.Query"/>
			</f>
			<haxe_doc>* Order list by given property
     * @param property 
     * @return Query</haxe_doc>
		</orderBy>
		<offset public="1" set="method" line="142">
			<f a="page">
				<x path="Int"/>
				<c path="connect.api.Query"/>
			</f>
			<haxe_doc>* Offset (page) to return on paged queries.
     * @param page 
     * @return Query</haxe_doc>
		</offset>
		<ordering public="1" set="method" line="154">
			<f a="propertyList">
				<c path="connect.util.Collection"><c path="String"/></c>
				<c path="connect.api.Query"/>
			</f>
			<haxe_doc>* Order list of objects by the given properties (unlimited number of properties).
     * The list is ordered first by the first specified property, then by the second, and
     * so on. The order is specified by the prefix: + ascending order, - descending.
     * @param propertyList 
     * @return Query</haxe_doc>
		</ordering>
		<like public="1" set="method" line="169">
			<f a="property:pattern">
				<c path="String"/>
				<c path="String"/>
				<c path="connect.api.Query"/>
			</f>
			<haxe_doc>* Search for the specified pattern in the specified property. The function is similar
     * to the SQL LIKE operator, though it uses the * wildcard instead of %. To specify in
     * a pattern the * symbol itself, it must be percent-encoded, that is, you need to specify
     * %2A instead of *, see the usage examples below. In addition, it is possible to use the
     * ? wildcard in the pattern to specify that any symbol will be valid in this position.
     * @param property 
     * @param pattern 
     * @return Query</haxe_doc>
		</like>
		<ilike public="1" set="method" line="180">
			<f a="property:pattern">
				<c path="String"/>
				<c path="String"/>
				<c path="connect.api.Query"/>
			</f>
			<haxe_doc>* Same as like but case unsensitive.
     * @param property 
     * @param pattern 
     * @return Query</haxe_doc>
		</ilike>
		<select public="1" set="method" line="195">
			<f a="attributes">
				<c path="connect.util.Collection"><c path="String"/></c>
				<c path="connect.api.Query"/>
			</f>
			<haxe_doc>* The function is applicable to a list of resources (hereafter base resources). It receives
     * the list of attributes (up to 100 attributes) that can be primitive properties of the base
     * resources, relation names, and relation names combined with properties of related resources.
     * The output is the list of objects presenting the selected properties and related (linked)
     * resources. Normally, when relations are selected, the base resource properties are also presented
     * in the output.
     * @param attributes 
     * @return Query</haxe_doc>
		</select>
		<equal public="1" set="method" line="206">
			<f a="property:value">
				<c path="String"/>
				<c path="String"/>
				<c path="connect.api.Query"/>
			</f>
			<haxe_doc>* Select objects with a property value equal to value.
     * @param property 
     * @param value 
     * @return Query</haxe_doc>
		</equal>
		<notEqual public="1" set="method" line="216">
			<f a="property:value">
				<c path="String"/>
				<c path="String"/>
				<c path="connect.api.Query"/>
			</f>
			<haxe_doc>* Select objects with a property value not equal to value.
     * @param property 
     * @param value 
     * @return Query</haxe_doc>
		</notEqual>
		<greater public="1" set="method" line="226">
			<f a="property:value">
				<c path="String"/>
				<c path="String"/>
				<c path="connect.api.Query"/>
			</f>
			<haxe_doc>* Select objects with a property value greater than the value.
     * @param property 
     * @param value 
     * @return Query</haxe_doc>
		</greater>
		<greaterOrEqual public="1" set="method" line="236">
			<f a="property:value">
				<c path="String"/>
				<c path="String"/>
				<c path="connect.api.Query"/>
			</f>
			<haxe_doc>* Select objects with a property value equal or greater than the value.
     * @param property 
     * @param value 
     * @return Query</haxe_doc>
		</greaterOrEqual>
		<lesser public="1" set="method" line="246">
			<f a="property:value">
				<c path="String"/>
				<c path="String"/>
				<c path="connect.api.Query"/>
			</f>
			<haxe_doc>* Select objects with a property value less than the value.
     * @param property 
     * @param value 
     * @return Query</haxe_doc>
		</lesser>
		<lesserOrEqual public="1" set="method" line="256">
			<f a="property:value">
				<c path="String"/>
				<c path="String"/>
				<c path="connect.api.Query"/>
			</f>
			<haxe_doc>* Select objects with a property value equal or less than the value.
     * @param property 
     * @param value 
     * @return Query</haxe_doc>
		</lesserOrEqual>
		<toString public="1" set="method" line="265">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns a string representation of `this` query in RQL syntax that can be appended
     * to a URL.
     * @return String</haxe_doc>
		</toString>
		<toPlain public="1" set="method" line="327">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns a string representation of `this` Query with the parameters
     * compatible with query params syntax. It can be appended to a URL.
     * If `forceRql(true)` was called on `this` Query, then it returns the
     * string in RQL syntax, making this method equivalent to `toString`
     * in that case.
     * @return String</haxe_doc>
		</toPlain>
		<toObject public="1" set="method" line="368">
			<f a=""><d/></f>
			<haxe_doc>* Returns a dynamic object with the fields of the Query.
     * @return Dynamic</haxe_doc>
		</toObject>
		<toJson public="1" set="method" line="404">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns a Json representation of the Query.
     * @return String</haxe_doc>
		</toJson>
		<forceRql public="1" set="method" line="484">
			<f a="force">
				<x path="Bool"/>
				<c path="connect.api.Query"/>
			</f>
			<haxe_doc>* Calling this method with a `true` argument makes the
     * `toPlain` method return an RQL string representation
     * instead of a plain list of query params.
     * @param force 
     * @return Query</haxe_doc>
		</forceRql>
		<addRelOp set="method" line="489"><f a="op:property:value">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="connect.api.Query"/>
</f></addRelOp>
		<new public="1" set="method" line="25"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.api._Query.KeyValue" params="" file="connect/api/Query.hx" private="1" module="connect.api.Query">
		<key final="1" public="1"><c path="String"/></key>
		<value final="1" public="1"><c path="String"/></value>
		<equals public="1" set="method" line="534"><f a="other">
	<c path="connect.api._Query.KeyValue"/>
	<x path="Bool"/>
</f></equals>
		<toObject public="1" set="method" line="538"><f a=""><d/></f></toObject>
		<new public="1" set="method" line="529"><f a="key:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.api.Response" params="" file="connect/api/Response.hx">
		<extends path="connect.Base"/>
		<status final="1" public="1"><x path="Int"/></status>
		<text final="1" public="1"><c path="String"/></text>
		<data final="1" public="1"><c path="connect.util.Blob"/></data>
		<new public="1" set="method" line="15"><f a="status:text:data">
	<x path="Int"/>
	<c path="String"/>
	<c path="connect.util.Blob"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.api.SubscriptionsApi" params="" file="connect/api/SubscriptionsApi.hx">
		<extends path="connect.Base"/>
		<ASSETS_PATH final="1" set="null" expr="&quot;subscriptions/assets&quot;" line="12" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"subscriptions/assets"</e></m></meta>
		</ASSETS_PATH>
		<REQUESTS_PATH final="1" set="null" expr="&quot;subscriptions/requests&quot;" line="13" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"subscriptions/requests"</e></m></meta>
		</REQUESTS_PATH>
		<listRecurringAssets public="1" set="method" line="18"><f a="filters">
	<c path="connect.api.Query"/>
	<c path="String"/>
</f></listRecurringAssets>
		<getRecurringAsset public="1" set="method" line="22"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getRecurringAsset>
		<listBillingRequests public="1" set="method" line="26"><f a="filters">
	<c path="connect.api.Query"/>
	<c path="String"/>
</f></listBillingRequests>
		<getBillingRequest public="1" set="method" line="30"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getBillingRequest>
		<createBillingRequest public="1" set="method" line="34"><f a="data:currentRequest">
	<c path="String"/>
	<x path="Null"><c path="connect.models.IdModel"/></x>
	<c path="String"/>
</f></createBillingRequest>
		<updateBillingRequestAttributes public="1" set="method" line="38"><f a="id:data">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></updateBillingRequestAttributes>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="connect.api.TierApi" params="" file="connect/api/TierApi.hx">
		<extends path="connect.Base"/>
		<TCR_PATH final="1" set="null" expr="&quot;tier/config-requests&quot;" line="11" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"tier/config-requests"</e></m></meta>
		</TCR_PATH>
		<TA_PATH final="1" set="null" expr="&quot;tier/accounts&quot;" line="12" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"tier/accounts"</e></m></meta>
		</TA_PATH>
		<TC_PATH final="1" set="null" expr="&quot;tier/configs&quot;" line="13" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"tier/configs"</e></m></meta>
		</TC_PATH>
		<listTierConfigRequests public="1" set="method" line="18"><f a="filters">
	<c path="connect.api.Query"/>
	<c path="String"/>
</f></listTierConfigRequests>
		<createTierConfigRequest public="1" set="method" line="22"><f a="body">
	<c path="String"/>
	<c path="String"/>
</f></createTierConfigRequest>
		<getTierConfigRequest public="1" set="method" line="26"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getTierConfigRequest>
		<updateTierConfigRequest public="1" set="method" line="30"><f a="id:tcr">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></updateTierConfigRequest>
		<pendTierConfigRequest public="1" set="method" line="34"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></pendTierConfigRequest>
		<inquireTierConfigRequest public="1" set="method" line="38"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></inquireTierConfigRequest>
		<approveTierConfigRequest public="1" set="method" line="42"><f a="id:data">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></approveTierConfigRequest>
		<failTierConfigRequest public="1" set="method" line="46"><f a="id:data">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></failTierConfigRequest>
		<assignTierConfigRequest public="1" set="method" line="50"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></assignTierConfigRequest>
		<unassignTierConfigRequest public="1" set="method" line="54"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></unassignTierConfigRequest>
		<listTierAccounts public="1" set="method" line="58"><f a="filters">
	<c path="connect.api.Query"/>
	<c path="String"/>
</f></listTierAccounts>
		<getTierAccount public="1" set="method" line="62"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getTierAccount>
		<listTierConfigs public="1" set="method" line="66"><f a="filters">
	<c path="connect.api.Query"/>
	<c path="String"/>
</f></listTierConfigs>
		<getTierConfig public="1" set="method" line="70"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getTierConfig>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.api.UsageApi" params="" file="connect/api/UsageApi.hx">
		<extends path="connect.Base"/>
		<USAGE_FILES_PATH final="1" set="null" expr="&quot;usage/files&quot;" line="12" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"usage/files"</e></m></meta>
		</USAGE_FILES_PATH>
		<USAGE_PRODUCTS_PATH final="1" set="null" expr="&quot;usage/products&quot;" line="13" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"usage/products"</e></m></meta>
		</USAGE_PRODUCTS_PATH>
		<USAGE_RECORDS_PATH final="1" set="null" expr="&quot;usage/records&quot;" line="14" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"usage/records"</e></m></meta>
		</USAGE_RECORDS_PATH>
		<listUsageFiles public="1" set="method" line="19"><f a="filters">
	<c path="connect.api.Query"/>
	<c path="String"/>
</f></listUsageFiles>
		<createUsageFile public="1" set="method" line="23"><f a="body">
	<c path="String"/>
	<c path="String"/>
</f></createUsageFile>
		<getUsageFile public="1" set="method" line="27"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getUsageFile>
		<updateUsageFile public="1" set="method" line="31"><f a="id:body">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></updateUsageFile>
		<deleteUsageFile public="1" set="method" line="35"><f a="id">
	<c path="String"/>
	<x path="Void"/>
</f></deleteUsageFile>
		<uploadUsageFile public="1" set="method" line="39"><f a="id:file">
	<c path="String"/>
	<c path="connect.util.Blob"/>
	<c path="String"/>
</f></uploadUsageFile>
		<submitUsageFileAction public="1" set="method" line="50"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></submitUsageFileAction>
		<acceptUsageFileAction public="1" set="method" line="54"><f a="id:note">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></acceptUsageFileAction>
		<rejectUsageFileAction public="1" set="method" line="59"><f a="id:note">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></rejectUsageFileAction>
		<closeUsageFileAction public="1" set="method" line="64"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></closeUsageFileAction>
		<getProductSpecificUsageFileTemplate public="1" set="method" line="68"><f a="productId">
	<c path="String"/>
	<c path="String"/>
</f></getProductSpecificUsageFileTemplate>
		<uploadReconciliationFileFromProvider public="1" set="method" line="72"><f a="id:file">
	<c path="String"/>
	<c path="connect.util.Blob"/>
	<c path="String"/>
</f></uploadReconciliationFileFromProvider>
		<reprocessProcessedFile public="1" set="method" line="83"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></reprocessProcessedFile>
		<listUsageRecords public="1" set="method" line="87"><f a="filters">
	<c path="connect.api.Query"/>
	<c path="String"/>
</f></listUsageRecords>
		<getUsageRecord public="1" set="method" line="91"><f a="id">
	<c path="String"/>
	<c path="String"/>
</f></getUsageRecord>
		<updateUsageRecord public="1" set="method" line="95"><f a="id:record">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></updateUsageRecord>
		<closeUsageRecord public="1" set="method" line="99"><f a="id:record">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></closeUsageRecord>
		<new public="1" set="method" line="16"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.api.impl.ApiClientImpl" params="" file="connect/api/impl/ApiClientImpl.hx">
		<extends path="connect.Base"/>
		<implements path="connect.api.IApiClient"/>
		<logRequest set="method" line="261" static="1">
			<f a="level:method:url:headers:body:response:?logger" v="::::::null">
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
				<c path="connect.util.Dictionary"/>
				<c path="String"/>
				<c path="connect.api.Response"/>
				<c path="connect.logger.Logger"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ logger : null }</e></m></meta>
		</logRequest>
		<getHeadersTable set="method" line="286" static="1"><f a="headers:fmt">
	<c path="connect.util.Dictionary"/>
	<c path="connect.logger.ILoggerFormatter"/>
	<c path="String"/>
</f></getHeadersTable>
		<maskHeaders set="method" line="303" static="1"><f a="headers">
	<c path="connect.util.Dictionary"/>
	<c path="connect.util.Dictionary"/>
</f></maskHeaders>
		<getFormattedData set="method" line="308" static="1"><f a="data:title:fmt">
	<c path="String"/>
	<c path="String"/>
	<c path="connect.logger.ILoggerFormatter"/>
	<c path="String"/>
</f></getFormattedData>
		<syncRequest public="1" set="method" line="20"><f a="method:url:headers:body:fileArg:fileName:fileContent:certificate">
	<c path="String"/>
	<c path="String"/>
	<c path="connect.util.Dictionary"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="connect.util.Blob"/>
	<c path="String"/>
	<c path="connect.api.Response"/>
</f></syncRequest>
		<syncRequestWithLogger public="1" set="method" line="26"><f a="method:url:headers:body:fileArg:fileName:fileContent:certificate:logger:logLevel">
	<c path="String"/>
	<c path="String"/>
	<c path="connect.util.Dictionary"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="connect.util.Blob"/>
	<c path="String"/>
	<x path="Null"><c path="connect.logger.Logger"/></x>
	<x path="Null"><x path="Int"/></x>
	<c path="connect.api.Response"/>
</f></syncRequestWithLogger>
		<syncRequestStd public="1" set="method" line="220"><f a="method:url:headers:body:fileArg:fileName:fileContent:certificate">
	<c path="String"/>
	<c path="String"/>
	<c path="connect.util.Dictionary"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="connect.util.Blob"/>
	<c path="String"/>
	<c path="connect.api.Response"/>
</f></syncRequestStd>
		<new public="1" set="method" line="57"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.flow.FlowExecutor" params="" file="connect/flow/FlowExecutor.hx">
		<getExceptionMessage public="1" set="method" line="73" static="1"><f a="ex">
	<d/>
	<c path="String"/>
</f></getExceptionMessage>
		<flow final="1"><c path="connect.Flow"/></flow>
		<delegate final="1"><x path="Null"><c path="connect.flow.FlowExecutorDelegate"/></x></delegate>
		<steps final="1"><c path="Array"><c path="connect.flow.Step"/></c></steps>
		<abortRequested><x path="Bool"/></abortRequested>
		<abortMessage><x path="Null"><c path="String"/></x></abortMessage>
		<addStep public="1" set="method" line="24"><f a="description:func">
	<c path="String"/>
	<t path="connect.flow.StepFunc"/>
	<x path="Void"/>
</f></addStep>
		<reset public="1" set="method" line="28"><f a=""><x path="Void"/></f></reset>
		<executeRequest public="1" set="method" line="33"><f a="request:firstIndex">
	<c path="connect.models.IdModel"/>
	<x path="Int"/>
	<x path="Void"/>
</f></executeRequest>
		<processSteps set="method" line="38"><f a="request:steps:firstIndex">
	<c path="connect.models.IdModel"/>
	<c path="Array"><c path="connect.flow.Step"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></processSteps>
		<processStep set="method" line="48"><f a="request:step:index">
	<c path="connect.models.IdModel"/>
	<c path="connect.flow.Step"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></processStep>
		<callStepFunc set="method" line="56"><f a="request:step:index">
	<c path="connect.models.IdModel"/>
	<c path="connect.flow.Step"/>
	<x path="Int"/>
	<x path="Void"/>
</f></callStepFunc>
		<processAbortOrEnd set="method" line="88"><f a="request:step:index">
	<c path="connect.models.IdModel"/>
	<c path="connect.flow.Step"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></processAbortOrEnd>
		<abort public="1" set="method" line="112">
			<f a="?message">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Without a message, a skip is performed with the standard skip message, which
        will try to store step data. If a message is provided, no data is stored, and that message
        is printed instead as long as it is not an empty string.</haxe_doc>
		</abort>
		<new public="1" set="method" line="16"><f a="flow:delegate">
	<c path="connect.Flow"/>
	<x path="Null"><c path="connect.flow.FlowExecutorDelegate"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="connect.flow.FlowLogger" params="" file="connect/flow/FlowLogger.hx">
		<flowName final="1"><c path="String"/></flowName>
		<logger><c path="connect.logger.Logger"/></logger>
		<openFlowSection public="1" set="method" line="26"><f a=""><x path="Void"/></f></openFlowSection>
		<closeFlowSection public="1" set="method" line="30"><f a=""><x path="Void"/></f></closeFlowSection>
		<openRequestSection public="1" set="method" line="35"><f a="request">
	<c path="connect.models.IdModel"/>
	<x path="Void"/>
</f></openRequestSection>
		<closeRequestSection public="1" set="method" line="40"><f a=""><x path="Void"/></f></closeRequestSection>
		<openSetupSection public="1" set="method" line="45"><f a=""><x path="Void"/></f></openSetupSection>
		<closeSetupSection public="1" set="method" line="49"><f a=""><x path="Void"/></f></closeSetupSection>
		<openStepSection public="1" set="method" line="53"><f a="index:description">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></openStepSection>
		<closeStepSection public="1" set="method" line="57"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></closeStepSection>
		<writeStepInfo public="1" set="method" line="61"><f a="requestInfo:prevRequestInfo">
	<c path="connect.flow.ProcessedRequestInfo"/>
	<c path="connect.flow.ProcessedRequestInfo"/>
	<x path="Void"/>
</f></writeStepInfo>
		<writeStepError public="1" set="method" line="65"><f a="requestInfo:prevRequestInfo">
	<c path="connect.flow.ProcessedRequestInfo"/>
	<c path="connect.flow.ProcessedRequestInfo"/>
	<x path="Void"/>
</f></writeStepError>
		<writeStep set="method" line="71"><f a="level:requestInfo:prevRequestInfo">
	<x path="Int"/>
	<c path="connect.flow.ProcessedRequestInfo"/>
	<c path="connect.flow.ProcessedRequestInfo"/>
	<x path="Void"/>
</f></writeStep>
		<getFormattedRequest set="method" line="80"><f a="request:lastRequest:fmt">
	<c path="String"/>
	<c path="String"/>
	<c path="connect.logger.ILoggerFormatter"/>
	<c path="String"/>
</f></getFormattedRequest>
		<getFormattedData set="method" line="103"><f a="data:lastData:dataDict:fmt">
	<c path="String"/>
	<c path="String"/>
	<x path="Null"><c path="connect.util.Dictionary"/></x>
	<c path="connect.logger.ILoggerFormatter"/>
	<c path="String"/>
</f></getFormattedData>
		<getDataTable set="method" line="120"><f a="data:fmt">
	<c path="connect.util.Dictionary"/>
	<c path="connect.logger.ILoggerFormatter"/>
	<c path="String"/>
</f></getDataTable>
		<writeStepSkip public="1" set="method" line="129"><f a="willSave">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeStepSkip>
		<writeStepSavedInConnect public="1" set="method" line="137"><f a=""><x path="Void"/></f></writeStepSavedInConnect>
		<writeStepSavedLocally public="1" set="method" line="141"><f a=""><x path="Void"/></f></writeStepSavedLocally>
		<writeStepSaveFailed public="1" set="method" line="145"><f a=""><x path="Void"/></f></writeStepSaveFailed>
		<writeMigrationMessage public="1" set="method" line="149"><f a="request">
	<c path="connect.models.IdModel"/>
	<x path="Void"/>
</f></writeMigrationMessage>
		<writeException public="1" set="method" line="153"><f a="message">
	<c path="String"/>
	<x path="Void"/>
</f></writeException>
		<writeLoadedStepData public="1" set="method" line="157"><f a="index:storageType">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeLoadedStepData>
		<new public="1" set="method" line="21"><f a="flowName">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="connect.flow.FlowStore" params="" file="connect/flow/FlowStore.hx">
		<STEP_PARAM_ID final="1" set="null" expr="&quot;__sdk_processor_step&quot;" line="11" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__sdk_processor_step"</e></m></meta>
		</STEP_PARAM_ID>
		<STEP_PARAM_ID_TIER final="1" set="null" expr="&quot;__sdk_processor_step_tier&quot;" line="12" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__sdk_processor_step_tier"</e></m></meta>
		</STEP_PARAM_ID_TIER>
		<STEP_PARAM_ID_TIER2 final="1" set="null" expr="&quot;__sdk_processor_step_tier2&quot;" line="13" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"__sdk_processor_step_tier2"</e></m></meta>
		</STEP_PARAM_ID_TIER2>
		<delegate final="1"><c path="connect.flow.FlowStoreDelegate"/></delegate>
		<storeRequestOnFailure><x path="Bool"/></storeRequestOnFailure>
		<storeNumAttempts><x path="Bool"/></storeNumAttempts>
		<setStoreRequestOnFailure public="1" set="method" line="25"><f a="enable">
	<x path="Bool"/>
	<x path="Void"/>
</f></setStoreRequestOnFailure>
		<storesRequestOnFailure public="1" set="method" line="29"><f a=""><x path="Bool"/></f></storesRequestOnFailure>
		<setStoreNumAttempts public="1" set="method" line="33"><f a="enable">
	<x path="Bool"/>
	<x path="Void"/>
</f></setStoreNumAttempts>
		<storesNumAttempts public="1" set="method" line="37"><f a=""><x path="Bool"/></f></storesNumAttempts>
		<requestDidBegin public="1" set="method" line="41"><f a="request">
	<c path="connect.models.IdModel"/>
	<x path="Void"/>
</f></requestDidBegin>
		<requestDidSkip public="1" set="method" line="55"><f a="request:data:index:attempt">
	<c path="connect.models.IdModel"/>
	<c path="connect.util.Dictionary"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></requestDidSkip>
		<removeStepData public="1" set="method" line="73"><f a="request">
	<c path="connect.models.IdModel"/>
	<x path="Void"/>
</f></removeStepData>
		<getStepParam set="method" line="77"><f a="request">
	<c path="connect.models.IdModel"/>
	<c path="connect.models.Param"/>
</f></getStepParam>
		<new public="1" set="method" line="19"><f a="delegate">
	<x path="Null"><c path="connect.flow.FlowStoreDelegate"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="connect.flow.ProcessedRequestInfo" params="" file="connect/flow/ProcessedRequestInfo.hx">
		<requestToString set="method" line="38" static="1"><f a="request">
	<x path="Null"><c path="connect.models.IdModel"/></x>
	<c path="String"/>
</f></requestToString>
		<dataToString set="method" line="48" static="1"><f a="data">
	<x path="Null"><c path="connect.util.Dictionary"/></x>
	<c path="String"/>
</f></dataToString>
		<request final="1"><x path="Null"><c path="connect.models.IdModel"/></x></request>
		<data final="1"><x path="Null"><c path="connect.util.Dictionary"/></x></data>
		<requestStr final="1"><c path="String"/></requestStr>
		<dataStr final="1"><c path="String"/></dataStr>
		<getRequest public="1" set="method" line="22"><f a=""><x path="Null"><c path="connect.models.IdModel"/></x></f></getRequest>
		<getData public="1" set="method" line="26"><f a=""><x path="Null"><c path="connect.util.Dictionary"/></x></f></getData>
		<getRequestString public="1" set="method" line="30"><f a=""><c path="String"/></f></getRequestString>
		<getDataString public="1" set="method" line="34"><f a=""><c path="String"/></f></getDataString>
		<new public="1" set="method" line="15"><f a="request:data">
	<x path="Null"><c path="connect.models.IdModel"/></x>
	<x path="Null"><c path="connect.util.Dictionary"/></x>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="connect.flow.RequestCaster" params="" file="connect/flow/RequestCaster.hx">
		<castAssetRequest public="1" set="method" line="11" static="1"><f a="request">
	<c path="connect.models.IdModel"/>
	<c path="connect.models.AssetRequest"/>
</f></castAssetRequest>
		<castListing public="1" set="method" line="19" static="1"><f a="request">
	<c path="connect.models.IdModel"/>
	<c path="connect.models.Listing"/>
</f></castListing>
		<castTierConfigRequest public="1" set="method" line="27" static="1"><f a="request">
	<c path="connect.models.IdModel"/>
	<c path="connect.models.TierConfigRequest"/>
</f></castTierConfigRequest>
		<castUsageFile public="1" set="method" line="35" static="1"><f a="request">
	<c path="connect.models.IdModel"/>
	<c path="connect.models.UsageFile"/>
</f></castUsageFile>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="connect.flow.Step" params="" file="connect/flow/Step.hx">
		<description final="1"><c path="String"/></description>
		<func final="1"><t path="connect.flow.StepFunc"/></func>
		<getDescription public="1" set="method" line="13"><f a=""><c path="String"/></f></getDescription>
		<getFunc public="1" set="method" line="17"><f a=""><t path="connect.flow.StepFunc"/></f></getFunc>
		<new public="1" set="method" line="8"><f a="description:func">
	<c path="String"/>
	<t path="connect.flow.StepFunc"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<typedef path="connect.flow.StepFunc" params="" file="connect/flow/StepFunc.hx">
		<f a="">
			<c path="connect.Flow"/>
			<x path="Void"/>
		</f>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</typedef>
	<class path="connect.logger.ILoggerWriter" params="" file="connect/logger/ILoggerWriter.hx" interface="1">
		<setFilename public="1" set="method">
			<f a="filename">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Sets the filename of the log.
     * @param filename The current filename of the log.
     * @return `true` if file has been reset, `false` otherwise.</haxe_doc>
		</setFilename>
		<getFilename public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>@returns The last filename that was set.</haxe_doc>
		</getFilename>
		<writeLine public="1" set="method">
			<f a="level:line">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes a line to the log output. The new line character is added by the method.</haxe_doc>
		</writeLine>
		<copy public="1" set="method">
			<f a="request">
				<x path="Null"><c path="connect.models.IdModel"/></x>
				<c path="connect.logger.ILoggerWriter"/>
			</f>
			<haxe_doc>Returns full copy of writter</haxe_doc>
		</copy>
		<haxe_doc>Represents the functionality of writing logs to some output. The `Logger` uses an
    instance of a class that implements this interface (`FileLoggerWriter` by default)
    to write log messages.</haxe_doc>
	</class>
	<class path="connect.logger.FileLoggerWriter" params="" file="connect/logger/FileLoggerWriter.hx">
		<extends path="connect.Base"/>
		<implements path="connect.logger.ILoggerWriter"/>
		<filename><c path="String"/></filename>
		<file><c path="sys.io.FileOutput"/></file>
		<setFilename public="1" set="method" line="23"><f a="filename">
	<c path="String"/>
	<x path="Bool"/>
</f></setFilename>
		<getFilename public="1" set="method" line="35"><f a=""><c path="String"/></f></getFilename>
		<writeLine public="1" set="method" line="39"><f a="level:line">
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeLine>
		<getFile set="method" line="51"><f a=""><c path="sys.io.FileOutput"/></f></getFile>
		<copy public="1" set="method" line="73"><f a="request">
	<x path="Null"><c path="connect.models.IdModel"/></x>
	<c path="connect.logger.FileLoggerWriter"/>
</f></copy>
		<new public="1" set="method" line="18"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="connect.logger.ILoggerFormatter" params="" file="connect/logger/ILoggerFormatter.hx" interface="1">
		<formatSection public="1" set="method"><f a="level:sectionLevel:text">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></formatSection>
		<formatBlock public="1" set="method"><f a="level:text">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></formatBlock>
		<formatCodeBlock public="1" set="method"><f a="level:text:language">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></formatCodeBlock>
		<formatList public="1" set="method"><f a="level:list">
	<x path="Int"/>
	<c path="connect.util.Collection"><c path="String"/></c>
	<c path="String"/>
</f></formatList>
		<formatTable public="1" set="method"><f a="level:table">
	<x path="Int"/>
	<c path="connect.util.Collection"><c path="connect.util.Collection"><c path="String"/></c></c>
	<c path="String"/>
</f></formatTable>
		<formatLine public="1" set="method"><f a="level:text">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></formatLine>
		<getFileExtension public="1" set="method"><f a=""><c path="String"/></f></getFileExtension>
		<copy public="1" set="method"><f a="request">
	<x path="Null"><c path="connect.models.IdModel"/></x>
	<c path="connect.logger.ILoggerFormatter"/>
</f></copy>
		<haxe_doc>* Represents a log formatter.The `Logger` uses an instance of a class that implements
 * this interface (`PlainLoggerFormatter` or `MarkdownLoggerFormatter` by default,
 * depending on the value of `LoggerConfig.markdown()`) to write log messages.</haxe_doc>
	</class>
	<class path="connect.logger.Logger" params="" file="connect/logger/Logger.hx">
		<extends path="connect.Base"/>
		<LEVEL_ERROR final="1" public="1" set="null" expr="0" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>Only writes compact error level messages.</haxe_doc>
		</LEVEL_ERROR>
		<LEVEL_WARNING final="1" public="1" set="null" expr="1" line="24" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
			<haxe_doc><![CDATA[Only writes compact error & warning level messages.]]></haxe_doc>
		</LEVEL_WARNING>
		<LEVEL_INFO final="1" public="1" set="null" expr="2" line="27" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
			<haxe_doc><![CDATA[Only writes compact error & info level messages.]]></haxe_doc>
		</LEVEL_INFO>
		<LEVEL_DEBUG final="1" public="1" set="null" expr="3" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
			<haxe_doc>Writes detailed messages of all levels.</haxe_doc>
		</LEVEL_DEBUG>
		<path final="1"><c path="String"/></path>
		<level final="1"><x path="Int"/></level>
		<handlers final="1"><c path="connect.util.Collection"><c path="connect.logger.LoggerHandler"/></c></handlers>
		<sections final="1"><c path="Array"><c path="connect.logger._Logger.LoggerSection"/></c></sections>
		<maskedFields final="1"><c path="connect.util.Collection"><c path="String"/></c></maskedFields>
		<maskedParams final="1"><c path="connect.util.Collection"><c path="String"/></c></maskedParams>
		<regexMaskingList final="1"><c path="connect.util.Collection"><c path="EReg"/></c></regexMaskingList>
		<compact final="1"><x path="Bool"/></compact>
		<beautify final="1"><x path="Bool"/></beautify>
		<defaultFilename><c path="String"/></defaultFilename>
		<initialConfig final="1"><c path="connect.logger.LoggerConfig"/></initialConfig>
		<getInitialConfig public="1" set="method" line="65">
			<f a=""><c path="connect.logger.LoggerConfig"/></f>
			<haxe_doc>@returns initial logger configuration</haxe_doc>
		</getInitialConfig>
		<getPath public="1" set="method" line="70">
			<f a=""><c path="String"/></f>
			<haxe_doc>@returns The path where logs are stored.</haxe_doc>
		</getPath>
		<getLevel public="1" set="method" line="78">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* @return Int The level of the log. One of: `LEVEL_ERROR`, `LEVEL_WARNING`,
     * `LEVEL_INFO`, `LEVEL_DEBUG`.</haxe_doc>
		</getLevel>
		<isBeautified public="1" set="method" line="86">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* @return Bool Whether the logs are written in beautified format (this is,
     * for JSON objects use new lines and two space indentation).</haxe_doc>
		</isBeautified>
		<isCompact public="1" set="method" line="95">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* @return Bool Whether the logs are written in compact format (this is,
     * for JSON objects only print key names or, if it has an 'id' field,
     * only the id)..</haxe_doc>
		</isCompact>
		<setFilename public="1" set="method" line="109">
			<f a="filename">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the filename of the log. All future log messages will get printed to this file.
        Initially, the logger only writes to the standard output. The first time you call
        this method with an argument other than `null`, the provided name will be considered
        the default filename. Whenever this method is called afterwards with a `null` argument,
        output will be sent to the default file.

        Filename extension must be omitted, since it is provided by the formatters
        used in each handler.</haxe_doc>
		</setFilename>
		<setFilenameForRequest public="1" set="method" line="131"><f a="request">
	<c path="connect.models.IdModel"/>
	<x path="Void"/>
</f></setFilenameForRequest>
		<getFilename public="1" set="method" line="186">
			<f a=""><c path="String"/></f>
			<haxe_doc>@returns The last filename that was set.</haxe_doc>
		</getFilename>
		<getHandlers public="1" set="method" line="204">
			<f a=""><c path="connect.util.Collection"><c path="connect.logger.LoggerHandler"/></c></f>
			<haxe_doc>@returns The defined handlers for this logger. Do not modify this collection.</haxe_doc>
		</getHandlers>
		<openSection public="1" set="method" line="213">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Opens a new section in the log. This will be output as a Markdown header when using
        this formatting, depending on the number of opened sections. For example, at the beginning
        of a function, a section can be opened, and closed when the function finishes.</haxe_doc>
		</openSection>
		<closeSection public="1" set="method" line="220">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Closes the last opened section.</haxe_doc>
		</closeSection>
		<writeBlock public="1" set="method" line="230">
			<f a="level:block">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Writes a block to the log in the specified level.
     * It adds a new line to the log after writing the block.
     * @param level Message level. One of: `LEVEL_ERROR`, `LEVEL_WARNING`, `LEVEL_INFO`, `LEVEL_DEBUG`.
     * @param block Block of text to log. Lines in the text are formatted to appear as a block.</haxe_doc>
		</writeBlock>
		<writeCodeBlock public="1" set="method" line="243">
			<f a="level:code:language">
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Writes a code block to the log in the specified level.
     * It adds a new line to the log after writing the block.
     * @param level Message level. One of: `LEVEL_ERROR`, `LEVEL_WARNING`, `LEVEL_INFO`, `LEVEL_DEBUG`.
     * @param code Code to log. Text is formatted to appear as a code block.
     * @param language Language used in the block. For example, "json". Can be an empty string.</haxe_doc>
		</writeCodeBlock>
		<writeList public="1" set="method" line="255">
			<f a="level:list">
				<x path="Int"/>
				<c path="connect.util.Collection"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Writes a list to the log in the specified level.
     * It adds a new line to the log after writing the list.
     * @param level Message level. One of: `LEVEL_ERROR`, `LEVEL_WARNING`, `LEVEL_INFO`, `LEVEL_DEBUG`.
     * @param list List to log. Lines are formatted to appear as a list.</haxe_doc>
		</writeList>
		<writeTable public="1" set="method" line="268">
			<f a="level:table">
				<x path="Int"/>
				<c path="connect.util.Collection"><c path="connect.util.Collection"><c path="String"/></c></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Writes a table to the log in the specified level. The first row should contain the
     * table header.
     * It adds a new line to the log after writing the list.
     * @param level Message level. One of: `LEVEL_ERROR`, `LEVEL_WARNING`, `LEVEL_INFO`, `LEVEL_DEBUG`.
     * @param table Table to log. Rows are formatted to appear as a table.</haxe_doc>
		</writeTable>
		<write public="1" set="method" line="280">
			<f a="level:message">
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Writes a message to the log in the specified level.
     * It adds a new line to the log after writing the message.
     * @param level Message level. One of: `LEVEL_ERROR`, `LEVEL_WARNING`, `LEVEL_INFO`, `LEVEL_DEBUG`.
     * @param message Message to log. The message is not formatted.</haxe_doc>
		</write>
		<getMaskedFields public="1" set="method" line="287">
			<f a=""><c path="connect.util.Collection"><c path="String"/></c></f>
			<haxe_doc>Returns a list of fields which should be masked in http requests or responses.</haxe_doc>
		</getMaskedFields>
		<getMaskedParams public="1" set="method" line="292">
			<f a=""><c path="connect.util.Collection"><c path="String"/></c></f>
			<haxe_doc>Returns a list of param ids whose value should be masked in logged requests.</haxe_doc>
		</getMaskedParams>
		<getRegExMaskingList public="1" set="method" line="299">
			<f a=""><c path="connect.util.Collection"><c path="EReg"/></c></f>
			<haxe_doc>*  Returns a list of regular expression for string data masking purposes</haxe_doc>
		</getRegExMaskingList>
		<log public="1" set="method" line="304">
			<f a="message">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</log>
		<debug public="1" set="method" line="309">
			<f a="message">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</debug>
		<info public="1" set="method" line="314">
			<f a="message">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</info>
		<notice public="1" set="method" line="319">
			<f a="message">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</notice>
		<warning public="1" set="method" line="324">
			<f a="message">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</warning>
		<error public="1" set="method" line="329">
			<f a="message">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</error>
		<critical public="1" set="method" line="334">
			<f a="message">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</critical>
		<alert public="1" set="method" line="339">
			<f a="message">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</alert>
		<emergency public="1" set="method" line="344">
			<f a="message">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</emergency>
		<_writeToHandler public="1" set="method" line="349">
			<f a="level:message:handler">
				<x path="Int"/>
				<c path="String"/>
				<c path="connect.logger.LoggerHandler"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_writeToHandler>
		<writeSections set="method" line="356"><f a="level">
	<x path="Int"/>
	<x path="Void"/>
</f></writeSections>
		<copy public="1" set="method" line="368"><f a="request">
	<x path="Null"><c path="connect.models.IdModel"/></x>
	<c path="connect.logger.Logger"/>
</f></copy>
		<new public="1" set="method" line="48">
			<f a="config">
				<c path="connect.logger.LoggerConfig"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Logger object. You don't normally create objects of this class,
        since the SDK uses the default instance provided by `Env.getLogger()` or `Env.getLoggerForRequest()`.</haxe_doc>
		</new>
		<haxe_doc>This class is used to log events to a file and the output console.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.logger._Logger.LoggerSection" params="" file="connect/logger/Logger.hx" private="1" module="connect.logger.Logger">
		<name final="1" public="1"><c path="String"/></name>
		<written public="1"><x path="Bool"/></written>
		<new public="1" set="method" line="395"><f a="name">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.ds._Map.Map_Impl_" params="" file="/home/travis/haxe/std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map" final="1">
		<_new public="1" set="method" static="1">
			<f a=""><x path="haxe.ds.Map">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</x></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>Creates a new Map.

		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:

		1. if `K` is a `String`, `haxe.ds.StringMap` is used
		2. if `K` is an `Int`, `haxe.ds.IntMap` is used
		3. if `K` is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if `K` is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if `K` is any other type, it causes a compile-time error

		(Cpp) Map does not use weak keys on `ObjectMap` by default.</haxe_doc>
		</_new>
		<set public="1" get="inline" set="null" line="76" static="1">
			<f a="this:key:value">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Maps `key` to `value`.

		If `key` already has a mapping, the previous value disappears.

		If `key` is `null`, the result is unspecified.</haxe_doc>
		</set>
		<get public="1" get="inline" set="null" line="94" static="1">
			<f a="this:key">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<c path="haxe.ds.Map.K"/>
				<x path="Null"><c path="haxe.ds.Map.V"/></x>
			</f>
			<meta><m n=":arrayAccess"/></meta>
			<haxe_doc>Returns the current mapping of `key`.

		If no such mapping exists, `null` is returned.

		Note that a check like `map.get(key) == null` can hold for two reasons:

		1. the map has no mapping for `key`
		2. the map has a mapping with a value of `null`

		If it is important to distinguish these cases, `exists()` should be
		used.

		If `key` is `null`, the result is unspecified.</haxe_doc>
		</get>
		<exists public="1" get="inline" set="null" line="102" static="1">
			<f a="this:key">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<c path="haxe.ds.Map.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `key` has a mapping, false otherwise.

		If `key` is `null`, the result is unspecified.</haxe_doc>
		</exists>
		<remove public="1" get="inline" set="null" line="111" static="1">
			<f a="this:key">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<c path="haxe.ds.Map.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the mapping of `key` and returns true if such a mapping existed,
		false otherwise.

		If `key` is `null`, the result is unspecified.</haxe_doc>
		</remove>
		<keys public="1" get="inline" set="null" line="118" static="1">
			<f a="this">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<t path="Iterator"><c path="haxe.ds.Map.K"/></t>
			</f>
			<haxe_doc>Returns an Iterator over the keys of `this` Map.

		The order of keys is undefined.</haxe_doc>
		</keys>
		<iterator public="1" get="inline" set="null" line="127" static="1">
			<f a="this">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<t path="Iterator"><c path="haxe.ds.Map.V"/></t>
			</f>
			<haxe_doc>Returns an Iterator over the values of `this` Map.

		The order of values is undefined.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="136" static="1">
			<f a="this">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<t path="KeyValueIterator">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</t>
			</f>
			<haxe_doc>Returns an Iterator over the keys and values of `this` Map.

		The order of values is undefined.</haxe_doc>
		</keyValueIterator>
		<copy public="1" get="inline" set="null" line="145" static="1">
			<f a="this">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<x path="haxe.ds.Map">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</x>
			</f>
			<haxe_doc>Returns a shallow copy of `this` map.

		The order of values is undefined.</haxe_doc>
		</copy>
		<toString public="1" get="inline" set="null" line="154" static="1">
			<f a="this">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a String representation of `this` Map.

		The exact representation depends on the platform and key-type.</haxe_doc>
		</toString>
		<clear public="1" get="inline" set="null" line="161" static="1">
			<f a="this">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes all keys from `this` Map.</haxe_doc>
		</clear>
		<arrayWrite public="1" get="inline" set="null" line="165" static="1">
			<f a="this:k:v">
				<c path="haxe.IMap">
					<c path="haxe.ds.Map.K"/>
					<c path="haxe.ds.Map.V"/>
				</c>
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
				<c path="haxe.ds.Map.V"/>
			</f>
			<meta>
				<m n=":arrayAccess"/>
				<m n=":noCompletion"/>
			</meta>
		</arrayWrite>
		<toStringMap params="K:V" get="inline" set="null" line="170" static="1">
			<f a="t">
				<c path="haxe.IMap">
					<c path="toStringMap.K"/>
					<c path="toStringMap.V"/>
				</c>
				<c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c>
			</f>
			<meta><m n=":to"/></meta>
		</toStringMap>
		<toIntMap params="K:V" get="inline" set="null" line="174" static="1">
			<f a="t">
				<c path="haxe.IMap">
					<c path="toIntMap.K"/>
					<c path="toIntMap.V"/>
				</c>
				<c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c>
			</f>
			<meta><m n=":to"/></meta>
		</toIntMap>
		<toEnumValueMapMap params="K:V" get="inline" set="null" line="178" static="1">
			<f a="t">
				<c path="haxe.IMap">
					<c path="toEnumValueMapMap.K"/>
					<c path="toEnumValueMapMap.V"/>
				</c>
				<c path="haxe.ds.EnumValueMap">
					<c path="toEnumValueMapMap.K"/>
					<c path="toEnumValueMapMap.V"/>
				</c>
			</f>
			<meta><m n=":to"/></meta>
		</toEnumValueMapMap>
		<toObjectMap params="K:V" get="inline" set="null" line="182" static="1">
			<f a="t">
				<c path="haxe.IMap">
					<c path="toObjectMap.K"/>
					<c path="toObjectMap.V"/>
				</c>
				<c path="haxe.ds.ObjectMap">
					<c path="toObjectMap.K"/>
					<c path="toObjectMap.V"/>
				</c>
			</f>
			<meta><m n=":to"/></meta>
		</toObjectMap>
		<fromStringMap params="V" get="inline" set="null" line="186" static="1">
			<f a="map">
				<c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c>
				<x path="haxe.ds.Map">
					<c path="String"/>
					<c path="fromStringMap.V"/>
				</x>
			</f>
			<meta><m n=":from"/></meta>
		</fromStringMap>
		<fromIntMap params="V" get="inline" set="null" line="190" static="1">
			<f a="map">
				<c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c>
				<x path="haxe.ds.Map">
					<x path="Int"/>
					<c path="fromIntMap.V"/>
				</x>
			</f>
			<meta><m n=":from"/></meta>
		</fromIntMap>
		<fromObjectMap params="K:V" get="inline" set="null" line="194" static="1">
			<f a="map">
				<c path="haxe.ds.ObjectMap">
					<c path="fromObjectMap.K"/>
					<c path="fromObjectMap.V"/>
				</c>
				<x path="haxe.ds.Map">
					<c path="fromObjectMap.K"/>
					<c path="fromObjectMap.V"/>
				</x>
			</f>
			<meta><m n=":from"/></meta>
		</fromObjectMap>
	</class>
	<class path="connect.logger.LoggerConfig" params="" file="connect/logger/LoggerConfig.hx">
		<extends path="connect.Base"/>
		<levelTranslation final="1" set="null" expr="[&quot;ERROR&quot; =&gt; Logger.LEVEL_ERROR, &quot;WARNING&quot; =&gt; Logger.LEVEL_WARNING, &quot;INFO&quot; =&gt; Logger.LEVEL_INFO, &quot;DEBUG&quot; =&gt; Logger.LEVEL_DEBUG]" line="32" static="1">
			<t path="Map">
				<c path="String"/>
				<x path="Int"/>
			</t>
			<meta><m n=":value"><e><![CDATA[["ERROR" => Logger.LEVEL_ERROR, "WARNING" => Logger.LEVEL_WARNING, "INFO" => Logger.LEVEL_INFO, "DEBUG" => Logger.LEVEL_DEBUG]]]></e></m></meta>
		</levelTranslation>
		<path_ public="1" set="null">
			<c path="String"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</path_>
		<level_ public="1" set="null">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</level_>
		<handlers_ public="1" set="null">
			<c path="connect.util.Collection"><c path="connect.logger.LoggerHandler"/></c>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</handlers_>
		<maskedFields_ public="1" set="null">
			<c path="connect.util.Collection"><c path="String"/></c>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</maskedFields_>
		<maskedParams_ public="1" set="null">
			<c path="connect.util.Collection"><c path="String"/></c>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</maskedParams_>
		<regexMaskingList_ public="1">
			<c path="connect.util.Collection"><c path="EReg"/></c>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</regexMaskingList_>
		<compact_ public="1" set="null">
			<x path="Bool"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</compact_>
		<beautify_ public="1" set="null">
			<x path="Bool"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</beautify_>
		<customHandlers><x path="Bool"/></customHandlers>
		<path public="1" set="method" line="61">
			<f a="path">
				<c path="String"/>
				<c path="connect.logger.LoggerConfig"/>
			</f>
			<haxe_doc>* Sets the path where logs will be stored. Default is "logs". When using a `Processor`
     * to process requests, the `Flow`s in the processor will use `Logger.setFilename` to switch
     * to the correct filename based on the id of the element being processed. When not using
     * the `Processor` at all, remember to call `Logger.setFilename` after initializing the Log
     * or log messages will only be printed to the standard output (usually, the terminal).
     *
     * @param path Path for logs.
     * @return `this` instance to support a fluent interface.</haxe_doc>
		</path>
		<level public="1" set="method" line="72">
			<f a="level">
				<x path="Int"/>
				<c path="connect.logger.LoggerConfig"/>
			</f>
			<haxe_doc>* Sets the logging level. Default is `Logger.LEVEL_INFO`.
     * @param level Level of log. One of: `Logger.LEVEL_ERROR`,
     * `Logger.LEVEL_WARNING`, `Logger.LEVEL_INFO`, `Logger.LEVEL_DEBUG`.
     * @return `this` instance to support a fluent interface.</haxe_doc>
		</level>
		<levelName public="1" set="method" line="83">
			<f a="level">
				<c path="String"/>
				<c path="connect.logger.LoggerConfig"/>
			</f>
			<haxe_doc>* Sets the logging level. Default is `Logger.LEVEL_INFO`.
     * @param level Level of log.
     *  One of: `"ERROR"`, `"WARNING"`, `"INFO"`, `"DEBUG"`.
     * @return `this` instance to support a fluent interface.</haxe_doc>
		</levelName>
		<handlers public="1" set="method" line="97">
			<f a="handlers">
				<c path="connect.util.Collection"><c path="connect.logger.LoggerHandler"/></c>
				<c path="connect.logger.LoggerConfig"/>
			</f>
			<haxe_doc>* Sets the handlers for the logger. Default is a handler with a plain of Markdown formatter
     * (depending on whether `markdown` method was called with a `true` argument) and a file
     * writer.
     * @param handlers Collection of handlers.
     * @return LoggerConfig `this` instance to support a fluent interface.</haxe_doc>
		</handlers>
		<maskedFields public="1" set="method" line="109">
			<f a="maskedFields">
				<c path="connect.util.Collection"><c path="String"/></c>
				<c path="connect.logger.LoggerConfig"/>
			</f>
			<haxe_doc>* Sets the fields which should be masked in the logs,
     * by default only Authorization field in header is masked.
     * @param maskedFields Collection of field names (string).
     * @return LoggerConfig `this` instance to support a fluent interface.</haxe_doc>
		</maskedFields>
		<maskedParams public="1" set="method" line="119">
			<f a="maskedParams">
				<c path="connect.util.Collection"><c path="String"/></c>
				<c path="connect.logger.LoggerConfig"/>
			</f>
			<haxe_doc>* Sets the id of the params whose value should be masked in the logs.
     * @param maskedParams Collection of param ids (string).
     * @return LoggerConfig `this` instance to support a fluent interface.</haxe_doc>
		</maskedParams>
		<beautify public="1" set="method" line="130">
			<f a="enable">
				<x path="Bool"/>
				<c path="connect.logger.LoggerConfig"/>
			</f>
			<haxe_doc>* Set whether the logs must be written in beautified format (this is,
     * for JSON objects use new lines and two space indentation).
     * @param enable Whether beautified logging should be enabled (defaults to `false`).
     * @return LoggerConfig `this` instance to support a fluent interface.</haxe_doc>
		</beautify>
		<compact public="1" set="method" line="142">
			<f a="enable">
				<x path="Bool"/>
				<c path="connect.logger.LoggerConfig"/>
			</f>
			<haxe_doc>* Sets whether the logs must be written in compact format (this is,
     * for JSON objects only prints key names or, if it has an 'id' field,
     * only the id). This is ignored if the logger is created in LEVEL_DEBUG.
     * @param enable Whether compact logging should be enabled.
     * @return LoggerConfig `this` instance to support a fluent interface.</haxe_doc>
		</compact>
		<regexMasks public="1" set="method" line="152">
			<f a="expressions">
				<c path="connect.util.Collection"><c path="String"/></c>
				<c path="connect.logger.LoggerConfig"/>
			</f>
			<haxe_doc>* Set list of regexs to replace in logs strings
     * @param expressions
     * @return LoggerConfig `this` instance to support a fluent interface.</haxe_doc>
		</regexMasks>
		<markdown public="1" set="method" line="169">
			<f a="enable">
				<x path="Bool"/>
				<c path="connect.logger.LoggerConfig"/>
			</f>
			<haxe_doc>* Sets whether the logger should use the Markdown formatter. By default,
     * the plain text formatter is used. This property only has effect if no default
     * set of logger handlers has been set.
     * @param enable Whether to use the Markdown formatter.
     * @return LoggerConfig `this` instance to support a fluent interface.</haxe_doc>
		</markdown>
		<new public="1" set="method" line="39"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Represents the configuration of the logger. An instance can be passed to `Env.initLogger`
 * to setup the logger behaviour.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.logger.LoggerHandler" params="" file="connect/logger/LoggerHandler.hx">
		<formatter final="1" public="1"><c path="connect.logger.ILoggerFormatter"/></formatter>
		<writer final="1" public="1"><c path="connect.logger.ILoggerWriter"/></writer>
		<new public="1" set="method" line="18"><f a="formatter:writer">
	<c path="connect.logger.ILoggerFormatter"/>
	<c path="connect.logger.ILoggerWriter"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* This class representes a handler for the Logger. An handler is composed of a formatter
 * (capable of formatting blocks, tables and lists to a specific syntax, like Markdown)
 * and a writer (capable of writing the formatted message to an output, like a file).</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.logger.MarkdownLoggerFormatter" params="" file="connect/logger/MarkdownLoggerFormatter.hx">
		<extends path="connect.Base"/>
		<implements path="connect.logger.ILoggerFormatter"/>
		<formatSection public="1" set="method" line="14"><f a="level:sectionLevel:text">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></formatSection>
		<formatBlock public="1" set="method" line="22"><f a="level:text">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></formatBlock>
		<formatCodeBlock public="1" set="method" line="28"><f a="level:text:language">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></formatCodeBlock>
		<formatList public="1" set="method" line="34"><f a="level:list">
	<x path="Int"/>
	<c path="connect.util.Collection"><c path="String"/></c>
	<c path="String"/>
</f></formatList>
		<formatTable public="1" set="method" line="43"><f a="level:table">
	<x path="Int"/>
	<c path="connect.util.Collection"><c path="connect.util.Collection"><c path="String"/></c></c>
	<c path="String"/>
</f></formatTable>
		<formatLine public="1" set="method" line="54"><f a="level:text">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></formatLine>
		<getFileExtension public="1" set="method" line="58"><f a=""><c path="String"/></f></getFileExtension>
		<copy public="1" set="method" line="62"><f a="request">
	<x path="Null"><c path="connect.models.IdModel"/></x>
	<c path="connect.logger.MarkdownLoggerFormatter"/>
</f></copy>
		<new public="1" set="method" line="66"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="connect.logger.PlainLoggerFormatter" params="" file="connect/logger/PlainLoggerFormatter.hx">
		<extends path="connect.Base"/>
		<implements path="connect.logger.ILoggerFormatter"/>
		<NO_REQUEST final="1" set="null" expr="&quot;NO_REQUEST&quot;" line="15" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"NO_REQUEST"</e></m></meta>
		</NO_REQUEST>
		<formatDate set="method" line="31" static="1"><f a=""><c path="String"/></f></formatDate>
		<formatLevel set="method" line="36" static="1"><f a="level">
	<x path="Int"/>
	<c path="String"/>
</f></formatLevel>
		<removePrefix set="method" line="61" static="1"><f a="text">
	<c path="String"/>
	<c path="String"/>
</f></removePrefix>
		<isPrefixed set="method" line="67" static="1"><f a="text">
	<c path="String"/>
	<x path="Bool"/>
</f></isPrefixed>
		<currentRequest expr="NO_REQUEST">
			<c path="String"/>
			<meta><m n=":value"><e>NO_REQUEST</e></m></meta>
		</currentRequest>
		<formatSection public="1" set="method" line="18"><f a="level:sectionLevel:text">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></formatSection>
		<formatPrefix set="method" line="27"><f a="level">
	<x path="Int"/>
	<c path="String"/>
</f></formatPrefix>
		<formatBlock public="1" set="method" line="48"><f a="level:text">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></formatBlock>
		<getPrefixedLines set="method" line="52"><f a="level:text">
	<x path="Int"/>
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></getPrefixedLines>
		<getUnprefixedLines set="method" line="57"><f a="level:text">
	<x path="Int"/>
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></getUnprefixedLines>
		<formatCodeBlock public="1" set="method" line="72"><f a="level:text:language">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></formatCodeBlock>
		<formatList public="1" set="method" line="76"><f a="level:list">
	<x path="Int"/>
	<c path="connect.util.Collection"><c path="String"/></c>
	<c path="String"/>
</f></formatList>
		<formatTable public="1" set="method" line="90"><f a="level:table">
	<x path="Int"/>
	<c path="connect.util.Collection"><c path="connect.util.Collection"><c path="String"/></c></c>
	<c path="String"/>
</f></formatTable>
		<formatLine public="1" set="method" line="102"><f a="level:text">
	<x path="Int"/>
	<c path="String"/>
	<c path="String"/>
</f></formatLine>
		<getFileExtension public="1" set="method" line="106"><f a=""><c path="String"/></f></getFileExtension>
		<copy public="1" set="method" line="110"><f a="request">
	<x path="Null"><c path="connect.models.IdModel"/></x>
	<c path="connect.logger.PlainLoggerFormatter"/>
</f></copy>
		<new public="1" set="method" line="116"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="connect.models.Model" params="" file="connect/models/Model.hx">
		<extends path="connect.Base"/>
		<parse public="1" params="T" set="method" line="82" static="1">
			<f a="modelClass:body">
				<x path="Class"><c path="parse.T"/></x>
				<c path="String"/>
				<c path="parse.T"/>
			</f>
			<haxe_doc>Parses the given string-encoded Json as a Model of the specified class.

        @returns The parsel model.
        @throws String If `obj` is not a dynamic object or if the class for a field was not
            found.</haxe_doc>
		</parse>
		<parseArray public="1" params="T" set="method" line="92" static="1">
			<f a="modelClass:body">
				<x path="Class"><c path="parseArray.T"/></x>
				<c path="String"/>
				<c path="connect.util.Collection"><c path="parseArray.T"/></c>
			</f>
			<haxe_doc>Parses the given Haxe dynamic object as a Collection of Models of the specified class.</haxe_doc>
		</parseArray>
		<_parse params="T" set="method" line="129" static="1"><f a="modelClass:obj">
	<x path="Class"><c path="_parse.T"/></x>
	<d/>
	<c path="_parse.T"/>
</f></_parse>
		<_parseArray params="T" set="method" line="185" static="1"><f a="modelClass:array">
	<x path="Class"><c path="_parseArray.T"/></x>
	<c path="Array"><d/></c>
	<c path="connect.util.Collection"><c path="_parseArray.T"/></c>
</f></_parseArray>
		<toObject public="1" set="method" line="19">
			<f a=""><d/></f>
			<haxe_doc>@returns A Haxe dynamic object with a shallow copy of `this` model's properties.</haxe_doc>
		</toObject>
		<toString public="1" set="method" line="70">
			<f a=""><c path="String"/></f>
			<haxe_doc>@returns A String with the JSON representation of `this` Model.</haxe_doc>
		</toString>
		<_setFieldClassNames public="1" set="method" line="102">
			<f a="map">
				<c path="haxe.ds.StringMap"><c path="String"/></c>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_setFieldClassNames>
		<_toDiff public="1" set="method" line="110">
			<f a=""><d/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_toDiff>
		<_toDiffString public="1" set="method" line="117">
			<f a=""><c path="String"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_toDiffString>
		<_footprint><c path="String"/></_footprint>
		<fieldClassNames><c path="haxe.ds.StringMap"><c path="String"/></c></fieldClassNames>
		<getFieldClassName set="method" line="198"><f a="field">
	<c path="String"/>
	<c path="String"/>
</f></getFieldClassName>
		<new public="1" set="method" line="122"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Base model class.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.models.IdModel" params="" file="connect/models/IdModel.hx">
		<extends path="connect.models.Model"/>
		<id public="1">
			<c path="String"/>
			<haxe_doc>Id of the model.</haxe_doc>
		</id>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>The base class of all models that have an id.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.models.Account" params="" file="connect/models/Account.hx">
		<extends path="connect.models.IdModel"/>
		<list public="1" set="method" line="47" static="1">
			<f a="filters">
				<c path="connect.api.Query"/>
				<c path="connect.util.Collection"><c path="connect.models.Account"/></c>
			</f>
			<haxe_doc>Lists all Accounts that match the given filters.

        @returns A Collection of Accounts.</haxe_doc>
		</list>
		<create public="1" set="method" line="58" static="1">
			<f a=""><c path="connect.models.Account"/></f>
			<haxe_doc>Creates a new Account.

        @returns The created Account.</haxe_doc>
		</create>
		<get public="1" set="method" line="65" static="1">
			<f a="id">
				<c path="String"/>
				<c path="connect.models.Account"/>
			</f>
			<haxe_doc>@returns The Account with the given id, or `null` if it was not found.</haxe_doc>
		</get>
		<name public="1">
			<c path="String"/>
			<haxe_doc>Name of account object.</haxe_doc>
		</name>
		<type public="1">
			<c path="String"/>
			<haxe_doc>Type of the account object ("vendor" or "provider").</haxe_doc>
		</type>
		<events public="1">
			<c path="connect.models.Events"/>
			<haxe_doc>Contains the `created` event, with the date when the account object was created.</haxe_doc>
		</events>
		<brand public="1">
			<c path="String"/>
			<haxe_doc>Brand id of the account object.</haxe_doc>
		</brand>
		<externalId public="1">
			<c path="String"/>
			<haxe_doc>External id of the account object.</haxe_doc>
		</externalId>
		<sourcing public="1">
			<x path="Bool"/>
			<haxe_doc>Whether the account has the ability to create Sourcing Agreements (is HyperProvider),
        defaults to false.</haxe_doc>
		</sourcing>
		<listUsers public="1" set="method" line="76">
			<f a=""><c path="connect.util.Collection"><c path="connect.models.User"/></c></f>
			<haxe_doc>@returns A Collection of Users of `this` Account.</haxe_doc>
		</listUsers>
		<getUser public="1" set="method" line="86">
			<f a="userId">
				<c path="String"/>
				<c path="connect.models.User"/>
			</f>
			<haxe_doc>@returns The User belonging to `this` Account with the given `userId`,
        or `null` if it was not found.</haxe_doc>
		</getUser>
		<new public="1" set="method" line="14"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Represents an account in the Connect platform, of either a Vendor or a Provider.</haxe_doc>
	</class>
	<class path="connect.models.Action" params="" file="connect/models/Action.hx">
		<extends path="connect.models.IdModel"/>
		<name public="1">
			<c path="String"/>
			<haxe_doc>Name field of Action.</haxe_doc>
		</name>
		<action public="1">
			<c path="String"/>
			<haxe_doc>The action field of the Action table</haxe_doc>
		</action>
		<type public="1">
			<c path="String"/>
			<haxe_doc>Only supported type is button for now.</haxe_doc>
		</type>
		<description public="1">
			<c path="String"/>
			<haxe_doc>A description of the action, describing the operation that will be performed.</haxe_doc>
		</description>
		<scope public="1">
			<c path="String"/>
			<haxe_doc>Specifies all constrains applied on the action. One of: asset, tier-1, tier-2.</haxe_doc>
		</scope>
		<events public="1">
			<c path="connect.models.Events"/>
			<haxe_doc>Events occured on the action.</haxe_doc>
		</events>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.models.Activation" params="" file="connect/models/Activation.hx">
		<extends path="connect.models.Model"/>
		<link public="1">
			<c path="String"/>
			<haxe_doc>Activation link.</haxe_doc>
		</link>
		<message public="1">
			<c path="String"/>
			<haxe_doc>Activation message.</haxe_doc>
		</message>
		<date public="1">
			<c path="connect.util.DateTime"/>
			<haxe_doc>Activation date.</haxe_doc>
		</date>
		<new public="1" set="method" line="25"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Contract activation information.</haxe_doc>
	</class>
	<class path="connect.models.Agreement" params="" file="connect/models/Agreement.hx">
		<extends path="connect.models.IdModel"/>
		<list public="1" set="method" line="90" static="1">
			<f a="filters">
				<c path="connect.api.Query"/>
				<c path="connect.util.Collection"><c path="connect.models.Agreement"/></c>
			</f>
			<haxe_doc>Lists all agreements that match the given filters. Supported filters are:

        - `type`
        - `owner__id`

        @returns A Collection of Agreements.</haxe_doc>
		</list>
		<get public="1" set="method" line="96" static="1">
			<f a="id">
				<c path="String"/>
				<c path="connect.models.Agreement"/>
			</f>
			<haxe_doc>@returns The Agreement with the given id, or `null` if it was not found.</haxe_doc>
		</get>
		<type public="1">
			<c path="String"/>
			<haxe_doc>Type of the agreement. One of: distribution, program, service.</haxe_doc>
		</type>
		<title public="1">
			<c path="String"/>
			<haxe_doc>Title of the agreement.</haxe_doc>
		</title>
		<description public="1">
			<c path="String"/>
			<haxe_doc>Agreement details (Markdown).</haxe_doc>
		</description>
		<created public="1">
			<c path="connect.util.DateTime"/>
			<haxe_doc>Date of creation of the agreement.</haxe_doc>
		</created>
		<updated public="1">
			<c path="connect.util.DateTime"/>
			<haxe_doc>Date of the update of the agreement. It can be creation
        of the new version, change of the field, etc. (any change).</haxe_doc>
		</updated>
		<owner public="1">
			<c path="connect.models.Account"/>
			<haxe_doc>Reference to the owner account object.</haxe_doc>
		</owner>
		<stats public="1">
			<c path="connect.models.AgreementStats"/>
			<haxe_doc>Agreement stats.</haxe_doc>
		</stats>
		<author public="1">
			<c path="connect.models.User"/>
			<haxe_doc>Reference to the user who created the version.</haxe_doc>
		</author>
		<version public="1">
			<x path="Int"/>
			<haxe_doc>Chronological number of the version.</haxe_doc>
		</version>
		<active public="1">
			<x path="Bool"/>
			<haxe_doc>State of the version.</haxe_doc>
		</active>
		<link public="1">
			<c path="String"/>
			<haxe_doc>Url to the document.</haxe_doc>
		</link>
		<versionCreated public="1">
			<c path="connect.util.DateTime"/>
			<haxe_doc>Date of the creation of the version.</haxe_doc>
		</versionCreated>
		<versionContracts public="1">
			<x path="Int"/>
			<haxe_doc>Number of contracts this version has.</haxe_doc>
		</versionContracts>
		<agreements public="1">
			<c path="connect.util.Collection"><c path="connect.models.Agreement"/></c>
			<haxe_doc>Program agreements can have distribution agreements associated with them.</haxe_doc>
		</agreements>
		<parent public="1">
			<c path="connect.models.Agreement"/>
			<haxe_doc>Reference to the parent program agreement (for distribution agreement).</haxe_doc>
		</parent>
		<marketplace public="1">
			<c path="connect.models.Marketplace"/>
			<haxe_doc>Reference to marketplace object (for distribution agreement).</haxe_doc>
		</marketplace>
		<name public="1">
			<c path="String"/>
			<haxe_doc>Name of Agreement.</haxe_doc>
		</name>
		<register public="1" set="method" line="109">
			<f a=""><c path="connect.models.Agreement"/></f>
			<haxe_doc>* Registers a new Agreement on Connect, based on the data of `this` Agreement.
     * @return The new Agreement, or `null` if it couldn't be created</haxe_doc>
		</register>
		<update public="1" set="method" line="132">
			<f a=""><c path="connect.models.Agreement"/></f>
			<haxe_doc>Updates the agreement in Connect platform with the data changed in `this` model.

        You should reassign your agreement with the object returned by this method, so the next time
        you call `update` on the object, the SDK knows the fields that already got updated in a
        previous call, like this:

        ```
        agreement = agreement.update();
        ```

        @returns The Agreement returned from the server, which should contain
        the same data as `this` Agreement, or `null` if the updating fails.</haxe_doc>
		</update>
		<remove public="1" set="method" line="153">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Removes `this` Agreement from Connect.
     * @return Bool If agreement could be removed, returns `true`. Otherwise, returns `false`.</haxe_doc>
		</remove>
		<listVersions public="1" set="method" line="168"><f a=""><c path="connect.util.Collection"><c path="connect.models.Agreement"/></c></f></listVersions>
		<registerVersion public="1" set="method" line="177">
			<f a=""><c path="connect.models.Agreement"/></f>
			<haxe_doc>* Registers a new version on Connect, based on the data of `this` Agreement.
     * @return The new version, or `null` if it couldn't be registered</haxe_doc>
		</registerVersion>
		<getVersion public="1" set="method" line="189">
			<f a="version">
				<x path="Int"/>
				<c path="connect.models.Agreement"/>
			</f>
			<haxe_doc>* @return Agreement Returns the specified version for `this` Agreement, or `null` if it was not found.</haxe_doc>
		</getVersion>
		<removeVersion public="1" set="method" line="202">
			<f a="version">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Removes the specified version from `this` agreement on Connect.
     * @param version The version to remove.</haxe_doc>
		</removeVersion>
		<listSubAgreements public="1" set="method" line="215">
			<f a=""><c path="connect.util.Collection"><c path="connect.models.Agreement"/></c></f>
			<haxe_doc><![CDATA[* Lists all sub agreements linked to `this` Agreement.
     * @return Collection<Agreement>]]></haxe_doc>
		</listSubAgreements>
		<registerSubAgreement public="1" set="method" line="224">
			<f a="agreement">
				<c path="connect.models.Agreement"/>
				<c path="connect.models.Agreement"/>
			</f>
			<haxe_doc>* Registers a new Agreement on Connect and links it to `this` Agreement.
     * @return The new Agreement, or `null` if it couldn't be created</haxe_doc>
		</registerSubAgreement>
		<new public="1" set="method" line="69"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.models.AgreementStats" params="" file="connect/models/AgreementStats.hx">
		<extends path="connect.models.Model"/>
		<contracts public="1">
			<x path="Int"/>
			<haxe_doc>Number of contracts this agreement has.</haxe_doc>
		</contracts>
		<versions public="1">
			<x path="Int"/>
			<haxe_doc>Number of versions in the agreement.</haxe_doc>
		</versions>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Agreement Stats.</haxe_doc>
	</class>
	<class path="connect.models.Asset" params="" file="connect/models/Asset.hx">
		<extends path="connect.models.IdModel"/>
		<list public="1" set="method" line="115" static="1">
			<f a="filters">
				<c path="connect.api.Query"/>
				<c path="connect.util.Collection"><c path="connect.models.Asset"/></c>
			</f>
			<haxe_doc>Lists all Assets that match the given filters. Supported filters are:

        - `id`
        - `conection.hub.id`
        - `connection.provider.id`
        - `tiers.customer.id`
        - `tiers.tier1.id`
        - `tiers.tier2.id`
        - `connection.id`
        - `status`
        - `created`
        - `updated`
        - `marketplace.id`
        - `contract.id`
        - `product.id`
        - `connection.type`

        @returns A Collection of Assets.</haxe_doc>
		</list>
		<get public="1" set="method" line="123" static="1">
			<f a="id">
				<c path="String"/>
				<c path="connect.models.Asset"/>
			</f>
			<haxe_doc>@returns The Asset with the given id, or `null` if it was not found.</haxe_doc>
		</get>
		<status public="1">
			<c path="String"/>
			<haxe_doc>Assets may have one of the following statuses:

        - new: First purchase requested.
        - processing: Until first purchase request is either completed or rejected.
        - active: After the first purchase request is completed.
          NOTE: Asset stays active regardless of any other requests except cancel.
        - rejected: Asset becomes rejected once the first purchase request is rejected.
        - terminated: Asset becomes terminated once the 'cancel' request type is fulfilled.
        - suspended: Asset becomes suspended once 'suspend' request type is fulfilled.</haxe_doc>
		</status>
		<externalId public="1">
			<c path="String"/>
			<haxe_doc>Identification for asset object on eCommerce.</haxe_doc>
		</externalId>
		<externalUid public="1">
			<c path="String"/>
			<haxe_doc>Id of asset in eCommerce system.</haxe_doc>
		</externalUid>
		<externalName public="1">
			<c path="String"/>
			<haxe_doc>Name of asset.</haxe_doc>
		</externalName>
		<product public="1">
			<c path="connect.models.Product"/>
			<haxe_doc>Product object reference.</haxe_doc>
		</product>
		<connection public="1">
			<c path="connect.models.Connection"/>
			<haxe_doc>Connection object reference.</haxe_doc>
		</connection>
		<contract public="1">
			<c path="connect.models.Contract"/>
			<haxe_doc>Contract object reference.</haxe_doc>
		</contract>
		<marketplace public="1">
			<c path="connect.models.Marketplace"/>
			<haxe_doc>Marketplace object reference.</haxe_doc>
		</marketplace>
		<params public="1">
			<c path="connect.util.Collection"><c path="connect.models.Param"/></c>
			<haxe_doc>Collection of product parameters.</haxe_doc>
		</params>
		<tiers public="1">
			<c path="connect.models.Tiers"/>
			<haxe_doc>Supply chain accounts.</haxe_doc>
		</tiers>
		<items public="1">
			<c path="connect.util.Collection"><c path="connect.models.Item"/></c>
			<haxe_doc>Collection of asset product items.</haxe_doc>
		</items>
		<configuration public="1">
			<c path="connect.models.Configuration"/>
			<haxe_doc>Product and Marketplace Configuration Phase Parameter.</haxe_doc>
		</configuration>
		<events public="1">
			<c path="connect.models.Events"/>
			<haxe_doc>Events that have taken place on this asset (i.e: created, updated).</haxe_doc>
		</events>
		<getRequests public="1" set="method" line="134">
			<f a=""><c path="connect.util.Collection"><c path="connect.models.AssetRequest"/></c></f>
			<haxe_doc>@returns A collection with all the requests for the `this` Asset.</haxe_doc>
		</getRequests>
		<getNewItems public="1" set="method" line="141">
			<f a=""><c path="connect.util.Collection"><c path="connect.models.Item"/></c></f>
			<haxe_doc>@returns A collection with `this` Asset's new items.</haxe_doc>
		</getNewItems>
		<getChangedItems public="1" set="method" line="149">
			<f a=""><c path="connect.util.Collection"><c path="connect.models.Item"/></c></f>
			<haxe_doc>@returns A collection with `this` Asset's changed items.</haxe_doc>
		</getChangedItems>
		<getRemovedItems public="1" set="method" line="157">
			<f a=""><c path="connect.util.Collection"><c path="connect.models.Item"/></c></f>
			<haxe_doc>@returns A collection with `this` Asset's removed items.</haxe_doc>
		</getRemovedItems>
		<getParamById public="1" set="method" line="165">
			<f a="paramId">
				<c path="String"/>
				<c path="connect.models.Param"/>
			</f>
			<haxe_doc>@returns The param with the given id, or `null` if it was not found.</haxe_doc>
		</getParamById>
		<getItemById public="1" set="method" line="174">
			<f a="itemId">
				<c path="String"/>
				<c path="connect.models.Item"/>
			</f>
			<haxe_doc>@returns The item with the given id, or `null` if it was not found.</haxe_doc>
		</getItemById>
		<getItemByMpn public="1" set="method" line="183">
			<f a="mpn">
				<c path="String"/>
				<c path="connect.models.Item"/>
			</f>
			<haxe_doc>@returns The item with the given Manufacture Part Number, or `null` if it was not found.</haxe_doc>
		</getItemByMpn>
		<getItemByGlobalId public="1" set="method" line="192">
			<f a="globalId">
				<c path="String"/>
				<c path="connect.models.Item"/>
			</f>
			<haxe_doc>@returns The item with the given global id, or `null` if it was not found.</haxe_doc>
		</getItemByGlobalId>
		<getCustomerConfig public="1" set="method" line="203">
			<f a=""><c path="connect.models.TierConfig"/></f>
			<haxe_doc>* @return The `TierConfig` object for the customer tier of this asset, or `null`.</haxe_doc>
		</getCustomerConfig>
		<getTier1Config public="1" set="method" line="213">
			<f a=""><c path="connect.models.TierConfig"/></f>
			<haxe_doc>* @return The `TierConfig` object for the tier1 of this asset, or `null`.</haxe_doc>
		</getTier1Config>
		<getTier2Config public="1" set="method" line="223">
			<f a=""><c path="connect.models.TierConfig"/></f>
			<haxe_doc>* @return The `TierConfig` object for the tier2 of this asset, or `null`.</haxe_doc>
		</getTier2Config>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Represents a saleable item that can be provided/distributed in terms of one purchase.

    An asset is characterized by the following:

    - Every asset reflects some purchase (somebody purchases either a service or a good).
    - Purchase action can be reverted (canceled) or terminated when terms of purchase are expired.
    - Asset can be subscription-based (when customer pay for usage in some time terms) or
      one-time based.
    - Matter of asset is defined as list of purchased items with purchased quantities
      (asset items).
    - Item in asset may be either reservation-based, when customer decides how many items of SKU
      to be purchased or Pay-Per-User based when actual use of the SKU defines quantity for
      asset item.
    - Asset may be modified using change requests: either set of items may be changed or quantities
      of reservation-based items may be changed.
    - Some assets can be put into suspend state, when service is not actually provided
      and no charges happened.
    - Assets also may be parametrized by one or more parameters which differentiate
      one asset from another.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.models.AssetRequest" params="" file="connect/models/AssetRequest.hx">
		<extends path="connect.models.IdModel"/>
		<list public="1" set="method" line="99" static="1">
			<f a="filters">
				<c path="connect.api.Query"/>
				<c path="connect.util.Collection"><c path="connect.models.AssetRequest"/></c>
			</f>
			<haxe_doc>Lists all requests that match the given filters. Supported filters are:

        - `status`
        - `created`
        - `id` (List support)
        - `type` (purchase|renew|change|cancel)
        - `asset.id` (asset_id) - (List support)
        - `asset.product.id` (product_id)
        - `asset.product.name` - (List support)
        - `asset.hub.id`
        - `asset.connection.hub.name` - (List support)
        - `asset.connection.provider.id`
        - `asset.connection.provider.name` - (List support)
        - `asset.connection.vendor.name` - (List support)
        - `asset.tiers.customer.id` (Customer ID)
        - `asset.tiers.tier1.id`
        - `asset.tiers.tier2.id`
        - `asset.connection.type` (test|production|preview)

        @returns A Collection of AssetRequests.</haxe_doc>
		</list>
		<get public="1" set="method" line="105" static="1">
			<f a="id">
				<c path="String"/>
				<c path="connect.models.AssetRequest"/>
			</f>
			<haxe_doc>@returns The AssetRequest with the given id, or `null` if it was not found.</haxe_doc>
		</get>
		<type public="1">
			<c path="String"/>
			<haxe_doc>Type of request. One of: purchase, change, suspend, resume, renew, cancel.</haxe_doc>
		</type>
		<created public="1">
			<c path="connect.util.DateTime"/>
			<haxe_doc>Date of request creation.</haxe_doc>
		</created>
		<updated public="1">
			<c path="connect.util.DateTime"/>
			<haxe_doc>Date of last request modification.</haxe_doc>
		</updated>
		<status public="1">
			<c path="String"/>
			<haxe_doc><![CDATA[Status of request. One of: pending, inquiring, failed, approved.

        Valid status changes:

        - pending -> inquiring
        - pending -> failed
        - pending -> approved
        - inquiring -> failed
        - inquiring -> approved
        - inquiring -> pending]]></haxe_doc>
		</status>
		<paramsFormUrl public="1">
			<c path="String"/>
			<haxe_doc>URL for customer/reseller/provider for modifying param based on vendor's feedback.</haxe_doc>
		</paramsFormUrl>
		<activationKey public="1">
			<c path="String"/>
			<haxe_doc>Activation key content for activating the subscription on vendor portal.
        This markdown formatted message is sent to customer.</haxe_doc>
		</activationKey>
		<reason public="1">
			<c path="String"/>
			<haxe_doc>Fail reason in case of status of request is failed.</haxe_doc>
		</reason>
		<note public="1">
			<c path="String"/>
			<haxe_doc>Details of note.</haxe_doc>
		</note>
		<asset public="1">
			<c path="connect.models.Asset"/>
			<haxe_doc>Asset object</haxe_doc>
		</asset>
		<contract public="1">
			<c path="connect.models.Contract"/>
			<haxe_doc>Contract object.</haxe_doc>
		</contract>
		<marketplace public="1">
			<c path="connect.models.Marketplace"/>
			<haxe_doc>Marketplace object.</haxe_doc>
		</marketplace>
		<assignee public="1">
			<c path="String"/>
			<haxe_doc>Connect returns either a String or a JSON object in this field. When it is an object,
        its String representation is stored.</haxe_doc>
		</assignee>
		<register public="1" set="method" line="127">
			<f a=""><c path="connect.models.AssetRequest"/></f>
			<haxe_doc>Registers a new AssetRequest on Connect, based on the data of `this` AssetRequest, which
        should have a value at least in the following fields:

        - type
        - asset.externalUid
        - asset.items
        - asset.product.id
        - asset.tiers
        - marketplace.id

        @returns The new AssetRequest, or `null` if it couldn't be created.</haxe_doc>
		</register>
		<update public="1" set="method" line="152">
			<f a="params">
				<c path="connect.util.Collection"><c path="connect.models.Param"/></c>
				<c path="connect.models.AssetRequest"/>
			</f>
			<haxe_doc>Updates the request in the server with the data changed in `this` model.

        If no parameters are specified for updating, you should reassign your request with the
        object returned by this method, so the next time you call `update` on the object, the SDK
        knows the fields that already got updated in a previous call, like this:

        ```
        request = request.update(null);
        ```

        @param params A collection of parameters to update. If `null` is passed, then the
        parameters that have changed in the request will be sent.
        @returns The AssetRequest returned from the server, which should contain
        the same data as `this` AssetRequest, or `null` if the updating fails.</haxe_doc>
		</update>
		<addValueToParams set="method" line="178"><f a="obj">
	<d/>
	<d/>
</f></addValueToParams>
		<approveByTemplate public="1" set="method" line="202">
			<f a="id">
				<c path="String"/>
				<c path="connect.models.AssetRequest"/>
			</f>
			<haxe_doc>Changes `this` AssetRequest status to "approved", sending the id of a Template to render
        on the portal.

        When processing requests within a `Flow`, you should use the `Flow.approveByTemplate`
        method instead of this one, since it finishes the flow and logs the information.

        @returns The AssetRequest returned from the server, which should contain
        the updated status.</haxe_doc>
		</approveByTemplate>
		<approveByTile public="1" set="method" line="222">
			<f a="text">
				<c path="String"/>
				<c path="connect.models.AssetRequest"/>
			</f>
			<haxe_doc>Changes `this` AssetRequest status to "approved", rendering a tile on the portal with
        the given Markdown `text`.

        When processing requests within a `Flow`, you should use the `Flow.approveByTile`
        method instead of this one, since it finishes the flow and logs the information.

        @returns The AssetRequest returned from the server, which should contain
        the updated status.</haxe_doc>
		</approveByTile>
		<fail public="1" set="method" line="241">
			<f a="reason">
				<c path="String"/>
				<c path="connect.models.AssetRequest"/>
			</f>
			<haxe_doc>Changes the status of `this` AssetRequest to "failed".

        When processing requests within a `Flow`, you should use the `Flow.fail`
        method instead of this one, since it finishes the flow and logs the information.

        @returns The AssetRequest returned from the server, which should contain
        the updated status.</haxe_doc>
		</fail>
		<inquire public="1" set="method" line="261">
			<f a="templateId">
				<c path="String"/>
				<c path="connect.models.AssetRequest"/>
			</f>
			<haxe_doc>Changes the status of `this` AssetRequest to "inquiring".

        When processing requests within a `Flow`, you should use the `Flow.inquire`
        method instead of this one, since it finishes the flow and logs the information.

        @param templateId Id of the template to use in the portal, or `null` to not use any.
        @returns The AssetRequest returned from the server, which should contain
        the updated status.</haxe_doc>
		</inquire>
		<pend public="1" set="method" line="283">
			<f a=""><c path="connect.models.AssetRequest"/></f>
			<haxe_doc>Changes the status of `this` AssetRequest to "pending".

        When processing requests within a `Flow`, you should use the `Flow.pend`
        method instead of this one, since it finishes the flow and logs the information.

        @returns The AssetRequest returned from the server, which should contain
        the updated status.</haxe_doc>
		</pend>
		<assign public="1" set="method" line="295">
			<f a="assigneeId">
				<c path="String"/>
				<c path="connect.models.AssetRequest"/>
			</f>
			<haxe_doc>Assigns `this` request to the assignee with the given `assigneeId`.

        @returns The AssetRequest returned from the server, which should contain
        the updated assignee.</haxe_doc>
		</assign>
		<needsMigration public="1" set="method" line="306">
			<f a="?key" v="&quot;migration_info&quot;">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ key : "migration_info" }</e></m></meta>
			<haxe_doc>@returns Whether `this` AssetRequest is pending migration. This is indicated by the
        presence of a parameter that contains JSON data. By default, it checks the parameter
        "migration_info" and, if it is not found, it checks for "migration_info_object".</haxe_doc>
		</needsMigration>
		<getConversation public="1" set="method" line="316">
			<f a=""><c path="connect.models.Conversation"/></f>
			<haxe_doc>@returns The Conversation assigned to `this` AssetRequest, or `null` if there is none.</haxe_doc>
		</getConversation>
		<_updateConversation public="1" set="method" line="327">
			<f a="message">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_updateConversation>
		<new public="1" set="method" line="68"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Represents a request of the Fulfillment Api.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.models.BillingAnniversary" params="" file="connect/models/BillingAnniversary.hx">
		<extends path="connect.models.Model"/>
		<day public="1"><x path="Int"/></day>
		<month public="1"><x path="Int"/></month>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="connect.models.BillingInfo" params="" file="connect/models/BillingInfo.hx">
		<extends path="connect.models.Model"/>
		<stats public="1"><c path="connect.models.BillingStats"/></stats>
		<period public="1"><c path="connect.models.Period"/></period>
		<nextDate public="1"><c path="connect.util.DateTime"/></nextDate>
		<anniversary public="1"><c path="connect.models.BillingAnniversary"/></anniversary>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="connect.models.BillingStats" params="" file="connect/models/BillingStats.hx">
		<extends path="connect.models.Model"/>
		<vendor public="1"><c path="connect.models.BillingStatsInfo"/></vendor>
		<provider public="1"><c path="connect.models.BillingStatsInfo"/></provider>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="connect.models.BillingStatsInfo" params="" file="connect/models/BillingStatsInfo.hx">
		<extends path="connect.models.Model"/>
		<lastRequest public="1"><c path="connect.models.BillingStatsRequest"/></lastRequest>
		<count public="1">
			<x path="Int"/>
			<haxe_doc>Number of billing requests.</haxe_doc>
		</count>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="connect.models.BillingStatsRequest" params="" file="connect/models/BillingStatsRequest.hx">
		<extends path="connect.models.IdModel"/>
		<type public="1">
			<c path="String"/>
			<haxe_doc>One of: provider, vendor.</haxe_doc>
		</type>
		<period public="1"><c path="connect.models.Period"/></period>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="connect.models.Category" params="" file="connect/models/Category.hx">
		<extends path="connect.models.IdModel"/>
		<list public="1" set="method" line="39" static="1">
			<f a="filters">
				<c path="connect.api.Query"/>
				<c path="connect.util.Collection"><c path="connect.models.Category"/></c>
			</f>
			<haxe_doc>Lists all Categories that match the given filters. Supported filters are:

        - `family.id`
        - `parent.id`

        @returns A Collection of Categories.</haxe_doc>
		</list>
		<get public="1" set="method" line="46" static="1">
			<f a="id">
				<c path="String"/>
				<c path="connect.models.Category"/>
			</f>
			<haxe_doc>@returns The Category with the given id, or `null` if it was not found.</haxe_doc>
		</get>
		<name public="1">
			<c path="String"/>
			<haxe_doc>Category name.</haxe_doc>
		</name>
		<parent public="1">
			<c path="connect.models.Category"/>
			<haxe_doc>Reference to parent category.</haxe_doc>
		</parent>
		<children public="1">
			<c path="connect.util.Collection"><c path="connect.models.Category"/></c>
			<haxe_doc>Collection of children categories.</haxe_doc>
		</children>
		<family public="1">
			<c path="connect.models.Family"/>
			<haxe_doc>Product family.</haxe_doc>
		</family>
		<new public="1" set="method" line="56"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Represents a product category.</haxe_doc>
	</class>
	<class path="connect.models.Choice" params="" file="connect/models/Choice.hx">
		<extends path="connect.models.Model"/>
		<value public="1">
			<c path="String"/>
			<haxe_doc>The value of `this` Choice.</haxe_doc>
		</value>
		<label public="1">
			<c path="String"/>
			<haxe_doc>The label shown to the user in the dropdown selector.</haxe_doc>
		</label>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>A value choice for a parameter.</haxe_doc>
	</class>
	<class path="connect.models.Configuration" params="" file="connect/models/Configuration.hx">
		<extends path="connect.models.Model"/>
		<params public="1">
			<c path="connect.util.Collection"><c path="connect.models.Param"/></c>
			<haxe_doc>The collection of parameters.</haxe_doc>
		</params>
		<getParamById public="1" set="method" line="24">
			<f a="paramId">
				<c path="String"/>
				<c path="connect.models.Param"/>
			</f>
			<haxe_doc>@returns The `Param` with the given id, or `null` if it was not found.</haxe_doc>
		</getParamById>
		<new public="1" set="method" line="18"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Configuration Phase Parameter Context-Bound Data Object. To be used in parameter contexts:

    - Asset.
    - Fulfillment.
    - TierConfig.
    - TierConfigRequest.</haxe_doc>
	</class>
	<class path="connect.models.Configurations" params="" file="connect/models/Configurations.hx">
		<extends path="connect.models.Model"/>
		<suspendResumeSupported public="1">
			<x path="Bool"/>
			<haxe_doc>Is suspend and resume supported for the product?</haxe_doc>
		</suspendResumeSupported>
		<requiresResellerInformation public="1">
			<x path="Bool"/>
			<haxe_doc>Does the product require reseller information?</haxe_doc>
		</requiresResellerInformation>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Product configurations.</haxe_doc>
	</class>
	<class path="connect.models.Connection" params="" file="connect/models/Connection.hx">
		<extends path="connect.models.IdModel"/>
		<type public="1">
			<c path="String"/>
			<haxe_doc>Type of connection (one of: production, test, preview).</haxe_doc>
		</type>
		<provider public="1">
			<c path="connect.models.Account"/>
			<haxe_doc>Provider account reference.</haxe_doc>
		</provider>
		<vendor public="1">
			<c path="connect.models.Account"/>
			<haxe_doc>Vendor account reference.</haxe_doc>
		</vendor>
		<product public="1">
			<c path="connect.models.Product"/>
			<haxe_doc>Product reference.</haxe_doc>
		</product>
		<hub public="1">
			<c path="connect.models.Hub"/>
			<haxe_doc>Hub reference.</haxe_doc>
		</hub>
		<status public="1"><c path="String"/></status>
		<createdAt public="1"><c path="connect.util.DateTime"/></createdAt>
		<new public="1" set="method" line="46"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Represents a communication channel which provides the ability
    to order products within particular hub.

    Standalone connection is required for each product and for each provider account.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.models.Constraints" params="" file="connect/models/Constraints.hx">
		<extends path="connect.models.Model"/>
		<required public="1">
			<x path="Bool"/>
			<haxe_doc>Is the parameter required?</haxe_doc>
		</required>
		<hidden public="1">
			<x path="Bool"/>
			<haxe_doc>Is the parameter hidden?</haxe_doc>
		</hidden>
		<unique public="1">
			<x path="Bool"/>
			<haxe_doc>Is the constraint unique?</haxe_doc>
		</unique>
		<reconciliation public="1">
			<x path="Bool"/>
			<haxe_doc>An explicit way to specify one of the fulfillment parameters as
     * "primary reconciliation ID by the Vendor for the Asset", shown
     * as "asset_recon_id" in the Usage File format.</haxe_doc>
		</reconciliation>
		<shared public="1">
			<c path="String"/>
			<haxe_doc>Provider access. One of: view, edit.</haxe_doc>
		</shared>
		<minLength public="1">
			<x path="Int"/>
			<haxe_doc>Minimum characters required.</haxe_doc>
		</minLength>
		<maxLength public="1">
			<x path="Int"/>
			<haxe_doc>Maximum characters allowed.</haxe_doc>
		</maxLength>
		<choices public="1">
			<c path="connect.util.Collection"><c path="connect.models.Choice"/></c>
			<haxe_doc>A collection of choices.</haxe_doc>
		</choices>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Parameter constraints.</haxe_doc>
	</class>
	<class path="connect.models.Contact" params="" file="connect/models/Contact.hx">
		<extends path="connect.models.Model"/>
		<firstName public="1">
			<c path="String"/>
			<haxe_doc>First name.</haxe_doc>
		</firstName>
		<lastName public="1">
			<c path="String"/>
			<haxe_doc>Last name.</haxe_doc>
		</lastName>
		<email public="1">
			<c path="String"/>
			<haxe_doc>Email address.</haxe_doc>
		</email>
		<phoneNumber public="1">
			<c path="connect.models.PhoneNumber"/>
			<haxe_doc>Phone number.</haxe_doc>
		</phoneNumber>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Person of contact.</haxe_doc>
	</class>
	<class path="connect.models.ContactInfo" params="" file="connect/models/ContactInfo.hx">
		<extends path="connect.models.Model"/>
		<addressLine1 public="1">
			<c path="String"/>
			<haxe_doc>Street address, first line.</haxe_doc>
		</addressLine1>
		<addressLine2 public="1">
			<c path="String"/>
			<haxe_doc>Street address, second line.</haxe_doc>
		</addressLine2>
		<country public="1">
			<c path="String"/>
			<haxe_doc>Country code.</haxe_doc>
		</country>
		<state public="1">
			<c path="String"/>
			<haxe_doc>State name.</haxe_doc>
		</state>
		<city public="1">
			<c path="String"/>
			<haxe_doc>City name.</haxe_doc>
		</city>
		<postalCode public="1">
			<c path="String"/>
			<haxe_doc>Postal ZIP code.</haxe_doc>
		</postalCode>
		<contact public="1">
			<c path="connect.models.Contact"/>
			<haxe_doc>Person of contact.</haxe_doc>
		</contact>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Represents the information of a contact.</haxe_doc>
	</class>
	<class path="connect.models.Contract" params="" file="connect/models/Contract.hx">
		<extends path="connect.models.IdModel"/>
		<name public="1">
			<c path="String"/>
			<haxe_doc>Contract name.</haxe_doc>
		</name>
		<version public="1">
			<x path="Int"/>
			<haxe_doc>Version of the contract (same as associated agreement version).</haxe_doc>
		</version>
		<type public="1">
			<c path="String"/>
			<haxe_doc>Type of contract (same as agreement type). One of: distribution, program, service.</haxe_doc>
		</type>
		<status public="1">
			<c path="String"/>
			<haxe_doc>Contract status. One of: enrolling, pending, active, terminated, rejected.</haxe_doc>
		</status>
		<agreement public="1">
			<c path="connect.models.Agreement"/>
			<haxe_doc>Agreement object reference.</haxe_doc>
		</agreement>
		<marketplace public="1">
			<c path="connect.models.Marketplace"/>
			<haxe_doc>Marketplace object reference.</haxe_doc>
		</marketplace>
		<owner public="1">
			<c path="connect.models.Account"/>
			<haxe_doc>Owner Account object reference.</haxe_doc>
		</owner>
		<creator public="1">
			<c path="connect.models.User"/>
			<haxe_doc>Create User object reference.</haxe_doc>
		</creator>
		<created public="1">
			<c path="connect.util.DateTime"/>
			<haxe_doc>Contract creation date.</haxe_doc>
		</created>
		<updated public="1">
			<c path="connect.util.DateTime"/>
			<haxe_doc>Contract status update date.</haxe_doc>
		</updated>
		<enrolled public="1">
			<c path="connect.util.DateTime"/>
			<haxe_doc>Contract enrollment date.</haxe_doc>
		</enrolled>
		<versionCreated public="1">
			<c path="connect.util.DateTime"/>
			<haxe_doc>Contract version creation date.</haxe_doc>
		</versionCreated>
		<activation public="1">
			<c path="connect.models.Activation"/>
			<haxe_doc>Activation informacion.</haxe_doc>
		</activation>
		<signee public="1">
			<c path="connect.models.User"/>
			<haxe_doc>Signee User object reference, who signed the contract.</haxe_doc>
		</signee>
		<new public="1" set="method" line="70"><f a=""><x path="Void"/></f></new>
		<haxe_doc>A contract in the Connect platform.</haxe_doc>
	</class>
	<class path="connect.models.Conversation" params="" file="connect/models/Conversation.hx">
		<extends path="connect.models.IdModel"/>
		<list public="1" set="method" line="38" static="1">
			<f a="filters">
				<c path="connect.api.Query"/>
				<c path="connect.util.Collection"><c path="connect.models.Conversation"/></c>
			</f>
			<haxe_doc>Lists conversations.

        @returns A collection of Conversations.</haxe_doc>
		</list>
		<create public="1" set="method" line="49" static="1">
			<f a="instanceId:topic">
				<c path="String"/>
				<c path="String"/>
				<c path="connect.models.Conversation"/>
			</f>
			<haxe_doc>Creates a new conversation, linked to the given `instanceId`, and with the
        specified `topic`.

        @returns The created Conversation.</haxe_doc>
		</create>
		<get public="1" set="method" line="58" static="1">
			<f a="id">
				<c path="String"/>
				<c path="connect.models.Conversation"/>
			</f>
			<haxe_doc>@returns The Conversation with the given id, or `null` if it was not found.</haxe_doc>
		</get>
		<instanceId public="1">
			<c path="String"/>
			<haxe_doc>The id of object based on which discussion is made, e.g. listing request.
        It can be any object.</haxe_doc>
		</instanceId>
		<created public="1">
			<c path="connect.util.DateTime"/>
			<haxe_doc>Date of the Conversation creation.</haxe_doc>
		</created>
		<topic public="1">
			<c path="String"/>
			<haxe_doc>Conversation topic.</haxe_doc>
		</topic>
		<messages public="1">
			<c path="connect.util.Collection"><c path="connect.models.Message"/></c>
			<haxe_doc>Collection of messages.</haxe_doc>
		</messages>
		<creator public="1">
			<c path="connect.models.User"/>
			<haxe_doc>Creator of the conversation.</haxe_doc>
		</creator>
		<createMessage public="1" set="method" line="74">
			<f a="text">
				<c path="String"/>
				<c path="connect.models.Message"/>
			</f>
			<haxe_doc>Creates a new message in `this` Conversation with the given `text`, as long as the text
        is not the same as the one in the last `Message`.

        @returns The created `Message`, or `null` if the last message in the `Conversation` is
        the same as this one.</haxe_doc>
		</createMessage>
		<new public="1" set="method" line="86"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Conversation.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.models.Country" params="" file="connect/models/Country.hx">
		<extends path="connect.models.IdModel"/>
		<name public="1">
			<c path="String"/>
			<haxe_doc>Country name.</haxe_doc>
		</name>
		<icon public="1">
			<c path="String"/>
			<haxe_doc>Icon path.</haxe_doc>
		</icon>
		<zone public="1">
			<c path="String"/>
			<haxe_doc>Geographical zone.</haxe_doc>
		</zone>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Country data.</haxe_doc>
	</class>
	<class path="connect.models.CustomerUiSettings" params="" file="connect/models/CustomerUiSettings.hx">
		<extends path="connect.models.Model"/>
		<description public="1">
			<c path="String"/>
			<haxe_doc>Description text.</haxe_doc>
		</description>
		<gettingStarted public="1">
			<c path="String"/>
			<haxe_doc>Getting started text.</haxe_doc>
		</gettingStarted>
		<downloadLinks public="1">
			<c path="connect.util.Collection"><c path="connect.models.DownloadLink"/></c>
			<haxe_doc>Collection of download links.</haxe_doc>
		</downloadLinks>
		<documents public="1">
			<c path="connect.util.Collection"><c path="connect.models.Document"/></c>
			<haxe_doc>Collection of documents.</haxe_doc>
		</documents>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Customer Ui Settings for a product.</haxe_doc>
	</class>
	<class path="connect.models.Document" params="" file="connect/models/Document.hx">
		<extends path="connect.models.Model"/>
		<title public="1">
			<c path="String"/>
			<haxe_doc>Document title.</haxe_doc>
		</title>
		<url public="1"><c path="String"/></url>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Document for a product.</haxe_doc>
	</class>
	<class path="connect.models.DownloadLink" params="" file="connect/models/DownloadLink.hx">
		<extends path="connect.models.Model"/>
		<title public="1">
			<c path="String"/>
			<haxe_doc>Link title.</haxe_doc>
		</title>
		<url public="1">
			<c path="String"/>
			<haxe_doc>Link URL.</haxe_doc>
		</url>
		<visibleFor public="1">
			<c path="String"/>
			<haxe_doc>Link visibility. One of: admin, user.</haxe_doc>
		</visibleFor>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Download link for a product.</haxe_doc>
	</class>
	<class path="connect.models.Event" params="" file="connect/models/Event.hx">
		<extends path="connect.models.Model"/>
		<at public="1">
			<c path="connect.util.DateTime"/>
			<haxe_doc>Date when the event occurred.</haxe_doc>
		</at>
		<by public="1">
			<c path="connect.models.User"/>
			<haxe_doc>User that caused the event.</haxe_doc>
		</by>
		<new public="1" set="method" line="22"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Represents the date and user that caused an event.</haxe_doc>
	</class>
	<class path="connect.models.Events" params="" file="connect/models/Events.hx">
		<extends path="connect.models.Model"/>
		<created public="1">
			<c path="connect.models.Event"/>
			<haxe_doc>Creation event.</haxe_doc>
		</created>
		<inquired public="1">
			<c path="connect.models.Event"/>
			<haxe_doc>Inquire event.</haxe_doc>
		</inquired>
		<pended public="1">
			<c path="connect.models.Event"/>
			<haxe_doc>Pending event.</haxe_doc>
		</pended>
		<validated public="1">
			<c path="connect.models.Event"/>
			<haxe_doc>Validation event.</haxe_doc>
		</validated>
		<updated public="1">
			<c path="connect.models.Event"/>
			<haxe_doc>Update event.</haxe_doc>
		</updated>
		<approved public="1">
			<c path="connect.models.Event"/>
			<haxe_doc>Approve event.</haxe_doc>
		</approved>
		<uploaded public="1">
			<c path="connect.models.Event"/>
			<haxe_doc>Upload event.</haxe_doc>
		</uploaded>
		<submitted public="1">
			<c path="connect.models.Event"/>
			<haxe_doc>Submit event.</haxe_doc>
		</submitted>
		<accepted public="1">
			<c path="connect.models.Event"/>
			<haxe_doc>Accept event.</haxe_doc>
		</accepted>
		<rejected public="1">
			<c path="connect.models.Event"/>
			<haxe_doc>Reject event.</haxe_doc>
		</rejected>
		<closed public="1">
			<c path="connect.models.Event"/>
			<haxe_doc>Close event.</haxe_doc>
		</closed>
		<new public="1" set="method" line="56"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Represents a set of events that can take place on an object.</haxe_doc>
	</class>
	<class path="connect.models.ExtIdHub" params="" file="connect/models/ExtIdHub.hx">
		<extends path="connect.models.Model"/>
		<hub public="1">
			<c path="connect.models.Hub"/>
			<haxe_doc>Hub.</haxe_doc>
		</hub>
		<externalId public="1">
			<c path="String"/>
			<haxe_doc>External id.</haxe_doc>
		</externalId>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Associates a `Hub` with an external id.</haxe_doc>
	</class>
	<class path="connect.models.Family" params="" file="connect/models/Family.hx">
		<extends path="connect.models.IdModel"/>
		<name public="1">
			<c path="String"/>
			<haxe_doc>Family name.</haxe_doc>
		</name>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Represents a family of products.</haxe_doc>
	</class>
	<class path="connect.models.Hub" params="" file="connect/models/Hub.hx">
		<extends path="connect.models.IdModel"/>
		<name public="1">
			<c path="String"/>
			<haxe_doc>Hub name.</haxe_doc>
		</name>
		<company public="1">
			<c path="connect.models.Account"/>
			<haxe_doc>Reference to the company Account the hub belongs to.</haxe_doc>
		</company>
		<description public="1">
			<c path="String"/>
			<haxe_doc>Hub description (Markdown text).</haxe_doc>
		</description>
		<instance public="1">
			<c path="connect.models.Instance"/>
			<haxe_doc>Hub instance.</haxe_doc>
		</instance>
		<events public="1">
			<c path="connect.models.Events"/>
			<haxe_doc>Events occurred on Hub.</haxe_doc>
		</events>
		<stats public="1">
			<c path="connect.models.HubStats"/>
			<haxe_doc>Hub stats.</haxe_doc>
		</stats>
		<new public="1" set="method" line="36"><f a=""><x path="Void"/></f></new>
		<haxe_doc>A Hub.</haxe_doc>
	</class>
	<class path="connect.models.HubStats" params="" file="connect/models/HubStats.hx">
		<extends path="connect.models.Model"/>
		<connections public="1">
			<x path="Int"/>
			<haxe_doc>Number of connections active for the Hub.</haxe_doc>
		</connections>
		<marketplaces public="1">
			<x path="Int"/>
			<haxe_doc>Number of marketplaces for the Hub.</haxe_doc>
		</marketplaces>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Hub stats.</haxe_doc>
	</class>
	<class path="connect.models.Instance" params="" file="connect/models/Instance.hx">
		<extends path="connect.models.IdModel"/>
		<type public="1">
			<c path="String"/>
			<haxe_doc>E-Commerce system type.</haxe_doc>
		</type>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>An instance of a hub.</haxe_doc>
	</class>
	<class path="connect.models.Item" params="" file="connect/models/Item.hx">
		<extends path="connect.models.IdModel"/>
		<mpn public="1">
			<c path="String"/>
			<haxe_doc>Item manufacture part number.</haxe_doc>
		</mpn>
		<quantity public="1">
			<c path="String"/>
			<haxe_doc>Number of items of the type in the asset ("-1" if unlimited)</haxe_doc>
		</quantity>
		<oldQuantity public="1">
			<c path="String"/>
			<haxe_doc>Previous value of quantity.</haxe_doc>
		</oldQuantity>
		<renewal public="1">
			<c path="connect.models.Renewal"/>
			<haxe_doc>Parameters of renewal request (empty for all other types).</haxe_doc>
		</renewal>
		<params public="1">
			<c path="connect.util.Collection"><c path="connect.models.Param"/></c>
			<haxe_doc>List of Item and Item x Marketplace Configuration Phase Parameter Context-Bound Object.</haxe_doc>
		</params>
		<status public="1">
			<c path="String"/>
			<haxe_doc>Item status. One of: draft, published, endofsale.</haxe_doc>
		</status>
		<displayName public="1">
			<c path="String"/>
			<haxe_doc>Display name.</haxe_doc>
		</displayName>
		<globalId public="1">
			<c path="String"/>
			<haxe_doc>Global id.</haxe_doc>
		</globalId>
		<itemType public="1">
			<c path="String"/>
			<haxe_doc>Item type.</haxe_doc>
		</itemType>
		<period public="1">
			<c path="String"/>
			<haxe_doc>Period.</haxe_doc>
		</period>
		<type public="1">
			<c path="String"/>
			<haxe_doc>Type.</haxe_doc>
		</type>
		<name public="1">
			<c path="String"/>
			<haxe_doc>Name.</haxe_doc>
		</name>
		<description public="1">
			<c path="String"/>
			<haxe_doc>Description.</haxe_doc>
		</description>
		<billing public="1">
			<c path="connect.models.ItemBilling"/>
			<haxe_doc>Billing information (only for `SubscriptionRequest`)</haxe_doc>
		</billing>
		<getParamById public="1" set="method" line="82">
			<f a="paramId">
				<c path="String"/>
				<c path="connect.models.Param"/>
			</f>
			<haxe_doc>@returns The `Param` with the given id, or `null` if it was not found.</haxe_doc>
		</getParamById>
		<new public="1" set="method" line="73"><f a=""><x path="Void"/></f></new>
		<haxe_doc>A product item.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.models.ItemBilling" params="" file="connect/models/ItemBilling.hx">
		<extends path="connect.models.Model"/>
		<cycleNumber public="1">
			<x path="Int"/>
			<haxe_doc>Number of times that the `Item` has been billed.</haxe_doc>
		</cycleNumber>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="connect.models.Listing" params="" file="connect/models/Listing.hx">
		<extends path="connect.models.IdModel"/>
		<list public="1" set="method" line="66" static="1">
			<f a="filters">
				<c path="connect.api.Query"/>
				<c path="connect.util.Collection"><c path="connect.models.Listing"/></c>
			</f>
			<haxe_doc>Lists all listings that match the given filters. Supported filters are:

        - `status`
        - `contract`
        - `product`
        - `created_date`
        - `marketplace`
        - `sourcing__agreement`
        - `sourcing__published`

        @returns A Collection of Listings.</haxe_doc>
		</list>
		<get public="1" set="method" line="72" static="1">
			<f a="id">
				<c path="String"/>
				<c path="connect.models.Listing"/>
			</f>
			<haxe_doc>@returns The Listing with the given id, or `null` if it was not found.</haxe_doc>
		</get>
		<status public="1">
			<c path="String"/>
			<haxe_doc>Status of the listing. One of: listed, unlisted.</haxe_doc>
		</status>
		<contract public="1">
			<c path="connect.models.Contract"/>
			<haxe_doc>Distribution contract.</haxe_doc>
		</contract>
		<product public="1">
			<c path="connect.models.Product"/>
			<haxe_doc>Product reference.</haxe_doc>
		</product>
		<created public="1">
			<c path="connect.util.DateTime"/>
			<haxe_doc>Listing creation date.</haxe_doc>
		</created>
		<vendor public="1">
			<c path="connect.models.Account"/>
			<haxe_doc>Vendor account reference.</haxe_doc>
		</vendor>
		<provider public="1">
			<c path="connect.models.Account"/>
			<haxe_doc>Provider account reference.</haxe_doc>
		</provider>
		<sourcing public="1">
			<c path="connect.models.ListingSourcing"/>
			<haxe_doc>* Indicates whether the product is available in wholesale catalog.
     * Object appears when product can be published.</haxe_doc>
		</sourcing>
		<pendingRequest public="1">
			<c path="connect.models.ListingRequest"/>
			<haxe_doc>ListingRequest reference.</haxe_doc>
		</pendingRequest>
		<put public="1" set="method" line="95">
			<f a=""><c path="connect.models.Listing"/></f>
			<haxe_doc>Puts the listing in the Connect platform with the data changed in `this` model.

        You should reassign your listing with the object returned by this method, so the next time
        you call `put` on the object, the SDK knows the fields that already got updated in a
        previous call, like this:

        ```
        listing = listing.put();
        ```

        @returns The Listing returned from the server, which should contain
        the same data as `this` Listing.</haxe_doc>
		</put>
		<new public="1" set="method" line="42"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A Listing represents the the actual publishing procedure in the Connect platform.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.models.ListingRequest" params="" file="connect/models/ListingRequest.hx">
		<extends path="connect.models.IdModel"/>
		<list public="1" set="method" line="54" static="1">
			<f a="filters">
				<c path="connect.api.Query"/>
				<c path="connect.util.Collection"><c path="connect.models.ListingRequest"/></c>
			</f>
			<haxe_doc>Lists all listing requests that match the given filters. Supported filters are:

        - `type`
        - `status`
        - `listing`
        - `creator`
        - `assignee`
        - `created_date`
        - `notes`

        @returns A Collection of ListingRequests.</haxe_doc>
		</list>
		<get public="1" set="method" line="60" static="1">
			<f a="id">
				<c path="String"/>
				<c path="connect.models.ListingRequest"/>
			</f>
			<haxe_doc>@returns The ListingRequest with the given id, or `null` if it was not found.</haxe_doc>
		</get>
		<type public="1">
			<c path="String"/>
			<haxe_doc>Type of the listing request. One of: new, update, remove.</haxe_doc>
		</type>
		<product public="1">
			<c path="connect.models.Product"/>
			<haxe_doc>Version of the product attached to the Listing Request.</haxe_doc>
		</product>
		<state public="1">
			<c path="String"/>
			<haxe_doc>Status of the listing request. One of: draft, reviewing, deploying, completed, canceled.</haxe_doc>
		</state>
		<listing public="1">
			<c path="connect.models.Listing"/>
			<haxe_doc>Listing Object representation.</haxe_doc>
		</listing>
		<created public="1">
			<c path="connect.util.DateTime"/>
			<haxe_doc>Listing Request creation date.</haxe_doc>
		</created>
		<updated public="1">
			<c path="connect.util.DateTime"/>
			<haxe_doc>Listing Request update date.</haxe_doc>
		</updated>
		<register public="1" set="method" line="74">
			<f a=""><c path="connect.models.ListingRequest"/></f>
			<haxe_doc>Registers a new ListingRequest on Connect, based on the data of `this` ListingRequest.

        @returns The new ListingRequest, or `null` if it couldn't be created.</haxe_doc>
		</register>
		<assign public="1" set="method" line="86">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Assigns this request to the user whose authorization is stored in the configuration.</haxe_doc>
		</assign>
		<unassign public="1" set="method" line="98">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Unassigns this request from the user is was assigned to.</haxe_doc>
		</unassign>
		<changeToDraft public="1" set="method" line="110">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Changes the state of the request to "draft".</haxe_doc>
		</changeToDraft>
		<changeToDeploying public="1" set="method" line="122">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Changes the state of the request to "deploying".</haxe_doc>
		</changeToDeploying>
		<changeToCompleted public="1" set="method" line="134">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Changes the state of the request to "completed".</haxe_doc>
		</changeToCompleted>
		<changeToCanceled public="1" set="method" line="146">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Changes the state of the request to "canceled".</haxe_doc>
		</changeToCanceled>
		<changeToReviewing public="1" set="method" line="158">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Changes the state of the request to "reviewing".</haxe_doc>
		</changeToReviewing>
		<new public="1" set="method" line="33"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Represents a change request for a Listing object.</haxe_doc>
	</class>
	<class path="connect.models.ListingSourcing" params="" file="connect/models/ListingSourcing.hx">
		<extends path="connect.models.Model"/>
		<agreement public="1">
			<c path="connect.models.Agreement"/>
			<haxe_doc>Sourcing Agreement Reference.</haxe_doc>
		</agreement>
		<published public="1">
			<x path="Bool"/>
			<haxe_doc>Indicates whether it is published in the wholesale catalog.</haxe_doc>
		</published>
		<new public="1" set="method" line="12"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Indicates whether the product is available in wholesale catalog.
 * Object appears when product can be published.</haxe_doc>
	</class>
	<class path="connect.models.Marketplace" params="" file="connect/models/Marketplace.hx">
		<extends path="connect.models.IdModel"/>
		<list public="1" set="method" line="73" static="1">
			<f a="filters">
				<c path="connect.api.Query"/>
				<c path="connect.util.Collection"><c path="connect.models.Marketplace"/></c>
			</f>
			<haxe_doc>Lists all marketplaces that match the given filters. Supported filters are:

        - `id`
        - `name`
        - `owner.id`
        - `owner.name`
        - `sourcing`
        - `search`
        - `owner__id`

        @returns A Collection of Marketplaces.</haxe_doc>
		</list>
		<get public="1" set="method" line="79" static="1">
			<f a="id">
				<c path="String"/>
				<c path="connect.models.Marketplace"/>
			</f>
			<haxe_doc>@returns The Marketplace with the given id, or `null` if it was not found.</haxe_doc>
		</get>
		<name public="1">
			<c path="String"/>
			<haxe_doc>Marketplace title, unique for an account.</haxe_doc>
		</name>
		<description public="1">
			<c path="String"/>
			<haxe_doc>Markdown text describing the marketplace.</haxe_doc>
		</description>
		<activeContracts public="1">
			<x path="Int"/>
			<haxe_doc>How many active contracts were signed on the Marketplace.</haxe_doc>
		</activeContracts>
		<icon public="1">
			<c path="String"/>
			<haxe_doc>Image identifying Marketplace object uploaded by user.</haxe_doc>
		</icon>
		<owner public="1">
			<c path="connect.models.Account"/>
			<haxe_doc>Provider account - the object owner.</haxe_doc>
		</owner>
		<hubs public="1">
			<c path="connect.util.Collection"><c path="connect.models.ExtIdHub"/></c>
			<haxe_doc>Collection of account-hub relations associated with the Marketplace object.</haxe_doc>
		</hubs>
		<zone public="1">
			<c path="String"/>
			<haxe_doc>Zone where the marketplace is located, there can be following zones:
        AF, NA, OC, AS, EU, SA (It is continents).</haxe_doc>
		</zone>
		<countries public="1">
			<c path="connect.util.Collection"><c path="connect.models.Country"/></c>
			<haxe_doc>Collection of country objects associated with marketplace.</haxe_doc>
		</countries>
		<sourcing public="1">
			<x path="Bool"/>
			<haxe_doc>Is marketplace available for sourcing?</haxe_doc>
		</sourcing>
		<currency public="1"><c path="String"/></currency>
		<register public="1" set="method" line="93">
			<f a=""><c path="connect.models.Marketplace"/></f>
			<haxe_doc>Registers a new Marketplace on Connect, based on the data of `this` Marketplace.

        @returns The new Marketplace, or `null` if it couldn't be created.</haxe_doc>
		</register>
		<update public="1" set="method" line="116">
			<f a=""><c path="connect.models.Marketplace"/></f>
			<haxe_doc>Updates the Marketplace in the server with the data changed in `this` model.

        You should reassign your marketplace with the object returned by this method, so the next time
        you call `update` on the object, the SDK knows the fields that already got updated in a
        previous call, like this:

        ```
        marketplace = marketplace.update();
        ```

        @returns The Marketplace returned from the server, which should contain
        the same data as `this` Marketplace, or `null` if the updating fails.</haxe_doc>
		</update>
		<setIcon public="1" set="method" line="136">
			<f a="icon">
				<c path="connect.util.Blob"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Sets the icon of `this` Marketplace.</haxe_doc>
		</setIcon>
		<remove public="1" set="method" line="148">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Removes `this` Marketplace from Connect.</haxe_doc>
		</remove>
		<new public="1" set="method" line="51"><f a=""><x path="Void"/></f></new>
		<haxe_doc>An object containing Distribution agreements with exact Hubs, enriched with additional
    information on details about the relation.

    A Marketplace is a way to list Products to specified regions (based on Distribution Agreements)
    and use specific Hubs to provision incoming Fulfillment requests.</haxe_doc>
	</class>
	<class path="connect.models.Media" params="" file="connect/models/Media.hx">
		<extends path="connect.models.IdModel"/>
		<position public="1"><x path="Int"/></position>
		<type public="1">
			<c path="String"/>
			<haxe_doc>Inner media type. One of: image, video.</haxe_doc>
		</type>
		<thumbnail public="1">
			<c path="String"/>
			<haxe_doc>URL for image or video thumbnail to our Azure media storage.</haxe_doc>
		</thumbnail>
		<url public="1">
			<c path="String"/>
			<haxe_doc>Video URL.</haxe_doc>
		</url>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Media object represents a media item, like image or video, related to a Product.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.models.Message" params="" file="connect/models/Message.hx">
		<extends path="connect.models.IdModel"/>
		<conversation public="1">
			<c path="String"/>
			<haxe_doc>Primary id of Conversation object.</haxe_doc>
		</conversation>
		<created public="1">
			<c path="connect.util.DateTime"/>
			<haxe_doc>Date of the Message creation.</haxe_doc>
		</created>
		<creator public="1">
			<c path="connect.models.User"/>
			<haxe_doc>User that created the message.</haxe_doc>
		</creator>
		<text public="1">
			<c path="String"/>
			<haxe_doc>Actual message.</haxe_doc>
		</text>
		<new public="1" set="method" line="29"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Message in a `Conversation`.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.models.Param" params="" file="connect/models/Param.hx">
		<extends path="connect.models.IdModel"/>
		<name public="1">
			<c path="String"/>
			<haxe_doc>Name of parameter.</haxe_doc>
		</name>
		<title public="1">
			<c path="String"/>
			<haxe_doc>Title of parameter.</haxe_doc>
		</title>
		<description public="1">
			<c path="String"/>
			<haxe_doc>Description of parameter.</haxe_doc>
		</description>
		<type public="1">
			<c path="String"/>
			<haxe_doc>Type of parameter. One of: text, dropdown, password, email, checkbox, subdomain, domain, phone, url, choice.</haxe_doc>
		</type>
		<hint public="1">
			<c path="String"/>
			<haxe_doc>Hint for parameter value.</haxe_doc>
		</hint>
		<placeholder public="1">
			<c path="String"/>
			<haxe_doc>Placeholder for parameter.</haxe_doc>
		</placeholder>
		<value public="1">
			<c path="String"/>
			<haxe_doc>Value of parameter.</haxe_doc>
		</value>
		<valueError public="1">
			<c path="String"/>
			<haxe_doc>Error indicated for parameter.</haxe_doc>
		</valueError>
		<valueChoice public="1">
			<c path="connect.util.Collection"><c path="String"/></c>
			<haxe_doc>Collections of string choices for parameter.</haxe_doc>
		</valueChoice>
		<constraints public="1">
			<c path="connect.models.Constraints"/>
			<haxe_doc>Parameter constraints.</haxe_doc>
		</constraints>
		<shared public="1">
			<c path="String"/>
			<haxe_doc>Provider access. One of: view, edit.</haxe_doc>
		</shared>
		<valueChoices public="1">
			<c path="connect.util.Collection"><c path="connect.models.Choice"/></c>
			<haxe_doc>Collection of available dropdown choices for parameter.</haxe_doc>
		</valueChoices>
		<events public="1">
			<c path="connect.models.Events"/>
			<haxe_doc>Events.</haxe_doc>
		</events>
		<structuredValue public="1">
			<c path="connect.util.Dictionary"/>
			<haxe_doc>Only for parameter types phone, address, checkbox and object.</haxe_doc>
		</structuredValue>
		<scope public="1">
			<c path="String"/>
			<haxe_doc>Scope of parameter.</haxe_doc>
		</scope>
		<phase public="1">
			<c path="String"/>
			<haxe_doc>Param phase.</haxe_doc>
		</phase>
		<marketplace public="1">
			<c path="connect.models.Marketplace"/>
			<haxe_doc>Marketplace.</haxe_doc>
		</marketplace>
		<isCheckboxChecked public="1" set="method" line="100">
			<f a="fieldName">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* If `this` Param is a checkbox, returns the status of the field specified in the param.
     * @param fieldName Name of the field whose status we want to check.
     * @return Bool Whether the checkbox is checked.</haxe_doc>
		</isCheckboxChecked>
		<new public="1" set="method" line="86"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Parameters are used in product and asset definitions.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.models.Period" params="" file="connect/models/Period.hx">
		<extends path="connect.models.Model"/>
		<from public="1">
			<c path="connect.util.DateTime"/>
			<haxe_doc><![CDATA[Date & time from which usage records are considered in the usage file.]]></haxe_doc>
		</from>
		<to public="1">
			<c path="connect.util.DateTime"/>
			<haxe_doc><![CDATA[Date & time till which usage records are considered in the usage file.]]></haxe_doc>
		</to>
		<delta public="1">
			<x path="Int"/>
			<haxe_doc>Number of times which choosen UOM takes in period.</haxe_doc>
		</delta>
		<uom public="1">
			<c path="String"/>
			<haxe_doc>Units of measure. One of: monthly, yearly.</haxe_doc>
		</uom>
		<new public="1" set="method" line="23"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This class represent the period covered by a `UsageFile`.</haxe_doc>
	</class>
	<class path="connect.models.PhoneNumber" params="" file="connect/models/PhoneNumber.hx">
		<extends path="connect.models.Model"/>
		<countryCode public="1">
			<c path="String"/>
			<haxe_doc>Country code.</haxe_doc>
		</countryCode>
		<areaCode public="1">
			<c path="String"/>
			<haxe_doc>Area code.</haxe_doc>
		</areaCode>
		<phoneNumber public="1">
			<c path="String"/>
			<haxe_doc>Phone number.</haxe_doc>
		</phoneNumber>
		<extension public="1">
			<c path="String"/>
			<haxe_doc>Phone extension.</haxe_doc>
		</extension>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Phone number.</haxe_doc>
	</class>
	<class path="connect.models.Product" params="" file="connect/models/Product.hx">
		<extends path="connect.models.IdModel"/>
		<list public="1" set="method" line="88" static="1">
			<f a="filters">
				<c path="connect.api.Query"/>
				<c path="connect.util.Collection"><c path="connect.models.Product"/></c>
			</f>
			<haxe_doc>Lists all Products that match the given filters. Supported filters are:

        - `name`
        - `category.id` (eq)
        - `owner.id`
        - `owner.name`
        - `version` (eq, ne, null)
        - `search`
        - `stats.listings`
        - `stats.agreements.distribution`
        - `stats.agreements.sourcing`
        - `stats.contracts.sourcing`
        - `stats.contracts.distribution`
        - `latest` (eq, ne)
        - `status` (Draft)

        @returns A Collection of Products.</haxe_doc>
		</list>
		<get public="1" set="method" line="94" static="1">
			<f a="id">
				<c path="String"/>
				<c path="connect.models.Product"/>
			</f>
			<haxe_doc>@returns The Product with the given id, or `null` if it was not found.</haxe_doc>
		</get>
		<name public="1">
			<c path="String"/>
			<haxe_doc>Product name.</haxe_doc>
		</name>
		<icon public="1">
			<c path="String"/>
			<haxe_doc>Product icon URI.</haxe_doc>
		</icon>
		<shortDescription public="1">
			<c path="String"/>
			<haxe_doc>Short description of `this` Product.</haxe_doc>
		</shortDescription>
		<detailedDescription public="1">
			<c path="String"/>
			<haxe_doc>Detailed description of `this` Product.</haxe_doc>
		</detailedDescription>
		<version public="1">
			<x path="Int"/>
			<haxe_doc>Version of `this` Product.</haxe_doc>
		</version>
		<publishedAt public="1">
			<c path="connect.util.DateTime"/>
			<haxe_doc>Date of publishing.</haxe_doc>
		</publishedAt>
		<configurations public="1">
			<c path="connect.models.Configurations"/>
			<haxe_doc>Product configurations.</haxe_doc>
		</configurations>
		<customerUiSettings public="1">
			<c path="connect.models.CustomerUiSettings"/>
			<haxe_doc>Customer UI Settings.</haxe_doc>
		</customerUiSettings>
		<category public="1">
			<c path="connect.models.Category"/>
			<haxe_doc>Product Category.</haxe_doc>
		</category>
		<owner public="1">
			<c path="connect.models.Account"/>
			<haxe_doc>Product owner Account.</haxe_doc>
		</owner>
		<latest public="1">
			<x path="Bool"/>
			<haxe_doc>true if version is latest or for master versions without versions, false otherwise.</haxe_doc>
		</latest>
		<stats public="1">
			<c path="connect.models.ProductStats"/>
			<haxe_doc>Statistics of product use, depends on account of callee.</haxe_doc>
		</stats>
		<status public="1"><c path="String"/></status>
		<listActions public="1" set="method" line="110">
			<f a="filters">
				<c path="connect.api.Query"/>
				<c path="connect.util.Collection"><c path="connect.models.Action"/></c>
			</f>
			<haxe_doc>Lists all Actions for the Product that match the given filters. Supported filters are:

        - `scope`

        @returns A Collection of Actions.</haxe_doc>
		</listActions>
		<getAction public="1" set="method" line="122">
			<f a="actionId">
				<c path="String"/>
				<c path="connect.models.Action"/>
			</f>
			<haxe_doc>@returns The Action for `this` Product with the given id, or `null` if it was not found.</haxe_doc>
		</getAction>
		<getActionLink public="1" set="method" line="135">
			<f a="actionId">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@returns The link for `this` Product's Action with the given id,
        or an empty string if it was not found.</haxe_doc>
		</getActionLink>
		<getConnections public="1" set="method" line="146">
			<f a=""><c path="connect.util.Collection"><c path="connect.models.Connection"/></c></f>
			<haxe_doc>@returns A Collection of Connections for `this` Product.</haxe_doc>
		</getConnections>
		<listItems public="1" set="method" line="164">
			<f a="filters">
				<c path="connect.api.Query"/>
				<c path="connect.util.Collection"><c path="connect.models.Item"/></c>
			</f>
			<haxe_doc><![CDATA[* Lists all Items of `this` Product that match the given filters. Supported filters are:
     * 
     * - limit
     * - offset
     * 
     * @param filters 
     * @return Collection<Item>]]></haxe_doc>
		</listItems>
		<getItems public="1" set="method" line="176">
			<f a=""><c path="connect.util.Collection"><c path="connect.models.Item"/></c></f>
			<haxe_doc>@returns A Collection of Items for `this` Product.</haxe_doc>
		</getItems>
		<listParameters public="1" set="method" line="192">
			<f a="filters">
				<c path="connect.api.Query"/>
				<c path="connect.util.Collection"><c path="connect.models.Param"/></c>
			</f>
			<haxe_doc><![CDATA[* Lists all parameters of `this` Product that match the given filters. Supported filters are:
     * 
     * - scope
     * - phase
     * - type
     * - constraints
     * - name
     * 
     * @param filters
     * @return Collection<Param>]]></haxe_doc>
		</listParameters>
		<getParameter public="1" set="method" line="206">
			<f a="paramId">
				<c path="String"/>
				<c path="connect.models.Param"/>
			</f>
			<haxe_doc>* Get the product parameter with the given `paramId`.
     * @param paramId Id of the parameter
     * @return Param</haxe_doc>
		</getParameter>
		<createParameter public="1" set="method" line="220">
			<f a="param">
				<c path="connect.models.Param"/>
				<c path="connect.models.Param"/>
			</f>
			<haxe_doc>* Creates the given parameter in `this` Product.
     * @param param The parameter to create in the Product.
     * @return Param A copy of the parameter, with an id assigned to it.</haxe_doc>
		</createParameter>
		<updateParameter public="1" set="method" line="234">
			<f a="param">
				<c path="connect.models.Param"/>
				<c path="connect.models.Param"/>
			</f>
			<haxe_doc>* Updates the given parameter in `this` Product.
     * @param param The parameter to update.
     * @return Param A copy of the parameter.</haxe_doc>
		</updateParameter>
		<deleteParameter public="1" set="method" line="248">
			<f a="paramId">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Deletes the parameter with the given `paramId` from `this` Product.
     * @param paramId 
     * @return Bool Whether the parameter was correctly deleted.</haxe_doc>
		</deleteParameter>
		<getTemplates public="1" set="method" line="260">
			<f a=""><c path="connect.util.Collection"><c path="connect.models.Template"/></c></f>
			<haxe_doc>@returns A Collection of Templates for `this` Product.</haxe_doc>
		</getTemplates>
		<getVersions public="1" set="method" line="272">
			<f a=""><c path="connect.util.Collection"><c path="connect.models.Product"/></c></f>
			<haxe_doc>@returns A Collection of Product versions for `this` Product.</haxe_doc>
		</getVersions>
		<getVersion public="1" set="method" line="284">
			<f a="version">
				<x path="Int"/>
				<c path="connect.models.Product"/>
			</f>
			<haxe_doc>@returns The version for `this` Product with the given value, or `null` if it was not found.</haxe_doc>
		</getVersion>
		<getVersionActions public="1" set="method" line="296">
			<f a="version">
				<x path="Int"/>
				<c path="connect.util.Collection"><c path="connect.models.Action"/></c>
			</f>
			<haxe_doc>@returns The Collection of Actions for `this` Product version.</haxe_doc>
		</getVersionActions>
		<getVersionAction public="1" set="method" line="309">
			<f a="version:actionId">
				<x path="Int"/>
				<c path="String"/>
				<c path="connect.models.Action"/>
			</f>
			<haxe_doc>@returns The specified Action for `this` Product version, or `null` if it was not found.</haxe_doc>
		</getVersionAction>
		<getVersionActionLink public="1" set="method" line="323">
			<f a="version:actionId">
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>@returns The link for `this` Product version's Action with the given id,
        or an empty string if it was not found.</haxe_doc>
		</getVersionActionLink>
		<getVersionItems public="1" set="method" line="335">
			<f a="version">
				<x path="Int"/>
				<c path="connect.util.Collection"><c path="connect.models.Item"/></c>
			</f>
			<haxe_doc>@returns A Collection of Items for `this` Product version.</haxe_doc>
		</getVersionItems>
		<getVersionParameters public="1" set="method" line="347">
			<f a="version">
				<x path="Int"/>
				<c path="connect.util.Collection"><c path="connect.models.Param"/></c>
			</f>
			<haxe_doc>@returns A Collection of Params for `this` Product version.</haxe_doc>
		</getVersionParameters>
		<getVersionTemplates public="1" set="method" line="359">
			<f a="version">
				<x path="Int"/>
				<c path="connect.util.Collection"><c path="connect.models.Template"/></c>
			</f>
			<haxe_doc>@returns A Collection of Templates for `this` Product version.</haxe_doc>
		</getVersionTemplates>
		<listConfigurations public="1" set="method" line="382">
			<f a="filters">
				<c path="connect.api.Query"/>
				<c path="connect.util.Collection"><c path="connect.models.ProductConfigurationParam"/></c>
			</f>
			<haxe_doc>Lists all ProductConfigurationParams that match the given filters. Supported filters are:

        - `parameter.id`
        - `parameter.title`
        - `parameter.scope`
        - `marketplace.id`
        - `marketplace.name`
        - `item.id`
        - `item.name`
        - `value`

        @returns A Collection of ProductConfigurationParams for `this` Product.</haxe_doc>
		</listConfigurations>
		<setConfigurationParam public="1" set="method" line="397">
			<f a="param">
				<c path="connect.models.ProductConfigurationParam"/>
				<c path="connect.models.ProductConfigurationParam"/>
			</f>
			<haxe_doc>Creates or updates a ProductConfigurationParam.

        @returns The created or updated ProductConfigurationParam for `this` Product,
        or `null` if there was a problem.</haxe_doc>
		</setConfigurationParam>
		<listAgreements public="1" set="method" line="409">
			<f a="filters">
				<c path="connect.api.Query"/>
				<c path="connect.util.Collection"><c path="connect.models.Agreement"/></c>
			</f>
			<haxe_doc>@returns A Collection of Agreements for `this` Product.</haxe_doc>
		</listAgreements>
		<listMedia public="1" set="method" line="428">
			<f a="filters">
				<c path="connect.api.Query"/>
				<c path="connect.util.Collection"><c path="connect.models.Media"/></c>
			</f>
			<haxe_doc>Lists all Media that match the given filters. Supported filters are:

        - `id`
        - `position`
        - `type`
        - `url`

        @returns A Collection of Media for `this` Product.</haxe_doc>
		</listMedia>
		<createMedia public="1" set="method" line="442">
			<f a=""><c path="connect.models.Media"/></f>
			<haxe_doc>Create a new media for `this` Product.

        @returns The created Media object, or `null` if it could not be created.</haxe_doc>
		</createMedia>
		<getMedia public="1" set="method" line="454">
			<f a="mediaId">
				<c path="String"/>
				<c path="connect.models.Media"/>
			</f>
			<haxe_doc>@returns The Media for `this` Product with the given id, or `null` if it was not found.</haxe_doc>
		</getMedia>
		<updateMedia public="1" set="method" line="468">
			<f a="media">
				<c path="connect.models.Media"/>
				<c path="connect.models.Media"/>
			</f>
			<haxe_doc>Updates a Media of `this` Product.

        @returns The updated Media for `this` Product, or `null` if there was a problem.</haxe_doc>
		</updateMedia>
		<deleteMedia public="1" set="method" line="482">
			<f a="mediaId">
				<c path="String"/>
				<c path="connect.models.Media"/>
			</f>
			<haxe_doc>Deletes a Media of `this` Product.

        @returns The deleted Media for `this` Product, or `null` if there was a problem.</haxe_doc>
		</deleteMedia>
		<new public="1" set="method" line="60"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Represents basic marketing information about salable items, parameters, configurations,
    latest published version and connections.

    It contains basic product information like name, description and logo, along with the latest
    published version details. So in a single point we can say a single product object always
    represent the latest published version of that product.</haxe_doc>
	</class>
	<class path="connect.models.ProductConfigurationParam" params="" file="connect/models/ProductConfigurationParam.hx">
		<extends path="connect.models.Model"/>
		<value public="1">
			<c path="String"/>
			<haxe_doc>Configuration parameter value.</haxe_doc>
		</value>
		<parameter public="1">
			<c path="connect.models.Param"/>
			<haxe_doc>Full representation of parameter.</haxe_doc>
		</parameter>
		<marketplace public="1">
			<c path="connect.models.Marketplace"/>
			<haxe_doc>Reference to Marketplace.</haxe_doc>
		</marketplace>
		<item public="1">
			<c path="connect.models.Item"/>
			<haxe_doc>Reference to Item.</haxe_doc>
		</item>
		<events public="1">
			<c path="connect.models.Events"/>
			<haxe_doc>Product events.</haxe_doc>
		</events>
		<constraints public="1">
			<c path="connect.models.Constraints"/>
			<haxe_doc>Constraints.</haxe_doc>
		</constraints>
		<new public="1" set="method" line="39"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Representation of Configuration Phase Parameter (CPP) Data object.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.models.ProductStats" params="" file="connect/models/ProductStats.hx">
		<extends path="connect.models.Model"/>
		<listings public="1">
			<x path="Int"/>
			<haxe_doc>Number of listings (direct use of product by provider).</haxe_doc>
		</listings>
		<agreements public="1">
			<c path="connect.models.ProductStatsInfo"/>
			<haxe_doc>Agreements related to the product.</haxe_doc>
		</agreements>
		<contracts public="1">
			<c path="connect.models.ProductStatsInfo"/>
			<haxe_doc>Contracts related to the product.</haxe_doc>
		</contracts>
		<new public="1" set="method" line="24"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Statistics of product use.</haxe_doc>
	</class>
	<class path="connect.models.ProductStatsInfo" params="" file="connect/models/ProductStatsInfo.hx">
		<extends path="connect.models.Model"/>
		<distribution public="1">
			<x path="Int"/>
			<haxe_doc>Number of distributions related to the product.</haxe_doc>
		</distribution>
		<sourcing public="1">
			<x path="Int"/>
			<haxe_doc>Number of sourcings related to the product.</haxe_doc>
		</sourcing>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Information of some `ProductStats` fields.</haxe_doc>
	</class>
	<class path="connect.models.Renewal" params="" file="connect/models/Renewal.hx">
		<extends path="connect.models.Model"/>
		<from public="1">
			<c path="connect.util.DateTime"/>
			<haxe_doc>Date of renewal beginning.</haxe_doc>
		</from>
		<to public="1">
			<c path="connect.util.DateTime"/>
			<haxe_doc>Date of renewal end.</haxe_doc>
		</to>
		<periodDelta public="1">
			<x path="Int"/>
			<haxe_doc>Size of renewal period.</haxe_doc>
		</periodDelta>
		<periodUom public="1">
			<c path="String"/>
			<haxe_doc>Unit of measure for renewal period. One of: year, month, day, hour.</haxe_doc>
		</periodUom>
		<new public="1" set="method" line="30"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Item renewal data.</haxe_doc>
	</class>
	<class path="connect.models.Subscription" params="" file="connect/models/Subscription.hx">
		<extends path="connect.models.IdModel"/>
		<list public="1" set="method" line="62" static="1">
			<f a="filters">
				<c path="connect.api.Query"/>
				<c path="connect.util.Collection"><c path="connect.models.Subscription"/></c>
			</f>
			<haxe_doc>Lists all subscription assets that match the given filters. Supported filters are:

        - `status`
        - `events.created.at`
        - `events.created.at`
        - `billing.period.uom`
        - `billing.next_date`
        - `external_id`
        - `external_uid`
        - `product.id`
        - `product.name`
        - `connection.id`
        - `connection.type`
        - `connection.provider.id`
        - `connection.provider.name`
        - `connection.vendor.id`
        - `connection.vendor.name`
        - `connection.hub.id`
        - `connection.hub.name`
        - `marketplace.id`
        - `marketplace.name`
        - `tiers.customer.id`
        - `tiers.tier1.id`
        - `tiers.tier2.id`

        @returns A Collection of Subscriptions.</haxe_doc>
		</list>
		<get public="1" set="method" line="68" static="1">
			<f a="id">
				<c path="String"/>
				<c path="connect.models.Subscription"/>
			</f>
			<haxe_doc>@returns The Subscription with the given id, or `null` if it was not found.</haxe_doc>
		</get>
		<status public="1"><c path="String"/></status>
		<events public="1"><c path="connect.models.Events"/></events>
		<externalId public="1"><c path="String"/></externalId>
		<externalUid public="1"><c path="String"/></externalUid>
		<product public="1"><c path="connect.models.Product"/></product>
		<connection public="1"><c path="connect.models.Connection"/></connection>
		<params public="1"><c path="connect.util.Collection"><c path="connect.models.Param"/></c></params>
		<tiers public="1"><c path="connect.models.Tiers"/></tiers>
		<marketplace public="1"><c path="connect.models.Marketplace"/></marketplace>
		<contract public="1"><c path="connect.models.Contract"/></contract>
		<items public="1"><c path="connect.util.Collection"><c path="connect.models.Item"/></c></items>
		<billing public="1"><c path="connect.models.BillingInfo"/></billing>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* This class represents assets with one or more reservation type items.</haxe_doc>
	</class>
	<class path="connect.models.SubscriptionRequest" params="" file="connect/models/SubscriptionRequest.hx">
		<extends path="connect.models.IdModel"/>
		<list public="1" set="method" line="63" static="1">
			<f a="filters">
				<c path="connect.api.Query"/>
				<c path="connect.util.Collection"><c path="connect.models.SubscriptionRequest"/></c>
			</f>
			<haxe_doc>Lists all requests that match the given filters. Supported filters are:

        - `id`
        - `type`
        - `period.uom`
        - `period.from`
        - `period.to`
        - `events.created.at` (le, ge)
        - `events.updated.at` (le, ge)
        - `asset.id`
        - `asset.billing.period.uom`
        - `asset.billing.next_date`
        - `asset.external_id`
        - `asset.external_uid`
        - `asset.product.id`
        - `asset.product.name`
        - `asset.connection.id`
        - `asset.connection.type`
        - `asset.connection.provider.id`
        - `asset.connection.provider.name`
        - `asset.connection.vendor.id`
        - `asset.connection.vendor.name`
        - `asset.connection.hub.id`
        - `asset.connection.hub.name`
        - `asset.marketplace.id`
        - `asset.marketplace.name`
        - `asset.tiers.customer.id`
        - `asset.tiers.tier1.id`
        - `asset.tiers.tier2.id`

        @returns A Collection of SubscriptionRequests.</haxe_doc>
		</list>
		<get public="1" set="method" line="70" static="1">
			<f a="id">
				<c path="String"/>
				<c path="connect.models.SubscriptionRequest"/>
			</f>
			<haxe_doc>@returns The SubscriptionRequest with the given id, or `null` if it was not found.</haxe_doc>
		</get>
		<type public="1">
			<c path="String"/>
			<haxe_doc>One of: provider, vendor.</haxe_doc>
		</type>
		<events public="1"><c path="connect.models.Events"/></events>
		<asset public="1"><c path="connect.models.Subscription"/></asset>
		<items public="1"><c path="connect.util.Collection"><c path="connect.models.Item"/></c></items>
		<attributes public="1"><c path="connect.models.SubscriptionRequestAttributes"/></attributes>
		<period public="1"><c path="connect.models.Period"/></period>
		<register public="1" set="method" line="84">
			<f a=""><c path="connect.models.SubscriptionRequest"/></f>
			<haxe_doc>Registers a new SubscriptionRequest on Connect, based on the data of `this` SubscriptionRequest.

        @returns The new SubscriptionRequest, or `null` if it couldn't be created.</haxe_doc>
		</register>
		<updateAttributes public="1" set="method" line="100">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Updates the request in the server with the attributes changed in `this` model.

        Only the attributes corresponding to the type (vendor or provider) will be updated.

        @returns Whether the attributes were correctly updated.</haxe_doc>
		</updateAttributes>
		<new public="1" set="method" line="22"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Represents a vendor (generated) or provider (uploaded) billing of a `Subscription`.</haxe_doc>
	</class>
	<class path="connect.models.SubscriptionRequestAttributes" params="" file="connect/models/SubscriptionRequestAttributes.hx">
		<extends path="connect.models.Model"/>
		<vendor public="1"><c path="connect.util.Dictionary"/></vendor>
		<provider public="1"><c path="connect.util.Dictionary"/></provider>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.models.Template" params="" file="connect/models/Template.hx">
		<extends path="connect.models.IdModel"/>
		<title public="1">
			<c path="String"/>
			<haxe_doc>Title of `tihs` Template.</haxe_doc>
		</title>
		<body public="1">
			<c path="String"/>
			<haxe_doc>Body of `this` Template.</haxe_doc>
		</body>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>A Template of a Product.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.models.TierAccount" params="" file="connect/models/TierAccount.hx">
		<extends path="connect.models.IdModel"/>
		<list public="1" set="method" line="59" static="1">
			<f a="filters">
				<c path="connect.api.Query"/>
				<c path="connect.util.Collection"><c path="connect.models.TierAccount"/></c>
			</f>
			<haxe_doc>Lists all TierAccounts that match the given filters. Supported filters are:

        - `id`
        - `external_id`
        - `external_uid`
        - `environment`
        - `scopes`
        - `marketplace.id`
        - `marketplace.name`
        - `hub.id`
        - `hub.name`
        - `search` (search based on all fields - generic search option)

        @returns A Collection of TierAccounts.</haxe_doc>
		</list>
		<get public="1" set="method" line="65" static="1">
			<f a="id">
				<c path="String"/>
				<c path="connect.models.TierAccount"/>
			</f>
			<haxe_doc>@returns The TierAccount with the given id, or `null` if it was not found.</haxe_doc>
		</get>
		<externalId public="1">
			<c path="String"/>
			<haxe_doc>Only in case of filtering by this field.</haxe_doc>
		</externalId>
		<name public="1">
			<c path="String"/>
			<haxe_doc>Tier name.</haxe_doc>
		</name>
		<environment public="1">
			<c path="String"/>
			<haxe_doc>Type of account in respect to operation. One of: test, preview, production.</haxe_doc>
		</environment>
		<scopes public="1">
			<c path="connect.util.Collection"><c path="String"/></c>
			<haxe_doc>Scopes of the tier account in asset tier chain. Possible: tier1, tier2, customer</haxe_doc>
		</scopes>
		<contactInfo public="1">
			<c path="connect.models.ContactInfo"/>
			<haxe_doc>Tier ContactInfo object.</haxe_doc>
		</contactInfo>
		<marketplace public="1">
			<c path="connect.models.Marketplace"/>
			<haxe_doc>Marketplace Object reference</haxe_doc>
		</marketplace>
		<hub public="1">
			<c path="connect.models.Hub"/>
			<haxe_doc>Hub Reference</haxe_doc>
		</hub>
		<externalUid public="1">
			<c path="String"/>
			<haxe_doc>Only in case of filtering by this field.</haxe_doc>
		</externalUid>
		<taxId public="1">
			<c path="String"/>
			<haxe_doc>Used for storing "Tax Registration ID" value of CloudBlue Commerce.</haxe_doc>
		</taxId>
		<getTierConfig public="1" set="method" line="81">
			<f a="productId:tierLevel">
				<c path="String"/>
				<x path="Int"/>
				<c path="connect.models.TierConfig"/>
			</f>
			<haxe_doc>* Gets the TierConfig for `this` TierAccount, based on the product id and
     * tier level specified.
     * @param productId Product id of the TierConfig we want to get.
     * @param tierLevel Tier level of the tier account.
     * @return TierConfig The `TierConfig`, or `null` if none could be found with the given parameters.</haxe_doc>
		</getTierConfig>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Tier Accounts.</haxe_doc>
	</class>
	<class path="connect.models.TierConfig" params="" file="connect/models/TierConfig.hx">
		<extends path="connect.models.IdModel"/>
		<list public="1" set="method" line="81" static="1">
			<f a="filters">
				<c path="connect.api.Query"/>
				<c path="connect.util.Collection"><c path="connect.models.TierConfig"/></c>
			</f>
			<haxe_doc>Lists all TierConfigs that match the given filters. Supported filters are:

        - `id`
        - `account.id`
        - `product.id`
        - `connection.id`
        - `connection.type`
        - `tier_level`
        - `environent`
        - `search` (search based on all fields - generic search option)

        @returns A Collection of TierConfigs.</haxe_doc>
		</list>
		<get public="1" set="method" line="87" static="1">
			<f a="id">
				<c path="String"/>
				<c path="connect.models.TierConfig"/>
			</f>
			<haxe_doc>@returns The TierConfig with the given id, or `null` if it was not found.</haxe_doc>
		</get>
		<name public="1">
			<c path="String"/>
			<haxe_doc>Name of Tier configuration.</haxe_doc>
		</name>
		<account public="1">
			<c path="connect.models.TierAccount"/>
			<haxe_doc>Full tier account representation (same as in `Asset`).</haxe_doc>
		</account>
		<product public="1">
			<c path="connect.models.Product"/>
			<haxe_doc>Reference object to product (application).</haxe_doc>
		</product>
		<tierLevel public="1">
			<x path="Int"/>
			<haxe_doc>Tier level for product from customer perspective.</haxe_doc>
		</tierLevel>
		<params public="1">
			<c path="connect.util.Collection"><c path="connect.models.Param"/></c>
			<haxe_doc>List of TC parameter data objects as in Asset Object extended with unfilled parameters
        from product.</haxe_doc>
		</params>
		<connection public="1">
			<c path="connect.models.Connection"/>
			<haxe_doc>Reference to Connection Object.</haxe_doc>
		</connection>
		<openRequest public="1">
			<c path="connect.models.TierConfigRequest"/>
			<haxe_doc>Reference to TCR.</haxe_doc>
		</openRequest>
		<template public="1">
			<c path="connect.models.Template"/>
			<haxe_doc>Template object.</haxe_doc>
		</template>
		<contract public="1">
			<c path="connect.models.Contract"/>
			<haxe_doc>Contract object reference.</haxe_doc>
		</contract>
		<marketplace public="1">
			<c path="connect.models.Marketplace"/>
			<haxe_doc>Marketplace object reference.</haxe_doc>
		</marketplace>
		<configuration public="1">
			<c path="connect.models.Configuration"/>
			<haxe_doc>List of Product and Marketplace Configuration Phase Parameter Context-Bound Object.</haxe_doc>
		</configuration>
		<events public="1">
			<c path="connect.models.Events"/>
			<haxe_doc>TierConfig events.</haxe_doc>
		</events>
		<tiers public="1">
			<c path="connect.models.Tiers"/>
			<haxe_doc>TierConfig tier accounts.</haxe_doc>
		</tiers>
		<status public="1">
			<c path="String"/>
			<haxe_doc>TierConfig status.</haxe_doc>
		</status>
		<getParamById public="1" set="method" line="97">
			<f a="paramId">
				<c path="String"/>
				<c path="connect.models.Param"/>
			</f>
			<haxe_doc>@returns The `Param` with the given id, or `null` if it was not found.</haxe_doc>
		</getParamById>
		<new public="1" set="method" line="59"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This class represents the configuration of a Tier.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.models.TierConfigRequest" params="" file="connect/models/TierConfigRequest.hx">
		<extends path="connect.models.IdModel"/>
		<list public="1" set="method" line="100" static="1">
			<f a="filters">
				<c path="connect.api.Query"/>
				<c path="connect.util.Collection"><c path="connect.models.TierConfigRequest"/></c>
			</f>
			<haxe_doc>Lists all TierConfigRequests that match the given filters. Supported filters are:

        - `type` (=, in)
        - `status` (=, in)
        - `id` (=, in)
        - `configuration__id` (=, in)
        - `configuration__tier_level` (=, in)
        - `configuration__account__id` (=, in)
        - `configuration__product__id` (=, in)
        - `assignee__id` (=)
        - `unassigned` (bool)
        - `configuration__account__external_uid` (=)

        @returns A Collection of TierConfigRequests.</haxe_doc>
		</list>
		<get public="1" set="method" line="106" static="1">
			<f a="id">
				<c path="String"/>
				<c path="connect.models.TierConfigRequest"/>
			</f>
			<haxe_doc>@returns The TierConfigRequest with the given id, or `null` if it was not found.</haxe_doc>
		</get>
		<isParamInList set="method" line="244" static="1"><f a="param:list">
	<d/>
	<c path="Array"><d/></c>
	<x path="Bool"/>
</f></isParamInList>
		<type public="1">
			<c path="String"/>
			<haxe_doc>TCR type. One of: setup, update.</haxe_doc>
		</type>
		<status public="1">
			<c path="String"/>
			<haxe_doc>TCR current status. One of: tiers_setup, pending, inquiring, approved, failed.</haxe_doc>
		</status>
		<configuration public="1">
			<c path="connect.models.TierConfig"/>
			<haxe_doc>Full representation of TierConfig Object.</haxe_doc>
		</configuration>
		<parentConfiguration public="1">
			<c path="connect.models.TierConfig"/>
			<haxe_doc>Full representation of parent TierConfig.</haxe_doc>
		</parentConfiguration>
		<account public="1">
			<c path="connect.models.TierAccount"/>
			<haxe_doc>Reference object to TierAccount.</haxe_doc>
		</account>
		<product public="1">
			<c path="connect.models.Product"/>
			<haxe_doc>Reference object to product (application).</haxe_doc>
		</product>
		<tierLevel public="1">
			<x path="Null"><x path="Int"/></x>
			<haxe_doc>Tier level for product from customer perspective (1 or 2).</haxe_doc>
		</tierLevel>
		<params public="1">
			<c path="connect.util.Collection"><c path="connect.models.Param"/></c>
			<haxe_doc>List of parameter data objects as in Asset Object.
        Params can be modified only in Pending state.</haxe_doc>
		</params>
		<environment public="1">
			<c path="String"/>
			<haxe_doc>TCR environment (test, prod or preview)</haxe_doc>
		</environment>
		<assignee public="1">
			<c path="connect.models.User"/>
			<haxe_doc>User assigned to this TCR.</haxe_doc>
		</assignee>
		<template public="1">
			<c path="connect.models.Template"/>
			<haxe_doc>Template Object. This is filled only if TCR is approved.</haxe_doc>
		</template>
		<reason public="1">
			<c path="String"/>
			<haxe_doc>Failing reason. This is filled only if TCR is failed.</haxe_doc>
		</reason>
		<activation public="1">
			<c path="connect.models.Activation"/>
			<haxe_doc>Activation object. This is created only if TCR has ordering parameters
        and seen in inquiring state of the TCR.</haxe_doc>
		</activation>
		<notes public="1">
			<c path="String"/>
			<haxe_doc>TCR pending notes. Notes can be modified only in Pending state.</haxe_doc>
		</notes>
		<events public="1">
			<c path="connect.models.Events"/>
			<haxe_doc>Tier Config Tequest events.</haxe_doc>
		</events>
		<tiers public="1">
			<c path="connect.models.Tiers"/>
			<haxe_doc>TierConfig tier accounts.</haxe_doc>
		</tiers>
		<marketplace public="1">
			<c path="connect.models.Marketplace"/>
			<haxe_doc>TierConfig marketplace.</haxe_doc>
		</marketplace>
		<contract public="1">
			<c path="connect.models.Contract"/>
			<haxe_doc>TierConfig contract.</haxe_doc>
		</contract>
		<register public="1" set="method" line="130">
			<f a=""><c path="connect.models.TierConfigRequest"/></f>
			<haxe_doc>Registers a new TierConfigRequest on Connect, based on the data of `this`
        TierConfigRequest, which should have a value at least in the following fields:

        - configuration.product.id
        - configuration.connection.id (not required on preview)
        - configuration.marketplace.id (only available for preview)
        - configuration.account.id
        - configuration.parentAccount.id (optional)
        - configuration.parentAccount.externalUid (optional)
        - configuration.tierLevel
        - configuration.params (id and value of given params)

        @returns The new TierConfigRequest, or `null` if it couldn't be created.</haxe_doc>
		</register>
		<update public="1" set="method" line="155">
			<f a="params">
				<c path="connect.util.Collection"><c path="connect.models.Param"/></c>
				<c path="connect.models.TierConfigRequest"/>
			</f>
			<haxe_doc>Updates the TierConfigRequest in the server with the data changed in `this` model.

        If no parameters are specified for updating, you should reassign your request with the
        object returned by this method, so the next time you call `update` on the object, the SDK
        knows the fields that already got updated in a previous call, like this:

        ```
        request = request.update(null);
        ```

        @param params A collection of parameters to update. If `null` is passed, then the
        parameters that have changed in the request will be sent.
        @returns The TierConfigRequest returned from the server, which should contain
        the same data as `this` TierConfigRequest, or `null` if the updating fails.</haxe_doc>
		</update>
		<getModifiedTcrParams set="method" line="188"><f a=""><x path="Null"><c path="connect.util.Collection"><c path="connect.models.Param"/></c></x></f></getModifiedTcrParams>
		<prepareUpdateBody set="method" line="204"><f a="diff">
	<d/>
	<c path="String"/>
</f></prepareUpdateBody>
		<approveByTemplate public="1" set="method" line="260">
			<f a="id">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Changes `this` TierConfigRequest status to "approved", sending the id of a Template
        to render on the portal.

        When processing requests within a `Flow`, you should use the `Flow.approveByTemplate`
        method instead of this one, since it finishes the flow and logs the information.</haxe_doc>
		</approveByTemplate>
		<fail public="1" set="method" line="275">
			<f a="reason">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Changes the status of `this` TierConfigRequest to "failed".

        When processing requests within a `Flow`, you should use the `Flow.fail`
        method instead of this one, since it finishes the flow and logs the information.</haxe_doc>
		</fail>
		<inquire public="1" set="method" line="290">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Changes the status of `this` TierConfigRequest to "inquiring".

        When processing requests within a `Flow`, you should use the `Flow.inquire`
        method instead of this one, since it finishes the flow and logs the information.</haxe_doc>
		</inquire>
		<pend public="1" set="method" line="305">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Changes the status of `this` TierConfigRequest to "pending".

        When processing requests within a `Flow`, you should use the `Flow.pend`
        method instead of this one, since it finishes the flow and logs the information.</haxe_doc>
		</pend>
		<assign public="1" set="method" line="317">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Assigns this TierConfigRequest.</haxe_doc>
		</assign>
		<unassign public="1" set="method" line="329">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Unassigns this TierConfigRequest.</haxe_doc>
		</unassign>
		<getParamById public="1" set="method" line="339">
			<f a="paramId">
				<c path="String"/>
				<c path="connect.models.Param"/>
			</f>
			<haxe_doc>@returns The `Param` with the given id, or `null` if it was not found.</haxe_doc>
		</getParamById>
		<new public="1" set="method" line="74"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This class represents a request on a `TierConfig`</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.models.Tiers" params="" file="connect/models/Tiers.hx">
		<extends path="connect.models.Model"/>
		<customer public="1">
			<c path="connect.models.TierAccount"/>
			<haxe_doc>Customer Level TierAccount Object.</haxe_doc>
		</customer>
		<tier1 public="1">
			<c path="connect.models.TierAccount"/>
			<haxe_doc>Level 1 TierAccount Object.</haxe_doc>
		</tier1>
		<tier2 public="1">
			<c path="connect.models.TierAccount"/>
			<haxe_doc>Level 2 TierAccount Object.</haxe_doc>
		</tier2>
		<new public="1" set="method" line="24"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Tiers object.</haxe_doc>
	</class>
	<class path="connect.models.UsageCategory" params="" file="connect/models/UsageCategory.hx">
		<extends path="connect.models.IdModel"/>
		<name public="1"><c path="String"/></name>
		<description public="1"><c path="String"/></description>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="connect.models.UsageFile" params="" file="connect/models/UsageFile.hx">
		<extends path="connect.models.IdModel"/>
		<list public="1" set="method" line="119" static="1">
			<f a="filters">
				<c path="connect.api.Query"/>
				<c path="connect.util.Collection"><c path="connect.models.UsageFile"/></c>
			</f>
			<haxe_doc>Lists all UsageFiles that match the given filters. Supported filters are:

        - `product_id`
        - `distribution_contract_id`
        - `status`
        - `created_at`

        @returns A Collection of Requests.</haxe_doc>
		</list>
		<get public="1" set="method" line="125" static="1">
			<f a="id">
				<c path="String"/>
				<c path="connect.models.UsageFile"/>
			</f>
			<haxe_doc>@returns The UsageFile with the given id, or `null` if it was not found.</haxe_doc>
		</get>
		<createSpreadsheet set="method" line="207" static="1"><f a="fileId:records:categories">
	<c path="String"/>
	<c path="Array"><c path="connect.models.UsageRecord"/></c>
	<c path="Array"><c path="connect.models.UsageCategory"/></c>
	<c path="haxe.io.Bytes"/>
</f></createSpreadsheet>
		<getRecordParamNames set="method" line="280" static="1"><f a="records">
	<c path="Array"><c path="connect.models.UsageRecord"/></c>
	<c path="Array"><c path="String"/></c>
</f></getRecordParamNames>
		<getRecordParamValue set="method" line="294" static="1"><f a="record:name">
	<c path="connect.models.UsageRecord"/>
	<c path="String"/>
	<c path="String"/>
</f></getRecordParamValue>
		<name public="1">
			<c path="String"/>
			<haxe_doc>Name of the UsageFile object.</haxe_doc>
		</name>
		<description public="1">
			<c path="String"/>
			<haxe_doc>Vendor can provide a description value in this field to describe the file content.</haxe_doc>
		</description>
		<note public="1">
			<c path="String"/>
			<haxe_doc>Vendor can put a note which can be referred to later for some extra information.</haxe_doc>
		</note>
		<status public="1">
			<c path="String"/>
			<haxe_doc>One of:
    
        - draft
        - uploading
        - uploaded
        - processing
        - invalid
        - ready
        - rejected
        - pending
        - accepted
        - closed</haxe_doc>
		</status>
		<period public="1">
			<c path="connect.models.Period"/>
			<haxe_doc>Period covered by this UsageFile.</haxe_doc>
		</period>
		<currency public="1">
			<c path="String"/>
			<haxe_doc>Currency of the amount included in UsageFile.</haxe_doc>
		</currency>
		<schema public="1">
			<c path="String"/>
			<haxe_doc>Usage scheme used for the usage file. One of: QT, TR, CR, PR.</haxe_doc>
		</schema>
		<usageFileUri public="1">
			<c path="String"/>
			<haxe_doc>Google Storage shared location of the upload file. Only available in GET API and not
        included in list API (sharing timeout 600 sec).</haxe_doc>
		</usageFileUri>
		<processedFileUri public="1">
			<c path="String"/>
			<haxe_doc>Google Storage shared location of the generated file after processing uploaded file.
        Only available in GET API and not included in list API (sharing timeout 30 sec).</haxe_doc>
		</processedFileUri>
		<product public="1">
			<c path="connect.models.Product"/>
			<haxe_doc>Reference to `Product` object.</haxe_doc>
		</product>
		<contract public="1">
			<c path="connect.models.Contract"/>
			<haxe_doc>Reference to `Contract` object.</haxe_doc>
		</contract>
		<marketplace public="1">
			<c path="connect.models.Marketplace"/>
			<haxe_doc>Reference to `Marketplace` object.</haxe_doc>
		</marketplace>
		<vendor public="1">
			<c path="connect.models.Account"/>
			<haxe_doc>Reference to Vendor `Account`.</haxe_doc>
		</vendor>
		<provider public="1">
			<c path="connect.models.Account"/>
			<haxe_doc>Reference to Provider `Account`.</haxe_doc>
		</provider>
		<acceptanceNote public="1">
			<c path="String"/>
			<haxe_doc>Note provided by the provider in case of acceptance of the usage file.</haxe_doc>
		</acceptanceNote>
		<rejectionNote public="1">
			<c path="String"/>
			<haxe_doc>Note provider by the provider in case of rejection of the usage file.</haxe_doc>
		</rejectionNote>
		<errorDetail public="1">
			<c path="String"/>
			<haxe_doc>In case of invalid file, this field will contain errors related to the file.</haxe_doc>
		</errorDetail>
		<stats public="1">
			<c path="connect.models.UsageStats"/>
			<haxe_doc>Reference to `UsageStats` object.</haxe_doc>
		</stats>
		<events public="1">
			<c path="connect.models.Events"/>
			<haxe_doc>Reference to `Events` ocurred on the UsageFile.</haxe_doc>
		</events>
		<externalId public="1">
			<c path="String"/>
			<haxe_doc>External id of the UsageFile.</haxe_doc>
		</externalId>
		<environment public="1">
			<c path="String"/>
			<haxe_doc>Environment of the UsageFile.</haxe_doc>
		</environment>
		<register public="1" set="method" line="144">
			<f a=""><c path="connect.models.UsageFile"/></f>
			<haxe_doc>Registers a new UsageFile on Connect, based on the data of `this` UsageFile, which
        should have a value at least in the following fields:

        - name
        - product.id
        - contract.id

        @returns The new UsageFile.</haxe_doc>
		</register>
		<update public="1" set="method" line="167">
			<f a=""><c path="connect.models.UsageFile"/></f>
			<haxe_doc>Updates `this` UsageFile in the server with the data changed in `this` model.

        You should reassign your file with the object returned by this method, so the next time
        you call `update` on the object, the SDK knows the fields that already got updated in a
        previous call, like this:

        ```
        file = file.update();
        ```

        @returns The UsageFile returned from the server, which should contain
        the same data as `this` UsageFile, or `null` if the updating fails.</haxe_doc>
		</update>
		<delete public="1" set="method" line="185">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Deletes `this` UsageFile in the server.</haxe_doc>
		</delete>
		<uploadRecords public="1" set="method" line="200">
			<f a="records">
				<c path="connect.util.Collection"><c path="connect.models.UsageRecord"/></c>
				<c path="connect.models.UsageFile"/>
			</f>
			<haxe_doc>Uploads the `Collection` of `UsageRecord` objects to `this` UsageFile in Connect.
        The SDK automatically generates a Microsoft Excel XLSX file with the records
        and uploads it, so this is a more convenient version of the `UsageFile.upload()`
        method, which requires you to generate the Excel file contents yourself.</haxe_doc>
		</uploadRecords>
		<uploadRecordsAndCategories public="1" set="method" line="311">
			<f a="records:categories">
				<c path="connect.util.Collection"><c path="connect.models.UsageRecord"/></c>
				<c path="connect.util.Collection"><c path="connect.models.UsageCategory"/></c>
				<c path="connect.models.UsageFile"/>
			</f>
			<haxe_doc>* Uploads the `Collection` of `UsageRecord` objects and `UsageCategory` objects
     * to `this` UsageFile in Connect. The SDK automatically generates a Microsoft Excel
     * XLSX file with the records and uploads it, so this is a more convenient version of
     * the `UsageFile.upload()` method, which requires you to generate the Excel file
     * contents yourself.</haxe_doc>
		</uploadRecordsAndCategories>
		<upload public="1" set="method" line="323">
			<f a="content">
				<c path="connect.util.Blob"/>
				<c path="connect.models.UsageFile"/>
			</f>
			<haxe_doc>Uploads the specified contents to `this` UsageFile in Connect.

        @param content The contents of an XLSX file.
        @returns The UsageFile returned from the server.</haxe_doc>
		</upload>
		<submit public="1" set="method" line="333">
			<f a=""><c path="connect.models.UsageFile"/></f>
			<haxe_doc>Submits `this` UsageFile.

        @returns The UsageFile returned from the server.</haxe_doc>
		</submit>
		<accept public="1" set="method" line="343">
			<f a="note">
				<c path="String"/>
				<c path="connect.models.UsageFile"/>
			</f>
			<haxe_doc>Accepts `this` UsageFile.

        @returns The UsageFile returned from the server.</haxe_doc>
		</accept>
		<reject public="1" set="method" line="353">
			<f a="note">
				<c path="String"/>
				<c path="connect.models.UsageFile"/>
			</f>
			<haxe_doc>Rejects `this` UsageFile.

        @returns The UsageFile returned from the server.</haxe_doc>
		</reject>
		<close public="1" set="method" line="363">
			<f a=""><c path="connect.models.UsageFile"/></f>
			<haxe_doc>Cancels `this` UsageFile.

        @returns The UsageFile returned from the server.</haxe_doc>
		</close>
		<getTemplate public="1" set="method" line="371">
			<f a=""><c path="connect.util.Blob"/></f>
			<haxe_doc>Gets the contents of the product specific file template for `this` UsageFile.</haxe_doc>
		</getTemplate>
		<getTemplateLink public="1" set="method" line="384">
			<f a=""><c path="String"/></f>
			<haxe_doc>Gets the product specific file template URL for `this` UsageFile.</haxe_doc>
		</getTemplateLink>
		<uploadReconciliation public="1" set="method" line="395">
			<f a="content">
				<c path="connect.util.Blob"/>
				<c path="connect.models.UsageFile"/>
			</f>
			<haxe_doc>Uploads the contents of a reconciliation file to `this` UsageFile.

        @param content The contents of an XLSX file.
        @returns The UsageFile returned from the server.</haxe_doc>
		</uploadReconciliation>
		<reprocess public="1" set="method" line="406">
			<f a=""><c path="connect.models.UsageFile"/></f>
			<haxe_doc>Reprocesses a processed file. This is called by the provider after the provider closes
        some usage records manually.

        @returns The UsageFile returned from the server.</haxe_doc>
		</reprocess>
		<new public="1" set="method" line="100"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Usage File Object.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.models.UsageParam" params="" file="connect/models/UsageParam.hx">
		<extends path="connect.models.Model"/>
		<parameterName public="1"><c path="String"/></parameterName>
		<parameterValue public="1"><c path="String"/></parameterValue>
		<new public="1" set="method" line="7"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="connect.models.UsageRecord" params="" file="connect/models/UsageRecord.hx">
		<extends path="connect.models.Model"/>
		<recordId public="1">
			<c path="String"/>
			<haxe_doc>Unique identifier of the usage record.</haxe_doc>
		</recordId>
		<recordNote public="1">
			<c path="String"/>
			<haxe_doc>Optional note.</haxe_doc>
		</recordNote>
		<itemSearchCriteria public="1">
			<c path="String"/>
			<haxe_doc>Macro that will be used to find out respective item in product.</haxe_doc>
		</itemSearchCriteria>
		<itemSearchValue public="1">
			<c path="String"/>
			<haxe_doc>Value that will be used to identify item within product with the help of filter specified on `itemSearchCriteria`.</haxe_doc>
		</itemSearchValue>
		<amount public="1">
			<x path="Null"><x path="Float"/></x>
			<haxe_doc>Usage amount corresponding to a item of an asset. Only needed for CR, PR and TR Schemas.</haxe_doc>
		</amount>
		<quantity public="1">
			<x path="Null"><x path="Float"/></x>
			<haxe_doc>Usage quantity.</haxe_doc>
		</quantity>
		<startTimeUtc public="1">
			<c path="connect.util.DateTime"/>
			<haxe_doc>Start time.</haxe_doc>
		</startTimeUtc>
		<endTimeUtc public="1">
			<c path="connect.util.DateTime"/>
			<haxe_doc>End time.</haxe_doc>
		</endTimeUtc>
		<assetSearchCriteria public="1">
			<c path="String"/>
			<haxe_doc>Macro that will be used to find out respective asset belonging to the product.</haxe_doc>
		</assetSearchCriteria>
		<assetSearchValue public="1">
			<c path="String"/>
			<haxe_doc>Value that will be used to identify Asset belonging to the product with the help of filter specified on `assetSearchCriteria`.</haxe_doc>
		</assetSearchValue>
		<itemName public="1">
			<c path="String"/>
			<haxe_doc>* Item name to which usage record belongs to, only for reporting items that was not part of product definition.
     * Items are reported and created dynamically.</haxe_doc>
		</itemName>
		<itemMpn public="1">
			<c path="String"/>
			<haxe_doc>* Item MPN to which usage record belongs to, only for reporting items that was not part of product definition.
     * Items are reported and created dynamically.</haxe_doc>
		</itemMpn>
		<itemUnit public="1">
			<c path="String"/>
			<haxe_doc>* Only for reporting items that was not part of product definition.
     * Items are reported and created dynamically.</haxe_doc>
		</itemUnit>
		<itemPrecision public="1">
			<c path="String"/>
			<haxe_doc>* Precision of the item for which usage record belong to.
     * Input data should be one of: integer, decimal(1), decimal(2), decimal(4), decimal(8).
     * Only for reporting items that was not part of product definition.
     * Items are reported and created dynamically.</haxe_doc>
		</itemPrecision>
		<categoryId public="1">
			<c path="String"/>
			<haxe_doc>* Category id to link this usage record with a category.</haxe_doc>
		</categoryId>
		<assetReconId public="1">
			<c path="String"/>
			<haxe_doc>* Optional: Asset reconciliation ID provided by vendor.
     * This value comes from a parameter value of the asset that is marked as recon id by vendor.</haxe_doc>
		</assetReconId>
		<tier public="1">
			<x path="Int"/>
			<haxe_doc>Tier level specified for linking usage record with a tier account of Asset in case of TR schema.</haxe_doc>
		</tier>
		<params public="1">
			<c path="connect.util.Collection"><c path="connect.models.UsageParam"/></c>
			<haxe_doc>* Contains the custom fields of the record, such as vendor (prefixed with "v.")
     * and provider (prefixed with "p.") custom data.</haxe_doc>
		</params>
		<new public="1" set="method" line="106"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="connect.models.UsageStats" params="" file="connect/models/UsageStats.hx">
		<extends path="connect.models.Model"/>
		<uploaded public="1"><x path="Int"/></uploaded>
		<validated public="1"><x path="Int"/></validated>
		<pending public="1"><x path="Int"/></pending>
		<accepted public="1"><x path="Int"/></accepted>
		<closed public="1"><x path="Int"/></closed>
		<new public="1" set="method" line="8"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="connect.models.User" params="" file="connect/models/User.hx">
		<extends path="connect.models.IdModel"/>
		<name public="1">
			<c path="String"/>
			<haxe_doc>User name.</haxe_doc>
		</name>
		<email public="1">
			<c path="String"/>
			<haxe_doc>User email.</haxe_doc>
		</email>
		<new public="1" set="method" line="11"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Represents a user within the platform.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="connect.storage.StorageType" params="" file="connect/storage/StepData.hx" module="connect.storage.StepData">
		<ConnectStorage><haxe_doc>StepData saved in Connect.</haxe_doc></ConnectStorage>
		<LocalStorage><haxe_doc>StepData saved in a local file.</haxe_doc></LocalStorage>
		<FailedStorage><haxe_doc>StepData failed to load.</haxe_doc></FailedStorage>
		<haxe_doc>Indicates how a `StepData` is stored.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</enum>
	<class path="connect.storage.StepData" params="" file="connect/storage/StepData.hx">
		<createDictionaryWithClassnameSuffixes set="method" line="58" static="1"><f a="dict">
	<c path="connect.util.Dictionary"/>
	<c path="connect.util.Dictionary"/>
</f></createDictionaryWithClassnameSuffixes>
		<createDictionaryAndDeserializeContent set="method" line="74" static="1"><f a="obj">
	<d/>
	<c path="connect.util.Dictionary"/>
</f></createDictionaryAndDeserializeContent>
		<firstIndex final="1" public="1">
			<x path="Int"/>
			<haxe_doc>Index of the step.</haxe_doc>
		</firstIndex>
		<data final="1" public="1">
			<c path="connect.util.Dictionary"/>
			<haxe_doc>`connect.Flow` data when the step was last executed.</haxe_doc>
		</data>
		<storage final="1" public="1">
			<e path="connect.storage.StorageType"/>
			<haxe_doc>How this step was stored: `ConnectStorage`, `LocalStorage`, `FailedStorage`.</haxe_doc>
		</storage>
		<attempt final="1" public="1">
			<x path="Null"><x path="Int"/></x>
			<haxe_doc>Number of attempts that this step has tried to run.</haxe_doc>
		</attempt>
		<toString public="1" set="method" line="94"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="49">
			<f a="firstIndex:data:storage:attempt">
				<x path="Int"/>
				<d/>
				<e path="connect.storage.StorageType"/>
				<x path="Null"><x path="Int"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>Created a StepData with the passed attributes. The `data` can be of one of these types:

        - `connect.util.Dictionary`: Passed when `this` `StepData` is to be stored.
          The dictionary will be copied recursively, and all keys will contain a suffix with the
          class name of the corresponding value, so it can be used in deserialization.
        - `Dynamic` object: Passed when `this` `StepData` is to be retrieved from file. A new
          dictionary will be created with the contents of the objects, deserializing the values
          based on the type indicated on the key suffixes. These suffixes will be removed.</haxe_doc>
		</new>
		<haxe_doc>The data of a `connect.Flow` step. It can be saved and retrieved later to resume execution of the flow.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="connect.storage.StepStorage" params="" file="connect/storage/StepStorage.hx">
		<load public="1" set="method" line="28" static="1">
			<f a="requestId:param">
				<c path="String"/>
				<c path="connect.models.Param"/>
				<c path="connect.storage.StepData"/>
			</f>
			<haxe_doc>Loads a stored step data for the given request. It will first try to load it from the local
        storage file. If it is not found there, it will try to load it from the indicated `param` which
        must have been retreived from Connect.

        If no data is found on either source, then an empty `StepData` with a `storage` type of
        `FailedStorage` will be returned.</haxe_doc>
		</load>
		<loadRequestFromFile set="method" line="38" static="1"><f a="requestId">
	<c path="String"/>
	<c path="connect.storage.StepData"/>
</f></loadRequestFromFile>
		<loadAllFromFile set="method" line="45" static="1"><f a=""><d/></f></loadAllFromFile>
		<decodeData set="method" line="53" static="1"><f a="data">
	<c path="String"/>
	<d/>
</f></decodeData>
		<getRequestField set="method" line="69" static="1"><f a="object:requestId:storage">
	<d/>
	<c path="String"/>
	<e path="connect.storage.StorageType"/>
	<c path="connect.storage.StepData"/>
</f></getRequestField>
		<loadRequestFromParam set="method" line="80" static="1"><f a="requestId:param">
	<c path="String"/>
	<c path="connect.models.Param"/>
	<c path="connect.storage.StepData"/>
</f></loadRequestFromParam>
		<loadAllFromParam set="method" line="88" static="1"><f a="param">
	<c path="connect.models.Param"/>
	<d/>
</f></loadAllFromParam>
		<save public="1" set="method" line="104" static="1">
			<f a="request:stepData:param:updateFunc">
				<c path="connect.models.IdModel"/>
				<c path="connect.storage.StepData"/>
				<c path="connect.models.Param"/>
				<x path="haxe.Function"/>
				<e path="connect.storage.StorageType"/>
			</f>
			<haxe_doc>Saves `stepData` for the given `request`. First, it will try to save the data in the given
        `param` of the `request`, by calling `updateFunc`, which should try to update the
        parameter in Connect. If this fails, the method will try to save the data in the local
        storage file. The type of storage used for saving will be returned (which will be `FailedStorage`
        if neither worked).</haxe_doc>
		</save>
		<deleteRequestFromFile set="method" line="122" static="1"><f a="requestId">
	<c path="String"/>
	<x path="Void"/>
</f></deleteRequestFromFile>
		<deleteRequestFromObject set="method" line="130" static="1"><f a="obj:requestId">
	<d/>
	<c path="String"/>
	<d/>
</f></deleteRequestFromObject>
		<encodeData set="method" line="138" static="1"><f a="data">
	<d/>
	<c path="String"/>
</f></encodeData>
		<saveInConnect set="method" line="165" static="1">
			<f a="request:data:param:updateFunc">
				<c path="connect.models.IdModel"/>
				<c path="String"/>
				<c path="connect.models.Param"/>
				<x path="haxe.Function"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Saves data for all requests in Connect.
     * @param request An AssetRequest or TierConfigRequest whose update method will be called.
     * @param data Encoded string with all requests for the given asset or TierConfig.
     * @param param Param to be updated.
     * @param updateFunc The update function to be called (TODO: Get this using reflection).
     * @return Bool Whether the data could be saved in Connect or not.</haxe_doc>
		</saveInConnect>
		<saveInFile set="method" line="183" static="1">
			<f a="data">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Saves data for all requests in the local file.
     * @param data Encoded string with all requests for the given asset or TierConfig.
     * @return Bool Whether the data could be saved in the file or not.</haxe_doc>
		</saveInFile>
		<addRequestToObject set="method" line="193" static="1"><f a="obj:requestId:stepData">
	<d/>
	<c path="String"/>
	<c path="connect.storage.StepData"/>
	<d/>
</f></addRequestToObject>
		<removeStepData public="1" set="method" line="212" static="1">
			<f a="requestId:param">
				<c path="String"/>
				<c path="connect.models.Param"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the stored `StepData` for the given request id from the local storage file,
        and if the given `param` contains data for the request, updates its value to remove it.
        @return `true` if the param has been updated, which means that the request that it belongs to
        requires updating, or `false` otherwise.</haxe_doc>
		</removeStepData>
		<getStepFilename public="1" set="method" line="223" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the file name where steps should be stored.</haxe_doc>
		</getStepFilename>
		<haxe_doc>Responsible for storing the data that one step received when executing within a `connect.Flow`.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="connect.util.Blob" params="" file="connect/util/Blob.hx">
		<extends path="connect.Base"/>
		<load public="1" set="method" line="17" static="1">
			<f a="path">
				<c path="String"/>
				<c path="connect.util.Blob"/>
			</f>
			<haxe_doc>Loads the contents of the file at the specified path as a Blob object.</haxe_doc>
		</load>
		<_fromBytes public="1" set="method" line="45" static="1">
			<f a="bytes">
				<c path="haxe.io.Bytes"/>
				<c path="connect.util.Blob"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_fromBytes>
		<_bytesToArray public="1" set="method" line="63" static="1">
			<f a="bytes">
				<c path="haxe.io.Bytes"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_bytesToArray>
		<save public="1" set="method" line="27">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Saves the blob to the specified `path`.</haxe_doc>
		</save>
		<length public="1" set="method" line="33">
			<f a=""><x path="Int"/></f>
			<haxe_doc>@returns The number of bytes contained in the object.</haxe_doc>
		</length>
		<toString public="1" set="method" line="39">
			<f a=""><c path="String"/></f>
			<haxe_doc>@returns A String representation of the data interpreted as UTF-8.</haxe_doc>
		</toString>
		<_getBytes public="1" set="method" line="51">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_getBytes>
		<_toArray public="1" set="method" line="57">
			<f a=""><c path="Array"><x path="Int"/></c></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_toArray>
		<bytes final="1"><c path="haxe.io.Bytes"/></bytes>
		<new set="method" line="71"><f a="bytes">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>This object represents a buffer of binary data. Just as the contents of a text file can be
    represented by a string, the contents of binary files can be represented by a Blob.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.util.Collection" params="T" file="connect/util/Collection.hx">
		<extends path="connect.Base"/>
		<_fromArray public="1" params="T" set="method" line="336" static="1">
			<f a="array">
				<c path="Array"><c path="_fromArray.T"/></c>
				<c path="connect.util.Collection"><c path="_fromArray.T"/></c>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_fromArray>
		<length public="1" set="method" line="28">
			<f a=""><x path="Int"/></f>
			<haxe_doc>The length of `this` Collection.</haxe_doc>
		</length>
		<get public="1" set="method" line="36">
			<f a="index">
				<x path="Int"/>
				<c path="connect.util.Collection.T"/>
			</f>
			<haxe_doc>Returns the element at the specified index.</haxe_doc>
		</get>
		<set public="1" set="method" line="44">
			<f a="index:x">
				<x path="Int"/>
				<c path="connect.util.Collection.T"/>
				<c path="connect.util.Collection"><c path="connect.util.Collection.T"/></c>
			</f>
			<haxe_doc>Sets the value of the element at the specified index.</haxe_doc>
		</set>
		<toArray public="1" set="method" line="58">
			<f a=""><c path="Array"><c path="connect.util.Collection.T"/></c></f>
			<haxe_doc>Returns a Haxe array with the same elements as the collection.

        The array is a shallow copy of the original collection.

        This can be used when using the SDK within Haxe, but it is likely useless
        on other target languages.</haxe_doc>
		</toArray>
		<concat public="1" set="method" line="76">
			<f a="c">
				<c path="connect.util.Collection"><c path="connect.util.Collection.T"/></c>
				<c path="connect.util.Collection"><c path="connect.util.Collection.T"/></c>
			</f>
			<haxe_doc>Returns a new Collection by appending the elements of `c` to the elements of
        `this` Collection.

        This operation does not modify `this` Collection.

        If `c` is an empty collection, a copy of `this` Collection is returned.

        The length of the returned Collection is equal to the sum of `this.length()`
        and `c.length()`.

        If `c` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<copy public="1" set="method" line="88">
			<f a=""><c path="connect.util.Collection"><c path="connect.util.Collection.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Collection.

        The elements are not copied and retain their identity, so
        `c.get(i) == c.copy().get(i)` is true for any valid `i`. However,
        `c == c.copy()` is always false.</haxe_doc>
		</copy>
		<indexOf public="1" set="method" line="104">
			<f a="x:?fromIndex">
				<c path="connect.util.Collection.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurrence of `x` in `this` Collection, searching front to back.

        - If `x` is found by checking standard equality, the function returns its index.
        - If `x` is not found, the function returns -1.
        - If `fromIndex` is specified, it will be used as the starting index to search from,
        otherwise search starts with zero index. If it is negative, it will be taken as the
        offset from the end of `this` Collection to compute the starting index. If given or computed
        starting index is less than 0, the whole collection will be searched, if it is greater than
        or equal to the length of `this` Collection, the function returns -1.</haxe_doc>
		</indexOf>
		<insert public="1" set="method" line="122">
			<f a="pos:x">
				<x path="Int"/>
				<c path="connect.util.Collection.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.
        This operation modifies `this` Collection in place.
        The offset is calculated like so:
        - If `pos` exceeds `this.length()`, the offset is `this.length()`.
        - If `pos` is negative, the offset is calculated from the end of `this`
          Collection, i.e. `this.length() + pos`. If this yields a negative value, the
          offset is 0.
        - Otherwise, the offset is `pos`.
        If the resulting offset does not exceed `this.length()`, all elements from
        and including that offset to the end of `this` Collection are moved one index
        ahead.</haxe_doc>
		</insert>
		<iterator public="1" set="method" line="144">
			<f a=""><t path="Iterator"><c path="connect.util.Collection.T"/></t></f>
			<haxe_doc>Returns an iterator of the Collection values. This can be used with `for` loops when
        using the SDK within Haxe, and in Java it returns a native iterator.</haxe_doc>
		</iterator>
		<join public="1" set="method" line="166">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Collection, with `sep` separating
        each element.

        - If `this` is the empty Collection `[]`, the result is the empty String `""`.
        - If `this` has exactly one element, the result is equal to converting the element to string.
        - If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<lastIndexOf public="1" set="method" line="184">
			<f a="x:?fromIndex">
				<c path="connect.util.Collection.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurrence of `x` in `this` Collection, searching back to
        front.

        - If `x` is found by checking standard equality, the function returns its index.
        - If `x` is not found, the function returns -1.
        - If `fromIndex` is specified, it will be used as the starting index to search from,
        otherwise search starts with the last element index. If it is negative, it will be
        taken as the offset from the end of `this` Collection to compute the starting index. If
        given or computed starting index is greater than or equal to the length of `this`
        Collection, the whole array will be searched, if it is less than 0, the function returns
        -1.</haxe_doc>
		</lastIndexOf>
		<pop public="1" set="method" line="197">
			<f a=""><c path="connect.util.Collection.T"/></f>
			<haxe_doc>Removes the last element of `this` Collection and returns it.

        This operation modifies `this` Collection in place.

        - If `this` has at least one element, `this.length()` will decrease by 1.
        - If `this` is the empty Collection, null is returned and the length remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method" line="212">
			<f a="x">
				<c path="connect.util.Collection.T"/>
				<c path="connect.util.Collection"><c path="connect.util.Collection.T"/></c>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Collection and returns the new
        length of `this` Collection.

        This operation modifies `this` Collection in place.
        
        `this.length()` increases by 1.

        `this` Collection is returned to allows for fluent programming (method chaining).</haxe_doc>
		</push>
		<remove public="1" set="method" line="229">
			<f a="x">
				<c path="connect.util.Collection.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `x` in `this` Collection.

        This operation modifies `this` Collection in place.

        If `x` is found by checking standard equality, it is removed from `this`
        Collection and all following elements are reindexed accordingly. The function
        then returns true.

        If `x` is not found, `this` Collection is not changed and the function returns false.</haxe_doc>
		</remove>
		<reverse public="1" set="method" line="241">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Collection.

        This operation modifies `this` Collection in place.

        If `this.length() < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method" line="256">
			<f a=""><c path="connect.util.Collection.T"/></f>
			<haxe_doc>Removes the first element of `this` Collection and returns it.

        This operation modifies `this` Collection in place.

        If `this` has at least one element, `this.length()` and the index of each
        remaining element is decreased by 1.

        If `this` is the empty Collection, `null` is returned and the length remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method" line="279">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="connect.util.Collection"><c path="connect.util.Collection.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Collection, starting at and
        including `pos`, up to but not including `end`.

        This operation does not modify `this` Collection.

        The elements are not copied and retain their identity.

        If `end` is omitted or exceeds `this.length()`, it defaults to the end of
        `this` Collection.

        If `pos` or `end` are negative, their offsets are calculated from the
        end of `this` Collection by `this.length() + pos` and `this.length() + end`
        respectively. If this yields a negative value, 0 is used instead.

        If `pos` exceeds `this.length()` or if `end` is less than or equals
        `pos`, the result is an empty Collection.</haxe_doc>
		</slice>
		<splice public="1" set="method" line="305">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="connect.util.Collection"><c path="connect.util.Collection.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Collection, starting at and including `pos`,
        and returns them.

        This operation modifies `this` Collection in place.

        If `len` is < 0 or `pos` exceeds `this.length()`, an empty Collection is
        returned and `this` Collection is unchanged.

        If `pos` is negative, its value is calculated from the end    of `this`
        Collection by `this.length() + pos`. If this yields a negative value, 0 is used instead.

        If the sum of the resulting values for `len` and `pos` exceed
        `this.length()`, this operation will affect the elements from `pos` to the
        end of `this` Collection.

        The length of the returned Collection is equal to the new length of `this`
        Collection subtracted from the original length of `this` Collection. In other
        words, each element of the original `this` Collection either remains in
        `this` Collection or becomes an element of the returned Collection.]]></haxe_doc>
		</splice>
		<toString public="1" set="method" line="313">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a JSON string representation of `this` Collection.</haxe_doc>
		</toString>
		<unshift public="1" set="method" line="329">
			<f a="x">
				<c path="connect.util.Collection.T"/>
				<c path="connect.util.Collection"><c path="connect.util.Collection.T"/></c>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Collection.

        This operation modifies `this` Collection in place.

        `this.length()` and the index of each Collection element increases by 1.</haxe_doc>
		</unshift>
		<_array><c path="Array"><c path="connect.util.Collection.T"/></c></_array>
		<new public="1" set="method" line="20">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Collection.</haxe_doc>
		</new>
		<haxe_doc>A Collection is a way to have a standard collection type across all languages supported by the
    SDK.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="connect.util.DateTime" params="" file="connect/util/DateTime.hx">
		<now public="1" set="method" line="41" static="1">
			<f a=""><c path="connect.util.DateTime"/></f>
			<haxe_doc>Creates a date representing the current UTC time.</haxe_doc>
		</now>
		<fromString public="1" set="method" line="54" static="1">
			<f a="s">
				<c path="String"/>
				<c path="connect.util.DateTime"/>
			</f>
			<haxe_doc>Creates a DateTime from the formatted string `s`. The only accepted format is
        `"YYYY-mm-ddTHH:MM:SS+00:00"`.</haxe_doc>
		</fromString>
		<getYear public="1" set="method" line="90">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the year of `this` DateTime (4 digits) in UTC.</haxe_doc>
		</getYear>
		<getMonth public="1" set="method" line="99">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` DateTime (0-11 range) in UTC.
        Note that the month number is zero-based.</haxe_doc>
		</getMonth>
		<getDay public="1" set="method" line="105">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` DateTime (1-31 range) in UTC.</haxe_doc>
		</getDay>
		<getHours public="1" set="method" line="113">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` DateTime (0-23 range) in UTC.</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method" line="121">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` DateTime (0-59 range) in UTC.</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method" line="127">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of `this` DateTime (0-59 range) in UTC.</haxe_doc>
		</getSeconds>
		<getTimestamp public="1" set="method" line="139">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the timestamp in seconds of `this` DateTime. The fractional part contains at least
     * milliseconds accuracy, so you can multiply by 1000 and cast to int if you need an integer
     * timestamp. A timestamp is defined as the number of milliseconds elapsed since
     * 1st January 1970 UTC.
     * @return Float The timestamp in seconds.</haxe_doc>
		</getTimestamp>
		<toString public="1" set="method" line="150">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` DateTime in UTC
        using the standard format `YYYY-mm-ddTHH:MM:SS+00:00`.</haxe_doc>
		</toString>
		<compare public="1" set="method" line="170">
			<f a="other">
				<c path="connect.util.DateTime"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Compares `this` DateTime with the given one, and returns the difference
     * between both dates in seconds. A positive value means the `this` represents
     * a later date, while a negative value means that `this` is an early date.
     * If the function returns 0, it means both objects represent the same date with
     * precision of seconds.
     * @param other The `DateTime` we want to compare `this` to.
     * @return Int</haxe_doc>
		</compare>
		<equals public="1" set="method" line="184">
			<f a="other">
				<c path="connect.util.DateTime"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Indicates if the date in `this` is equal to the one in `other`. It is the same as doing
     * `this.compare(other) == 0`.
     * @param other The `DateTime` we want to compare `this` to.
     * @return Bool</haxe_doc>
		</equals>
		<isBetweenDates public="1" set="method" line="189"><f a="first:last">
	<c path="connect.util.DateTime"/>
	<c path="connect.util.DateTime"/>
	<x path="Bool"/>
</f></isBetweenDates>
		<year final="1"><x path="Int"/></year>
		<month final="1"><x path="Int"/></month>
		<day final="1"><x path="Int"/></day>
		<hours final="1"><x path="Int"/></hours>
		<minutes final="1"><x path="Int"/></minutes>
		<seconds final="1"><x path="Int"/></seconds>
		<new public="1" set="method" line="30">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.
        The behaviour of a DateTime instance is only consistent across platforms if
        the arguments describe a valid date.

         - month: 0 to 11 (note that this is zero-based)
         - day: 1 to 31
         - hour: 0 to 23
         - min: 0 to 59
         - sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The DateTime class provides a basic structure for date and time related
    information. DateTime instances can be created with
    
    - `new DateTime()` for a specific date,
    - `DateTime.now()` to obtain information about the current time, or
    - `DateTime.fromString()` to parse from a string.

    DateTime handles date and time information in UTC.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="connect.util.ExcelRow" params="" file="connect/util/ExcelWriter.hx" module="connect.util.ExcelWriter">
		<c path="Array"><c path="String"/></c>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</typedef>
	<typedef path="connect.util.ExcelSheet" params="" file="connect/util/ExcelWriter.hx" module="connect.util.ExcelWriter">
		<c path="Array"><t path="connect.util.ExcelRow"/></c>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</typedef>
	<class path="connect.util.ExcelWriter" params="" file="connect/util/ExcelWriter.hx">
		<APP final="1" set="null" expr="&quot;&lt;Properties xmlns=\&quot;http://schemas.openxmlformats.org/officeDocument/2006/extended-properties\&quot;&gt;&lt;Application&gt;Microsoft Excel&lt;/Application&gt;&lt;AppVersion&gt;2.5&lt;/AppVersion&gt;&lt;/Properties&gt;&quot;" line="15" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<Properties xmlns=\"http://schemas.openxmlformats.org/officeDocument/2006/extended-properties\"><Application>Microsoft Excel</Application><AppVersion>2.5</AppVersion></Properties>"]]></e></m></meta>
		</APP>
		<CORE final="1" set="null" expr="&quot;&lt;cp:coreProperties xmlns:cp=\&quot;http://schemas.openxmlformats.org/package/2006/metadata/core-properties\&quot; xmlns:dc=\&quot;http://purl.org/dc/elements/1.1/\&quot; xmlns:dcterms=\&quot;http://purl.org/dc/terms/\&quot; xmlns:xsi=\&quot;http://www.w3.org/2001/XMLSchema-instance\&quot;&gt;&lt;dc:creator&gt;connect&lt;/dc:creator&gt;&lt;dcterms:created xsi:type=\&quot;dcterms:W3CDTF\&quot;&gt;%DATE%&lt;/dcterms:created&gt;&lt;dcterms:modified xsi:type=\&quot;dcterms:W3CDTF\&quot;&gt;%DATE%&lt;/dcterms:modified&gt;&lt;/cp:coreProperties&gt;&quot;" line="16" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<cp:coreProperties xmlns:cp=\"http://schemas.openxmlformats.org/package/2006/metadata/core-properties\" xmlns:dc=\"http://purl.org/dc/elements/1.1/\" xmlns:dcterms=\"http://purl.org/dc/terms/\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"><dc:creator>connect</dc:creator><dcterms:created xsi:type=\"dcterms:W3CDTF\">%DATE%</dcterms:created><dcterms:modified xsi:type=\"dcterms:W3CDTF\">%DATE%</dcterms:modified></cp:coreProperties>"]]></e></m></meta>
		</CORE>
		<RELS1 final="1" set="null" expr="&quot;&lt;Relationships xmlns=\&quot;http://schemas.openxmlformats.org/package/2006/relationships\&quot;&gt;&lt;Relationship Id=\&quot;rId1\&quot; Target=\&quot;xl/workbook.xml\&quot; Type=\&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument\&quot; /&gt;&lt;Relationship Id=\&quot;rId2\&quot; Target=\&quot;docProps/core.xml\&quot; Type=\&quot;http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties\&quot; /&gt;&lt;Relationship Id=\&quot;rId3\&quot; Target=\&quot;docProps/app.xml\&quot; Type=\&quot;http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties\&quot; /&gt;&lt;/Relationships&gt;&quot;" line="17" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\"><Relationship Id=\"rId1\" Target=\"xl/workbook.xml\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument\" /><Relationship Id=\"rId2\" Target=\"docProps/core.xml\" Type=\"http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties\" /><Relationship Id=\"rId3\" Target=\"docProps/app.xml\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties\" /></Relationships>"]]></e></m></meta>
		</RELS1>
		<THEME final="1" set="null" expr="&quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;&lt;a:theme xmlns:a=\&quot;http://schemas.openxmlformats.org/drawingml/2006/main\&quot; name=\&quot;Office Theme\&quot;&gt;&lt;a:themeElements&gt;&lt;a:clrScheme name=\&quot;Office\&quot;&gt;&lt;a:dk1&gt;&lt;a:sysClr val=\&quot;windowText\&quot; lastClr=\&quot;000000\&quot;/&gt;&lt;/a:dk1&gt;&lt;a:lt1&gt;&lt;a:sysClr val=\&quot;window\&quot; lastClr=\&quot;FFFFFF\&quot;/&gt;&lt;/a:lt1&gt;&lt;a:dk2&gt;&lt;a:srgbClr val=\&quot;1F497D\&quot;/&gt;&lt;/a:dk2&gt;&lt;a:lt2&gt;&lt;a:srgbClr val=\&quot;EEECE1\&quot;/&gt;&lt;/a:lt2&gt;&lt;a:accent1&gt;&lt;a:srgbClr val=\&quot;4F81BD\&quot;/&gt;&lt;/a:accent1&gt;&lt;a:accent2&gt;&lt;a:srgbClr val=\&quot;C0504D\&quot;/&gt;&lt;/a:accent2&gt;&lt;a:accent3&gt;&lt;a:srgbClr val=\&quot;9BBB59\&quot;/&gt;&lt;/a:accent3&gt;&lt;a:accent4&gt;&lt;a:srgbClr val=\&quot;8064A2\&quot;/&gt;&lt;/a:accent4&gt;&lt;a:accent5&gt;&lt;a:srgbClr val=\&quot;4BACC6\&quot;/&gt;&lt;/a:accent5&gt;&lt;a:accent6&gt;&lt;a:srgbClr val=\&quot;F79646\&quot;/&gt;&lt;/a:accent6&gt;&lt;a:hlink&gt;&lt;a:srgbClr val=\&quot;0000FF\&quot;/&gt;&lt;/a:hlink&gt;&lt;a:folHlink&gt;&lt;a:srgbClr val=\&quot;800080\&quot;/&gt;&lt;/a:folHlink&gt;&lt;/a:clrScheme&gt;&lt;a:fontScheme name=\&quot;Office\&quot;&gt;&lt;a:majorFont&gt;&lt;a:latin typeface=\&quot;Cambria\&quot;/&gt;&lt;a:ea typeface=\&quot;\&quot;/&gt;&lt;a:cs typeface=\&quot;\&quot;/&gt;&lt;a:font script=\&quot;Jpan\&quot; typeface=\&quot;&#xFF2D;&#xFF33; &#xFF30;&#x30B4;&#x30B7;&#x30C3;&#x30AF;\&quot;/&gt;&lt;a:font script=\&quot;Hang\&quot; typeface=\&quot;&#xB9D1;&#xC740; &#xACE0;&#xB515;\&quot;/&gt;&lt;a:font script=\&quot;Hans\&quot; typeface=\&quot;&#x5B8B;&#x4F53;\&quot;/&gt;&lt;a:font script=\&quot;Hant\&quot; typeface=\&quot;&#x65B0;&#x7D30;&#x660E;&#x9AD4;\&quot;/&gt;&lt;a:font script=\&quot;Arab\&quot; typeface=\&quot;Times New Roman\&quot;/&gt;&lt;a:font script=\&quot;Hebr\&quot; typeface=\&quot;Times New Roman\&quot;/&gt;&lt;a:font script=\&quot;Thai\&quot; typeface=\&quot;Tahoma\&quot;/&gt;&lt;a:font script=\&quot;Ethi\&quot; typeface=\&quot;Nyala\&quot;/&gt;&lt;a:font script=\&quot;Beng\&quot; typeface=\&quot;Vrinda\&quot;/&gt;&lt;a:font script=\&quot;Gujr\&quot; typeface=\&quot;Shruti\&quot;/&gt;&lt;a:font script=\&quot;Khmr\&quot; typeface=\&quot;MoolBoran\&quot;/&gt;&lt;a:font script=\&quot;Knda\&quot; typeface=\&quot;Tunga\&quot;/&gt;&lt;a:font script=\&quot;Guru\&quot; typeface=\&quot;Raavi\&quot;/&gt;&lt;a:font script=\&quot;Cans\&quot; typeface=\&quot;Euphemia\&quot;/&gt;&lt;a:font script=\&quot;Cher\&quot; typeface=\&quot;Plantagenet Cherokee\&quot;/&gt;&lt;a:font script=\&quot;Yiii\&quot; typeface=\&quot;Microsoft Yi Baiti\&quot;/&gt;&lt;a:font script=\&quot;Tibt\&quot; typeface=\&quot;Microsoft Himalaya\&quot;/&gt;&lt;a:font script=\&quot;Thaa\&quot; typeface=\&quot;MV Boli\&quot;/&gt;&lt;a:font script=\&quot;Deva\&quot; typeface=\&quot;Mangal\&quot;/&gt;&lt;a:font script=\&quot;Telu\&quot; typeface=\&quot;Gautami\&quot;/&gt;&lt;a:font script=\&quot;Taml\&quot; typeface=\&quot;Latha\&quot;/&gt;&lt;a:font script=\&quot;Syrc\&quot; typeface=\&quot;Estrangelo Edessa\&quot;/&gt;&lt;a:font script=\&quot;Orya\&quot; typeface=\&quot;Kalinga\&quot;/&gt;&lt;a:font script=\&quot;Mlym\&quot; typeface=\&quot;Kartika\&quot;/&gt;&lt;a:font script=\&quot;Laoo\&quot; typeface=\&quot;DokChampa\&quot;/&gt;&lt;a:font script=\&quot;Sinh\&quot; typeface=\&quot;Iskoola Pota\&quot;/&gt;&lt;a:font script=\&quot;Mong\&quot; typeface=\&quot;Mongolian Baiti\&quot;/&gt;&lt;a:font script=\&quot;Viet\&quot; typeface=\&quot;Times New Roman\&quot;/&gt;&lt;a:font script=\&quot;Uigh\&quot; typeface=\&quot;Microsoft Uighur\&quot;/&gt;&lt;/a:majorFont&gt;&lt;a:minorFont&gt;&lt;a:latin typeface=\&quot;Calibri\&quot;/&gt;&lt;a:ea typeface=\&quot;\&quot;/&gt;&lt;a:cs typeface=\&quot;\&quot;/&gt;&lt;a:font script=\&quot;Jpan\&quot; typeface=\&quot;&#xFF2D;&#xFF33; &#xFF30;&#x30B4;&#x30B7;&#x30C3;&#x30AF;\&quot;/&gt;&lt;a:font script=\&quot;Hang\&quot; typeface=\&quot;&#xB9D1;&#xC740; &#xACE0;&#xB515;\&quot;/&gt;&lt;a:font script=\&quot;Hans\&quot; typeface=\&quot;&#x5B8B;&#x4F53;\&quot;/&gt;&lt;a:font script=\&quot;Hant\&quot; typeface=\&quot;&#x65B0;&#x7D30;&#x660E;&#x9AD4;\&quot;/&gt;&lt;a:font script=\&quot;Arab\&quot; typeface=\&quot;Arial\&quot;/&gt;&lt;a:font script=\&quot;Hebr\&quot; typeface=\&quot;Arial\&quot;/&gt;&lt;a:font script=\&quot;Thai\&quot; typeface=\&quot;Tahoma\&quot;/&gt;&lt;a:font script=\&quot;Ethi\&quot; typeface=\&quot;Nyala\&quot;/&gt;&lt;a:font script=\&quot;Beng\&quot; typeface=\&quot;Vrinda\&quot;/&gt;&lt;a:font script=\&quot;Gujr\&quot; typeface=\&quot;Shruti\&quot;/&gt;&lt;a:font script=\&quot;Khmr\&quot; typeface=\&quot;DaunPenh\&quot;/&gt;&lt;a:font script=\&quot;Knda\&quot; typeface=\&quot;Tunga\&quot;/&gt;&lt;a:font script=\&quot;Guru\&quot; typeface=\&quot;Raavi\&quot;/&gt;&lt;a:font script=\&quot;Cans\&quot; typeface=\&quot;Euphemia\&quot;/&gt;&lt;a:font script=\&quot;Cher\&quot; typeface=\&quot;Plantagenet Cherokee\&quot;/&gt;&lt;a:font script=\&quot;Yiii\&quot; typeface=\&quot;Microsoft Yi Baiti\&quot;/&gt;&lt;a:font script=\&quot;Tibt\&quot; typeface=\&quot;Microsoft Himalaya\&quot;/&gt;&lt;a:font script=\&quot;Thaa\&quot; typeface=\&quot;MV Boli\&quot;/&gt;&lt;a:font script=\&quot;Deva\&quot; typeface=\&quot;Mangal\&quot;/&gt;&lt;a:font script=\&quot;Telu\&quot; typeface=\&quot;Gautami\&quot;/&gt;&lt;a:font script=\&quot;Taml\&quot; typeface=\&quot;Latha\&quot;/&gt;&lt;a:font script=\&quot;Syrc\&quot; typeface=\&quot;Estrangelo Edessa\&quot;/&gt;&lt;a:font script=\&quot;Orya\&quot; typeface=\&quot;Kalinga\&quot;/&gt;&lt;a:font script=\&quot;Mlym\&quot; typeface=\&quot;Kartika\&quot;/&gt;&lt;a:font script=\&quot;Laoo\&quot; typeface=\&quot;DokChampa\&quot;/&gt;&lt;a:font script=\&quot;Sinh\&quot; typeface=\&quot;Iskoola Pota\&quot;/&gt;&lt;a:font script=\&quot;Mong\&quot; typeface=\&quot;Mongolian Baiti\&quot;/&gt;&lt;a:font script=\&quot;Viet\&quot; typeface=\&quot;Arial\&quot;/&gt;&lt;a:font script=\&quot;Uigh\&quot; typeface=\&quot;Microsoft Uighur\&quot;/&gt;&lt;/a:minorFont&gt;&lt;/a:fontScheme&gt;&lt;a:fmtScheme name=\&quot;Office\&quot;&gt;&lt;a:fillStyleLst&gt;&lt;a:solidFill&gt;&lt;a:schemeClr val=\&quot;phClr\&quot;/&gt;&lt;/a:solidFill&gt;&lt;a:gradFill rotWithShape=\&quot;1\&quot;&gt;&lt;a:gsLst&gt;&lt;a:gs pos=\&quot;0\&quot;&gt;&lt;a:schemeClr val=\&quot;phClr\&quot;&gt;&lt;a:tint val=\&quot;50000\&quot;/&gt;&lt;a:satMod val=\&quot;300000\&quot;/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;&lt;a:gs pos=\&quot;35000\&quot;&gt;&lt;a:schemeClr val=\&quot;phClr\&quot;&gt;&lt;a:tint val=\&quot;37000\&quot;/&gt;&lt;a:satMod val=\&quot;300000\&quot;/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;&lt;a:gs pos=\&quot;100000\&quot;&gt;&lt;a:schemeClr val=\&quot;phClr\&quot;&gt;&lt;a:tint val=\&quot;15000\&quot;/&gt;&lt;a:satMod val=\&quot;350000\&quot;/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;&lt;/a:gsLst&gt;&lt;a:lin ang=\&quot;16200000\&quot; scaled=\&quot;1\&quot;/&gt;&lt;/a:gradFill&gt;&lt;a:gradFill rotWithShape=\&quot;1\&quot;&gt;&lt;a:gsLst&gt;&lt;a:gs pos=\&quot;0\&quot;&gt;&lt;a:schemeClr val=\&quot;phClr\&quot;&gt;&lt;a:shade val=\&quot;51000\&quot;/&gt;&lt;a:satMod val=\&quot;130000\&quot;/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;&lt;a:gs pos=\&quot;80000\&quot;&gt;&lt;a:schemeClr val=\&quot;phClr\&quot;&gt;&lt;a:shade val=\&quot;93000\&quot;/&gt;&lt;a:satMod val=\&quot;130000\&quot;/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;&lt;a:gs pos=\&quot;100000\&quot;&gt;&lt;a:schemeClr val=\&quot;phClr\&quot;&gt;&lt;a:shade val=\&quot;94000\&quot;/&gt;&lt;a:satMod val=\&quot;135000\&quot;/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;&lt;/a:gsLst&gt;&lt;a:lin ang=\&quot;16200000\&quot; scaled=\&quot;0\&quot;/&gt;&lt;/a:gradFill&gt;&lt;/a:fillStyleLst&gt;&lt;a:lnStyleLst&gt;&lt;a:ln w=\&quot;9525\&quot; cap=\&quot;flat\&quot; cmpd=\&quot;sng\&quot; algn=\&quot;ctr\&quot;&gt;&lt;a:solidFill&gt;&lt;a:schemeClr val=\&quot;phClr\&quot;&gt;&lt;a:shade val=\&quot;95000\&quot;/&gt;&lt;a:satMod val=\&quot;105000\&quot;/&gt;&lt;/a:schemeClr&gt;&lt;/a:solidFill&gt;&lt;a:prstDash val=\&quot;solid\&quot;/&gt;&lt;/a:ln&gt;&lt;a:ln w=\&quot;25400\&quot; cap=\&quot;flat\&quot; cmpd=\&quot;sng\&quot; algn=\&quot;ctr\&quot;&gt;&lt;a:solidFill&gt;&lt;a:schemeClr val=\&quot;phClr\&quot;/&gt;&lt;/a:solidFill&gt;&lt;a:prstDash val=\&quot;solid\&quot;/&gt;&lt;/a:ln&gt;&lt;a:ln w=\&quot;38100\&quot; cap=\&quot;flat\&quot; cmpd=\&quot;sng\&quot; algn=\&quot;ctr\&quot;&gt;&lt;a:solidFill&gt;&lt;a:schemeClr val=\&quot;phClr\&quot;/&gt;&lt;/a:solidFill&gt;&lt;a:prstDash val=\&quot;solid\&quot;/&gt;&lt;/a:ln&gt;&lt;/a:lnStyleLst&gt;&lt;a:effectStyleLst&gt;&lt;a:effectStyle&gt;&lt;a:effectLst&gt;&lt;a:outerShdw blurRad=\&quot;40000\&quot; dist=\&quot;20000\&quot; dir=\&quot;5400000\&quot; rotWithShape=\&quot;0\&quot;&gt;&lt;a:srgbClr val=\&quot;000000\&quot;&gt;&lt;a:alpha val=\&quot;38000\&quot;/&gt;&lt;/a:srgbClr&gt;&lt;/a:outerShdw&gt;&lt;/a:effectLst&gt;&lt;/a:effectStyle&gt;&lt;a:effectStyle&gt;&lt;a:effectLst&gt;&lt;a:outerShdw blurRad=\&quot;40000\&quot; dist=\&quot;23000\&quot; dir=\&quot;5400000\&quot; rotWithShape=\&quot;0\&quot;&gt;&lt;a:srgbClr val=\&quot;000000\&quot;&gt;&lt;a:alpha val=\&quot;35000\&quot;/&gt;&lt;/a:srgbClr&gt;&lt;/a:outerShdw&gt;&lt;/a:effectLst&gt;&lt;/a:effectStyle&gt;&lt;a:effectStyle&gt;&lt;a:effectLst&gt;&lt;a:outerShdw blurRad=\&quot;40000\&quot; dist=\&quot;23000\&quot; dir=\&quot;5400000\&quot; rotWithShape=\&quot;0\&quot;&gt;&lt;a:srgbClr val=\&quot;000000\&quot;&gt;&lt;a:alpha val=\&quot;35000\&quot;/&gt;&lt;/a:srgbClr&gt;&lt;/a:outerShdw&gt;&lt;/a:effectLst&gt;&lt;a:scene3d&gt;&lt;a:camera prst=\&quot;orthographicFront\&quot;&gt;&lt;a:rot lat=\&quot;0\&quot; lon=\&quot;0\&quot; rev=\&quot;0\&quot;/&gt;&lt;/a:camera&gt;&lt;a:lightRig rig=\&quot;threePt\&quot; dir=\&quot;t\&quot;&gt;&lt;a:rot lat=\&quot;0\&quot; lon=\&quot;0\&quot; rev=\&quot;1200000\&quot;/&gt;&lt;/a:lightRig&gt;&lt;/a:scene3d&gt;&lt;a:sp3d&gt;&lt;a:bevelT w=\&quot;63500\&quot; h=\&quot;25400\&quot;/&gt;&lt;/a:sp3d&gt;&lt;/a:effectStyle&gt;&lt;/a:effectStyleLst&gt;&lt;a:bgFillStyleLst&gt;&lt;a:solidFill&gt;&lt;a:schemeClr val=\&quot;phClr\&quot;/&gt;&lt;/a:solidFill&gt;&lt;a:gradFill rotWithShape=\&quot;1\&quot;&gt;&lt;a:gsLst&gt;&lt;a:gs pos=\&quot;0\&quot;&gt;&lt;a:schemeClr val=\&quot;phClr\&quot;&gt;&lt;a:tint val=\&quot;40000\&quot;/&gt;&lt;a:satMod val=\&quot;350000\&quot;/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;&lt;a:gs pos=\&quot;40000\&quot;&gt;&lt;a:schemeClr val=\&quot;phClr\&quot;&gt;&lt;a:tint val=\&quot;45000\&quot;/&gt;&lt;a:shade val=\&quot;99000\&quot;/&gt;&lt;a:satMod val=\&quot;350000\&quot;/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;&lt;a:gs pos=\&quot;100000\&quot;&gt;&lt;a:schemeClr val=\&quot;phClr\&quot;&gt;&lt;a:shade val=\&quot;20000\&quot;/&gt;&lt;a:satMod val=\&quot;255000\&quot;/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;&lt;/a:gsLst&gt;&lt;a:path path=\&quot;circle\&quot;&gt;&lt;a:fillToRect l=\&quot;50000\&quot; t=\&quot;-80000\&quot; r=\&quot;50000\&quot; b=\&quot;180000\&quot;/&gt;&lt;/a:path&gt;&lt;/a:gradFill&gt;&lt;a:gradFill rotWithShape=\&quot;1\&quot;&gt;&lt;a:gsLst&gt;&lt;a:gs pos=\&quot;0\&quot;&gt;&lt;a:schemeClr val=\&quot;phClr\&quot;&gt;&lt;a:tint val=\&quot;80000\&quot;/&gt;&lt;a:satMod val=\&quot;300000\&quot;/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;&lt;a:gs pos=\&quot;100000\&quot;&gt;&lt;a:schemeClr val=\&quot;phClr\&quot;&gt;&lt;a:shade val=\&quot;30000\&quot;/&gt;&lt;a:satMod val=\&quot;200000\&quot;/&gt;&lt;/a:schemeClr&gt;&lt;/a:gs&gt;&lt;/a:gsLst&gt;&lt;a:path path=\&quot;circle\&quot;&gt;&lt;a:fillToRect l=\&quot;50000\&quot; t=\&quot;50000\&quot; r=\&quot;50000\&quot; b=\&quot;50000\&quot;/&gt;&lt;/a:path&gt;&lt;/a:gradFill&gt;&lt;/a:bgFillStyleLst&gt;&lt;/a:fmtScheme&gt;&lt;/a:themeElements&gt;&lt;a:objectDefaults/&gt;&lt;a:extraClrSchemeLst/&gt;&lt;/a:theme&gt;&quot;" line="18" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<?xml version=\"1.0\"?><a:theme xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" name=\"Office Theme\"><a:themeElements><a:clrScheme name=\"Office\"><a:dk1><a:sysClr val=\"windowText\" lastClr=\"000000\"/></a:dk1><a:lt1><a:sysClr val=\"window\" lastClr=\"FFFFFF\"/></a:lt1><a:dk2><a:srgbClr val=\"1F497D\"/></a:dk2><a:lt2><a:srgbClr val=\"EEECE1\"/></a:lt2><a:accent1><a:srgbClr val=\"4F81BD\"/></a:accent1><a:accent2><a:srgbClr val=\"C0504D\"/></a:accent2><a:accent3><a:srgbClr val=\"9BBB59\"/></a:accent3><a:accent4><a:srgbClr val=\"8064A2\"/></a:accent4><a:accent5><a:srgbClr val=\"4BACC6\"/></a:accent5><a:accent6><a:srgbClr val=\"F79646\"/></a:accent6><a:hlink><a:srgbClr val=\"0000FF\"/></a:hlink><a:folHlink><a:srgbClr val=\"800080\"/></a:folHlink></a:clrScheme><a:fontScheme name=\"Office\"><a:majorFont><a:latin typeface=\"Cambria\"/><a:ea typeface=\"\"/><a:cs typeface=\"\"/><a:font script=\"Jpan\" typeface=\"&#xFF2D;&#xFF33; &#xFF30;&#x30B4;&#x30B7;&#x30C3;&#x30AF;\"/><a:font script=\"Hang\" typeface=\"&#xB9D1;&#xC740; &#xACE0;&#xB515;\"/><a:font script=\"Hans\" typeface=\"&#x5B8B;&#x4F53;\"/><a:font script=\"Hant\" typeface=\"&#x65B0;&#x7D30;&#x660E;&#x9AD4;\"/><a:font script=\"Arab\" typeface=\"Times New Roman\"/><a:font script=\"Hebr\" typeface=\"Times New Roman\"/><a:font script=\"Thai\" typeface=\"Tahoma\"/><a:font script=\"Ethi\" typeface=\"Nyala\"/><a:font script=\"Beng\" typeface=\"Vrinda\"/><a:font script=\"Gujr\" typeface=\"Shruti\"/><a:font script=\"Khmr\" typeface=\"MoolBoran\"/><a:font script=\"Knda\" typeface=\"Tunga\"/><a:font script=\"Guru\" typeface=\"Raavi\"/><a:font script=\"Cans\" typeface=\"Euphemia\"/><a:font script=\"Cher\" typeface=\"Plantagenet Cherokee\"/><a:font script=\"Yiii\" typeface=\"Microsoft Yi Baiti\"/><a:font script=\"Tibt\" typeface=\"Microsoft Himalaya\"/><a:font script=\"Thaa\" typeface=\"MV Boli\"/><a:font script=\"Deva\" typeface=\"Mangal\"/><a:font script=\"Telu\" typeface=\"Gautami\"/><a:font script=\"Taml\" typeface=\"Latha\"/><a:font script=\"Syrc\" typeface=\"Estrangelo Edessa\"/><a:font script=\"Orya\" typeface=\"Kalinga\"/><a:font script=\"Mlym\" typeface=\"Kartika\"/><a:font script=\"Laoo\" typeface=\"DokChampa\"/><a:font script=\"Sinh\" typeface=\"Iskoola Pota\"/><a:font script=\"Mong\" typeface=\"Mongolian Baiti\"/><a:font script=\"Viet\" typeface=\"Times New Roman\"/><a:font script=\"Uigh\" typeface=\"Microsoft Uighur\"/></a:majorFont><a:minorFont><a:latin typeface=\"Calibri\"/><a:ea typeface=\"\"/><a:cs typeface=\"\"/><a:font script=\"Jpan\" typeface=\"&#xFF2D;&#xFF33; &#xFF30;&#x30B4;&#x30B7;&#x30C3;&#x30AF;\"/><a:font script=\"Hang\" typeface=\"&#xB9D1;&#xC740; &#xACE0;&#xB515;\"/><a:font script=\"Hans\" typeface=\"&#x5B8B;&#x4F53;\"/><a:font script=\"Hant\" typeface=\"&#x65B0;&#x7D30;&#x660E;&#x9AD4;\"/><a:font script=\"Arab\" typeface=\"Arial\"/><a:font script=\"Hebr\" typeface=\"Arial\"/><a:font script=\"Thai\" typeface=\"Tahoma\"/><a:font script=\"Ethi\" typeface=\"Nyala\"/><a:font script=\"Beng\" typeface=\"Vrinda\"/><a:font script=\"Gujr\" typeface=\"Shruti\"/><a:font script=\"Khmr\" typeface=\"DaunPenh\"/><a:font script=\"Knda\" typeface=\"Tunga\"/><a:font script=\"Guru\" typeface=\"Raavi\"/><a:font script=\"Cans\" typeface=\"Euphemia\"/><a:font script=\"Cher\" typeface=\"Plantagenet Cherokee\"/><a:font script=\"Yiii\" typeface=\"Microsoft Yi Baiti\"/><a:font script=\"Tibt\" typeface=\"Microsoft Himalaya\"/><a:font script=\"Thaa\" typeface=\"MV Boli\"/><a:font script=\"Deva\" typeface=\"Mangal\"/><a:font script=\"Telu\" typeface=\"Gautami\"/><a:font script=\"Taml\" typeface=\"Latha\"/><a:font script=\"Syrc\" typeface=\"Estrangelo Edessa\"/><a:font script=\"Orya\" typeface=\"Kalinga\"/><a:font script=\"Mlym\" typeface=\"Kartika\"/><a:font script=\"Laoo\" typeface=\"DokChampa\"/><a:font script=\"Sinh\" typeface=\"Iskoola Pota\"/><a:font script=\"Mong\" typeface=\"Mongolian Baiti\"/><a:font script=\"Viet\" typeface=\"Arial\"/><a:font script=\"Uigh\" typeface=\"Microsoft Uighur\"/></a:minorFont></a:fontScheme><a:fmtScheme name=\"Office\"><a:fillStyleLst><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:gradFill rotWithShape=\"1\"><a:gsLst><a:gs pos=\"0\"><a:schemeClr val=\"phClr\"><a:tint val=\"50000\"/><a:satMod val=\"300000\"/></a:schemeClr></a:gs><a:gs pos=\"35000\"><a:schemeClr val=\"phClr\"><a:tint val=\"37000\"/><a:satMod val=\"300000\"/></a:schemeClr></a:gs><a:gs pos=\"100000\"><a:schemeClr val=\"phClr\"><a:tint val=\"15000\"/><a:satMod val=\"350000\"/></a:schemeClr></a:gs></a:gsLst><a:lin ang=\"16200000\" scaled=\"1\"/></a:gradFill><a:gradFill rotWithShape=\"1\"><a:gsLst><a:gs pos=\"0\"><a:schemeClr val=\"phClr\"><a:shade val=\"51000\"/><a:satMod val=\"130000\"/></a:schemeClr></a:gs><a:gs pos=\"80000\"><a:schemeClr val=\"phClr\"><a:shade val=\"93000\"/><a:satMod val=\"130000\"/></a:schemeClr></a:gs><a:gs pos=\"100000\"><a:schemeClr val=\"phClr\"><a:shade val=\"94000\"/><a:satMod val=\"135000\"/></a:schemeClr></a:gs></a:gsLst><a:lin ang=\"16200000\" scaled=\"0\"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w=\"9525\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"><a:solidFill><a:schemeClr val=\"phClr\"><a:shade val=\"95000\"/><a:satMod val=\"105000\"/></a:schemeClr></a:solidFill><a:prstDash val=\"solid\"/></a:ln><a:ln w=\"25400\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:prstDash val=\"solid\"/></a:ln><a:ln w=\"38100\" cap=\"flat\" cmpd=\"sng\" algn=\"ctr\"><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:prstDash val=\"solid\"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst><a:outerShdw blurRad=\"40000\" dist=\"20000\" dir=\"5400000\" rotWithShape=\"0\"><a:srgbClr val=\"000000\"><a:alpha val=\"38000\"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad=\"40000\" dist=\"23000\" dir=\"5400000\" rotWithShape=\"0\"><a:srgbClr val=\"000000\"><a:alpha val=\"35000\"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad=\"40000\" dist=\"23000\" dir=\"5400000\" rotWithShape=\"0\"><a:srgbClr val=\"000000\"><a:alpha val=\"35000\"/></a:srgbClr></a:outerShdw></a:effectLst><a:scene3d><a:camera prst=\"orthographicFront\"><a:rot lat=\"0\" lon=\"0\" rev=\"0\"/></a:camera><a:lightRig rig=\"threePt\" dir=\"t\"><a:rot lat=\"0\" lon=\"0\" rev=\"1200000\"/></a:lightRig></a:scene3d><a:sp3d><a:bevelT w=\"63500\" h=\"25400\"/></a:sp3d></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val=\"phClr\"/></a:solidFill><a:gradFill rotWithShape=\"1\"><a:gsLst><a:gs pos=\"0\"><a:schemeClr val=\"phClr\"><a:tint val=\"40000\"/><a:satMod val=\"350000\"/></a:schemeClr></a:gs><a:gs pos=\"40000\"><a:schemeClr val=\"phClr\"><a:tint val=\"45000\"/><a:shade val=\"99000\"/><a:satMod val=\"350000\"/></a:schemeClr></a:gs><a:gs pos=\"100000\"><a:schemeClr val=\"phClr\"><a:shade val=\"20000\"/><a:satMod val=\"255000\"/></a:schemeClr></a:gs></a:gsLst><a:path path=\"circle\"><a:fillToRect l=\"50000\" t=\"-80000\" r=\"50000\" b=\"180000\"/></a:path></a:gradFill><a:gradFill rotWithShape=\"1\"><a:gsLst><a:gs pos=\"0\"><a:schemeClr val=\"phClr\"><a:tint val=\"80000\"/><a:satMod val=\"300000\"/></a:schemeClr></a:gs><a:gs pos=\"100000\"><a:schemeClr val=\"phClr\"><a:shade val=\"30000\"/><a:satMod val=\"200000\"/></a:schemeClr></a:gs></a:gsLst><a:path path=\"circle\"><a:fillToRect l=\"50000\" t=\"50000\" r=\"50000\" b=\"50000\"/></a:path></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/></a:theme>"]]></e></m></meta>
		</THEME>
		<STYLES final="1" set="null" expr="&quot;&lt;styleSheet xmlns=\&quot;http://schemas.openxmlformats.org/spreadsheetml/2006/main\&quot;&gt;&lt;numFmts count=\&quot;0\&quot; /&gt;&lt;fonts count=\&quot;1\&quot;&gt;&lt;font&gt;&lt;name val=\&quot;Calibri\&quot; /&gt;&lt;family val=\&quot;2\&quot; /&gt;&lt;color theme=\&quot;1\&quot; /&gt;&lt;sz val=\&quot;11\&quot; /&gt;&lt;scheme val=\&quot;minor\&quot; /&gt;&lt;/font&gt;&lt;/fonts&gt;&lt;fills count=\&quot;2\&quot;&gt;&lt;fill&gt;&lt;patternFill /&gt;&lt;/fill&gt;&lt;fill&gt;&lt;patternFill patternType=\&quot;gray125\&quot; /&gt;&lt;/fill&gt;&lt;/fills&gt;&lt;borders count=\&quot;1\&quot;&gt;&lt;border&gt;&lt;left /&gt;&lt;right /&gt;&lt;top /&gt;&lt;bottom /&gt;&lt;diagonal /&gt;&lt;/border&gt;&lt;/borders&gt;&lt;cellStyleXfs count=\&quot;1\&quot;&gt;&lt;xf borderId=\&quot;0\&quot; fillId=\&quot;0\&quot; fontId=\&quot;0\&quot; numFmtId=\&quot;0\&quot; /&gt;&lt;/cellStyleXfs&gt;&lt;cellXfs count=\&quot;1\&quot;&gt;&lt;xf borderId=\&quot;0\&quot; fillId=\&quot;0\&quot; fontId=\&quot;0\&quot; numFmtId=\&quot;0\&quot; pivotButton=\&quot;0\&quot; quotePrefix=\&quot;0\&quot; xfId=\&quot;0\&quot; /&gt;&lt;/cellXfs&gt;&lt;cellStyles count=\&quot;1\&quot;&gt;&lt;cellStyle builtinId=\&quot;0\&quot; hidden=\&quot;0\&quot; name=\&quot;Normal\&quot; xfId=\&quot;0\&quot; /&gt;&lt;/cellStyles&gt;&lt;tableStyles count=\&quot;0\&quot; defaultPivotStyle=\&quot;PivotStyleLight16\&quot; defaultTableStyle=\&quot;TableStyleMedium9\&quot; /&gt;&lt;/styleSheet&gt;&quot;" line="19" static="1">
			<c path="String"/>
			<meta><m n=":value"><e><![CDATA["<styleSheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\"><numFmts count=\"0\" /><fonts count=\"1\"><font><name val=\"Calibri\" /><family val=\"2\" /><color theme=\"1\" /><sz val=\"11\" /><scheme val=\"minor\" /></font></fonts><fills count=\"2\"><fill><patternFill /></fill><fill><patternFill patternType=\"gray125\" /></fill></fills><borders count=\"1\"><border><left /><right /><top /><bottom /><diagonal /></border></borders><cellStyleXfs count=\"1\"><xf borderId=\"0\" fillId=\"0\" fontId=\"0\" numFmtId=\"0\" /></cellStyleXfs><cellXfs count=\"1\"><xf borderId=\"0\" fillId=\"0\" fontId=\"0\" numFmtId=\"0\" pivotButton=\"0\" quotePrefix=\"0\" xfId=\"0\" /></cellXfs><cellStyles count=\"1\"><cellStyle builtinId=\"0\" hidden=\"0\" name=\"Normal\" xfId=\"0\" /></cellStyles><tableStyles count=\"0\" defaultPivotStyle=\"PivotStyleLight16\" defaultTableStyle=\"TableStyleMedium9\" /></styleSheet>"]]></e></m></meta>
		</STYLES>
		<zipEntry set="method" line="81" static="1"><f a="name:content">
	<c path="String"/>
	<c path="String"/>
	<t path="haxe.zip.Entry"/>
</f></zipEntry>
		<parseSheet set="method" line="116" static="1"><f a="sheet:strings">
	<t path="connect.util.ExcelSheet"/>
	<c path="Array"><c path="String"/></c>
	<c path="String"/>
</f></parseSheet>
		<getRowNames set="method" line="149" static="1"><f a="row:rowNumber">
	<t path="connect.util.ExcelRow"/>
	<x path="Int"/>
	<c path="Array"><c path="String"/></c>
</f></getRowNames>
		<sheets final="1"><t path="Map">
	<c path="String"/>
	<t path="connect.util.ExcelSheet"/>
</t></sheets>
		<addSheet public="1" set="method" line="27"><f a="name:sheet">
	<c path="String"/>
	<t path="connect.util.ExcelSheet"/>
	<c path="connect.util.ExcelWriter"/>
</f></addSheet>
		<sheetExists public="1" set="method" line="34"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></sheetExists>
		<compress public="1" set="method" line="38"><f a=""><c path="haxe.io.Bytes"/></f></compress>
		<getStrings set="method" line="61"><f a=""><c path="Array"><c path="String"/></c></f></getStrings>
		<getSheetNames set="method" line="75"><f a=""><c path="Array"><c path="String"/></c></f></getSheetNames>
		<parseSheetsStrings set="method" line="153"><f a=""><c path="String"/></f></parseSheetsStrings>
		<getWorkbook set="method" line="164"><f a=""><c path="String"/></f></getWorkbook>
		<getRels2 set="method" line="185"><f a=""><c path="String"/></f></getRels2>
		<getContentTypes set="method" line="203"><f a=""><c path="String"/></f></getContentTypes>
		<new public="1" set="method" line="23"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="connect.util.Util" params="" file="connect/util/Util.hx">
		<replaceStrSensitiveData public="1" set="method" line="16" static="1">
			<f a="text:regExData">
				<c path="String"/>
				<c path="connect.util.Collection"><c path="EReg"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>* Given a list of regex search all in a string and hide this values
     * @param text 
     * @param regExData</haxe_doc>
		</replaceStrSensitiveData>
		<beautify public="1" set="method" line="32" static="1"><f a="text:compact:masked:beautify">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
</f></beautify>
		<beautifyObject public="1" set="method" line="46" static="1"><f a="obj:compact:masked:beautify">
	<d/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
</f></beautifyObject>
		<maskFields public="1" set="method" line="73" static="1"><f a="obj">
	<d/>
	<d/>
</f></maskFields>
		<maskParams public="1" set="method" line="100" static="1"><f a="obj">
	<d/>
	<d/>
</f></maskParams>
		<maskParamsInObject set="method" line="109" static="1"><f a="obj">
	<d/>
	<x path="Void"/>
</f></maskParamsInObject>
		<maskParamsArray set="method" line="126" static="1"><f a="arr:maskedParams">
	<c path="Array"><d/></c>
	<c path="connect.util.Collection"><c path="String"/></c>
	<x path="Void"/>
</f></maskParamsArray>
		<maskConfigParam set="method" line="140" static="1"><f a="obj:configParam:maskedParams">
	<d/>
	<d/>
	<c path="connect.util.Collection"><c path="String"/></c>
	<x path="Void"/>
</f></maskConfigParam>
		<isJson public="1" set="method" line="160" static="1">
			<f a="text">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@returns Whether the text seems to contain a JSON object or array.
        NOTE: This function could return `true` even if the JSON string is malformed.</haxe_doc>
		</isJson>
		<isJsonObject public="1" set="method" line="168" static="1">
			<f a="text">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@returns Whether the text seems to contain a JSON object.
        NOTE: This function could return `true` even if the JSON string is malformed.</haxe_doc>
		</isJsonObject>
		<isJsonArray public="1" set="method" line="176" static="1">
			<f a="text">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@returns Whether the text seems to contain a JSON array.
        NOTE: This function could return `true` even if the JSON string is malformed.</haxe_doc>
		</isJsonArray>
		<isArray public="1" set="method" line="181" static="1">
			<f a="value">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@return Whether the passed object is an array.</haxe_doc>
		</isArray>
		<isStruct public="1" set="method" line="186" static="1">
			<f a="value">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>@return Whether the passed object is a dynamic object.</haxe_doc>
		</isStruct>
		<createObjectDiff public="1" set="method" line="198" static="1">
			<f a="object:previous">
				<d/>
				<d/>
				<d/>
			</f>
			<haxe_doc>* Creates an object with the differences between the two passed objects (except
     * for deletions). The objects must contain an id field.
     * This method is used for example when updating a request, to send only the modified data.
     * @param object The updated object.
     * @param previous The object prior to the updates.
     * @return The object with only the differences.</haxe_doc>
		</createObjectDiff>
		<addIdsToObject set="method" line="212" static="1">
			<f a="object:original">
				<d/>
				<d/>
				<d/>
			</f>
			<haxe_doc>* Creates a new dynamic object that contains the sames fields as `object`.
     * When a field contains a subobject that has no `id` field, but the respective
     * subobject in `original` contains an id field, the value is copied.
     * If a field contains an array, `compactArray` is called on it.
     * This method is used for example when updating a request, to send only the modified data.
     * @return A new dynamic object with the updated data.</haxe_doc>
		</addIdsToObject>
		<compactArray set="method" line="245" static="1">
			<f a="array:second">
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>* Creates a new array containing only the non-null elements of `array`.
     * If the value of an element is an array, the method is called recursively.
     * If the value of an element is an object, `addIdsToObject` is called, passing also
     * the value of the same object in the `second` array.
     * @return A new array containing only the modified elements.</haxe_doc>
		</compactArray>
		<getLines public="1" set="method" line="269" static="1">
			<f a="text">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc><![CDATA[* Splits the given text into its lines, detecting Windows (CR+LF), Mac OS Classic (CR) and
     * Unix (LF) line endings.
     * @param text 
     * @return Array<String>]]></haxe_doc>
		</getLines>
		<boolToInt public="1" set="method" line="278" static="1">
			<f a="b">
				<x path="Bool"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* @return Int `1` if the argument is `true`, `0` otherwise.</haxe_doc>
		</boolToInt>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="diff.Diff" params="" file="/home/travis/haxe/lib/diff/1,0,0/diff/Diff.hx">
		<isStruct set="method" line="65" static="1"><f a="value">
	<d/>
	<x path="Bool"/>
</f></isStruct>
		<isArray set="method" line="69" static="1"><f a="value">
	<d/>
	<x path="Bool"/>
</f></isArray>
		<checkStructs set="method" line="73" static="1"><f a="first:second">
	<d/>
	<d/>
	<x path="Void"/>
</f></checkStructs>
		<areEqual set="method" line="80" static="1"><f a="first:second">
	<d/>
	<d/>
	<x path="Bool"/>
</f></areEqual>
		<compareArrays set="method" line="85" static="1"><f a="first:second">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="Array"><c path="Array"><d/></c></c>
</f></compareArrays>
		<applyArray set="method" line="153" static="1"><f a="obj:arr">
	<c path="Array"><d/></c>
	<c path="Array"><c path="Array"><d/></c></c>
	<c path="Array"><d/></c>
</f></applyArray>
		<swapArray set="method" line="210" static="1"><f a="arr">
	<c path="Array"><c path="Array"><d/></c></c>
	<c path="Array"><c path="Array"><d/></c></c>
</f></swapArray>
		<mapToObject set="method" line="265" static="1"><f a="map">
	<c path="haxe.ds.StringMap"><d/></c>
	<d/>
</f></mapToObject>
		<changeArrayToObject set="method" line="272" static="1">
			<f a="arr">
				<c path="Array"><c path="Array"><d/></c></c>
				<c path="Array"><c path="Array"><d/></c></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</changeArrayToObject>
		<a final="1"><c path="haxe.ds.StringMap"><d/></c></a>
		<d final="1"><c path="haxe.ds.StringMap"><d/></c></d>
		<c final="1"><c path="haxe.ds.StringMap"><d/></c></c>
		<apply public="1" set="method" line="117">
			<f a="obj">
				<d/>
				<d/>
			</f>
			<haxe_doc>Applies to changes in `this` `Diff` to the dynamic object passed as argument.
        If this method is called on the `first` object passed when constructing `this`,
        then an object identical to `second` is returned.</haxe_doc>
		</apply>
		<swap public="1" set="method" line="182">
			<f a=""><c path="diff.Diff"/></f>
			<haxe_doc>Returns a new `Diff` that reverts the changes made by this one. If `apply` is called on
        the returned `Diff` passing the `second` argument used to construct `this`, then and object
        identical to the `first` argument used to construct `this` will be returned by `apply`.</haxe_doc>
		</swap>
		<toString public="1" set="method" line="238">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string with the Json representation of `this` `Diff`.</haxe_doc>
		</toString>
		<toObject set="method" line="242"><f a=""><d/></f></toObject>
		<new public="1" set="method" line="28">
			<f a="first:second">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new `Diff` storing the differences between the two objects passed. The differences basically are:

        - Additions: Fields present in `second` that are not present in `first`.
        - Deletions: Fields present in `first` that are not present in `second`.
        - Changes: Fields whose value has changed between `first` and `second`.

        The class is capable of tracking changes inside arrays.</haxe_doc>
		</new>
		<haxe_doc>The `Diff` class stores the difference between two Haxe dynamic objects `first` and `second`.
    You can later `apply` the diff object to `first` to obtain `second`, or `swap` the diff and then
    `apply` to `second` to get `first`.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="haxe.StackItem" params="" file="/home/travis/haxe/std/haxe/CallStack.hx" module="haxe.CallStack">
		<CFunction/>
		<Module a="m"><c path="String"/></Module>
		<FilePos a="s:file:line:?column">
			<x path="Null"><e path="haxe.StackItem"/></x>
			<c path="String"/>
			<x path="Int"/>
			<x path="Int"/>
		</FilePos>
		<Method a="classname:method">
			<x path="Null"><c path="String"/></x>
			<c path="String"/>
		</Method>
		<LocalFunction a="?v"><x path="Int"/></LocalFunction>
		<haxe_doc>Elements return by `CallStack` methods.</haxe_doc>
	</enum>
	<abstract path="haxe.CallStack" params="" file="/home/travis/haxe/std/haxe/CallStack.hx">
		<from><icast><c path="Array"><e path="haxe.StackItem"/></c></icast></from>
		<this><c path="Array"><e path="haxe.StackItem"/></c></this>
		<haxe_doc>Get information about the call stack.</haxe_doc>
		<meta>
			<m n=":allow"><e>haxe.Exception</e></m>
			<m n=":using"><e>haxe.CallStack</e></m>
		</meta>
		<impl><class path="haxe._CallStack.CallStack_Impl_" params="" file="/home/travis/haxe/std/haxe/CallStack.hx" private="1" module="haxe.CallStack" final="1">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<haxe_doc>The length of this stack.</haxe_doc>
	</length>
	<get_length get="inline" set="null" line="46" static="1"><f a="this">
	<c path="Array"><e path="haxe.StackItem"/></c>
	<x path="Int"/>
</f></get_length>
	<callStack public="1" set="method" line="51" static="1">
		<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
		<haxe_doc>Return the call stack elements, or an empty array if not available.</haxe_doc>
	</callStack>
	<exceptionStack public="1" set="method" line="63" static="1">
		<f a="?fullStack" v="false">
			<x path="Bool"/>
			<c path="Array"><e path="haxe.StackItem"/></c>
		</f>
		<meta><m n=":value"><e>{ fullStack : false }</e></m></meta>
		<haxe_doc>Return the exception stack : this is the stack elements between
		the place the last exception was thrown and the place it was
		caught, or an empty array if not available.
		Set `fullStack` parameter to true in order to return the full exception stack.

		May not work if catch type was a derivative from `haxe.Exception`.</haxe_doc>
	</exceptionStack>
	<toString public="1" set="method" line="71" static="1">
		<f a="stack">
			<x path="haxe.CallStack"/>
			<c path="String"/>
		</f>
		<haxe_doc>Returns a representation of the stack as a printable string.</haxe_doc>
	</toString>
	<subtract public="1" set="method" line="84" static="1">
		<f a="this:stack">
			<c path="Array"><e path="haxe.StackItem"/></c>
			<x path="haxe.CallStack"/>
			<x path="haxe.CallStack"/>
		</f>
		<haxe_doc>Returns a range of entries of current stack from the beginning to the the
		common part of this and `stack`.</haxe_doc>
	</subtract>
	<copy public="1" get="inline" set="null" line="107" static="1">
		<f a="this">
			<c path="Array"><e path="haxe.StackItem"/></c>
			<x path="haxe.CallStack"/>
		</f>
		<haxe_doc>Make a copy of the stack.</haxe_doc>
	</copy>
	<get public="1" get="inline" set="null" line="111" static="1">
		<f a="this:index">
			<c path="Array"><e path="haxe.StackItem"/></c>
			<x path="Int"/>
			<e path="haxe.StackItem"/>
		</f>
		<meta><m n=":arrayAccess"/></meta>
	</get>
	<asArray get="inline" set="null" line="115" static="1"><f a="this">
	<c path="Array"><e path="haxe.StackItem"/></c>
	<c path="Array"><e path="haxe.StackItem"/></c>
</f></asArray>
	<equalItems set="method" line="119" static="1"><f a="item1:item2">
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Bool"/>
</f></equalItems>
	<exceptionToString set="method" line="135" static="1"><f a="e">
	<c path="haxe.Exception"/>
	<c path="String"/>
</f></exceptionToString>
	<itemToString set="method" line="155" static="1"><f a="b:s">
	<c path="StringBuf"/>
	<e path="haxe.StackItem"/>
	<x path="Void"/>
</f></itemToString>
	<meta>
		<m n=":using"><e>haxe.CallStack</e></m>
		<m n=":allow"><e>haxe.Exception</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe._CallStack.CallStack_Impl_" params="" file="/home/travis/haxe/std/haxe/CallStack.hx" private="1" module="haxe.CallStack" final="1">
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>The length of this stack.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="46" static="1"><f a="this">
	<c path="Array"><e path="haxe.StackItem"/></c>
	<x path="Int"/>
</f></get_length>
		<callStack public="1" set="method" line="51" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>Return the call stack elements, or an empty array if not available.</haxe_doc>
		</callStack>
		<exceptionStack public="1" set="method" line="63" static="1">
			<f a="?fullStack" v="false">
				<x path="Bool"/>
				<c path="Array"><e path="haxe.StackItem"/></c>
			</f>
			<meta><m n=":value"><e>{ fullStack : false }</e></m></meta>
			<haxe_doc>Return the exception stack : this is the stack elements between
		the place the last exception was thrown and the place it was
		caught, or an empty array if not available.
		Set `fullStack` parameter to true in order to return the full exception stack.

		May not work if catch type was a derivative from `haxe.Exception`.</haxe_doc>
		</exceptionStack>
		<toString public="1" set="method" line="71" static="1">
			<f a="stack">
				<x path="haxe.CallStack"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a representation of the stack as a printable string.</haxe_doc>
		</toString>
		<subtract public="1" set="method" line="84" static="1">
			<f a="this:stack">
				<c path="Array"><e path="haxe.StackItem"/></c>
				<x path="haxe.CallStack"/>
				<x path="haxe.CallStack"/>
			</f>
			<haxe_doc>Returns a range of entries of current stack from the beginning to the the
		common part of this and `stack`.</haxe_doc>
		</subtract>
		<copy public="1" get="inline" set="null" line="107" static="1">
			<f a="this">
				<c path="Array"><e path="haxe.StackItem"/></c>
				<x path="haxe.CallStack"/>
			</f>
			<haxe_doc>Make a copy of the stack.</haxe_doc>
		</copy>
		<get public="1" get="inline" set="null" line="111" static="1">
			<f a="this:index">
				<c path="Array"><e path="haxe.StackItem"/></c>
				<x path="Int"/>
				<e path="haxe.StackItem"/>
			</f>
			<meta><m n=":arrayAccess"/></meta>
		</get>
		<asArray get="inline" set="null" line="115" static="1"><f a="this">
	<c path="Array"><e path="haxe.StackItem"/></c>
	<c path="Array"><e path="haxe.StackItem"/></c>
</f></asArray>
		<equalItems set="method" line="119" static="1"><f a="item1:item2">
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Bool"/>
</f></equalItems>
		<exceptionToString set="method" line="135" static="1"><f a="e">
	<c path="haxe.Exception"/>
	<c path="String"/>
</f></exceptionToString>
		<itemToString set="method" line="155" static="1"><f a="b:s">
	<c path="StringBuf"/>
	<e path="haxe.StackItem"/>
	<x path="Void"/>
</f></itemToString>
		<meta>
			<m n=":using"><e>haxe.CallStack</e></m>
			<m n=":allow"><e>haxe.Exception</e></m>
		</meta>
	</class>
	<abstract path="haxe.Function" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" extern="1" final="1"/></impl>
	</abstract>
	<class path="haxe._Constraints.Function_Impl_" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" extern="1" final="1"/>
	<abstract path="haxe.FlatEnum" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" extern="1" final="1"/></impl>
	</abstract>
	<class path="haxe._Constraints.FlatEnum_Impl_" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" extern="1" final="1"/>
	<abstract path="haxe.NotVoid" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with anything but `Void`.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.NotVoid_Impl_" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" extern="1" final="1"/></impl>
	</abstract>
	<class path="haxe._Constraints.NotVoid_Impl_" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" extern="1" final="1"/>
	<abstract path="haxe.Constructible" params="T" file="/home/travis/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which

	  * is `public` and
	  * unifies with the type used for type parameter `T`.

	If a type parameter `A` is assigned to a type parameter `B` which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" extern="1" final="1"/></impl>
	</abstract>
	<class path="haxe._Constraints.Constructible_Impl_" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" extern="1" final="1"/>
	<class path="haxe.EnumTools" params="" file="/home/travis/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="52" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		
			pack1.pack2.(...).packN.EnumName

		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="65" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="81" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="98" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="110" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `enum` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/home/travis/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="133" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="144" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="158" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="170" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `EnumValue` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.Exception" params="" file="/home/travis/haxe/std/haxe/Exception.hx" extern="1">
		<caught set="method" static="1">
			<f a="value">
				<x path="Any"/>
				<c path="haxe.Exception"/>
			</f>
			<haxe_doc>Used internally for wildcard catches like `catch(e:Exception)`.</haxe_doc>
		</caught>
		<thrown set="method" static="1">
			<f a="value">
				<x path="Any"/>
				<x path="Any"/>
			</f>
			<haxe_doc>Used internally for wrapping non-throwable values for `throw` expressions.</haxe_doc>
		</thrown>
		<message public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>Exception message.</haxe_doc>
		</message>
		<get_message set="method"><f a=""><c path="String"/></f></get_message>
		<stack public="1" get="accessor" set="null">
			<x path="haxe.CallStack"/>
			<haxe_doc>The call stack at the moment of the exception creation.</haxe_doc>
		</stack>
		<get_stack set="method"><f a=""><x path="haxe.CallStack"/></f></get_stack>
		<previous public="1" get="accessor" set="null">
			<x path="Null"><c path="haxe.Exception"/></x>
			<haxe_doc>Contains an exception, which was passed to `previous` constructor argument.</haxe_doc>
		</previous>
		<get_previous set="method"><f a=""><x path="Null"><c path="haxe.Exception"/></x></f></get_previous>
		<native public="1" get="accessor" set="null">
			<x path="Any"/>
			<haxe_doc>Native exception, which caused this exception.</haxe_doc>
		</native>
		<get_native final="1" set="method"><f a=""><x path="Any"/></f></get_native>
		<unwrap set="method">
			<f a=""><x path="Any"/></f>
			<haxe_doc>Extract an originally thrown value.

		Used internally for catching non-native exceptions.
		Do _not_ override unless you know what you are doing.</haxe_doc>
		</unwrap>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns exception message.</haxe_doc>
		</toString>
		<details public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Detailed exception description.

		Includes message, stack and the chain of previous exceptions (if set).</haxe_doc>
		</details>
		<new public="1" set="method">
			<f a="message:?previous:?native">
				<c path="String"/>
				<c path="haxe.Exception"/>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new Exception instance.

		The `previous` argument could be used for exception chaining.

		The `native` argument is for internal usage only.
		There is no need to provide `native` argument manually and no need to keep it
		upon extending `haxe.Exception` unless you know what you're doing.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[Base class for exceptions.

	If this class (or derivatives) is used to catch an exception, then
	`haxe.CallStack.exceptionStack()` will not return a stack for the exception
	caught. Use `haxe.Exception.stack` property instead:
	```haxe
	try {
		throwSomething();
	} catch(e:Exception) {
		trace(e.stack);
	}
	```

	Custom exceptions should extend this class:
	```haxe
	class MyException extends haxe.Exception {}
	//...
	throw new MyException('terrible exception');
	```

	`haxe.Exception` is also a wildcard type to catch any exception:
	```haxe
	try {
		throw 'Catch me!';
	} catch(e:haxe.Exception) {
		trace(e.message); // Output: Catch me!
	}
	```

	To rethrow an exception just throw it again.
	Haxe will try to rethrow an original native exception whenever possible.
	```haxe
	try {
		var a:Array<Int> = null;
		a.push(1); // generates target-specific null-pointer exception
	} catch(e:haxe.Exception) {
		throw e; // rethrows native exception instead of haxe.Exception
	}
	```]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="haxe.Http" params="" file="/home/travis/haxe/std/haxe/Http.hx"><c path="sys.Http"/></typedef>
	<abstract path="haxe.Int32" params="" file="/home/travis/haxe/std/haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
	all platforms.</haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="/home/travis/haxe/std/haxe/Int32.hx" private="1" module="haxe.Int32" final="1">
	<negate get="inline" set="null" line="32" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":op"><e>-A</e></m></meta>
	</negate>
	<preIncrement get="inline" set="null" line="35" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":op"><e>++A</e></m></meta>
	</preIncrement>
	<postIncrement get="inline" set="null" line="37" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":op"><e>A++</e></m></meta>
	</postIncrement>
	<preDecrement get="inline" set="null" line="44" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":op"><e>--A</e></m></meta>
	</preDecrement>
	<postDecrement get="inline" set="null" line="46" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":op"><e>A--</e></m></meta>
	</postDecrement>
	<add get="inline" set="null" line="53" static="1">
		<f a="a:b">
			<x path="haxe.Int32"/>
			<x path="haxe.Int32"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
	</add>
	<addInt get="inline" set="null" line="56" static="1">
		<f a="a:b">
			<x path="haxe.Int32"/>
			<x path="Int"/>
			<x path="haxe.Int32"/>
		</f>
		<meta>
			<m n=":op"><e>A + B</e></m>
			<m n=":commutative"/>
		</meta>
	</addInt>
	<sub get="inline" set="null" line="61" static="1">
		<f a="a:b">
			<x path="haxe.Int32"/>
			<x path="haxe.Int32"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</sub>
	<subInt get="inline" set="null" line="64" static="1">
		<f a="a:b">
			<x path="haxe.Int32"/>
			<x path="Int"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</subInt>
	<intSub get="inline" set="null" line="67" static="1">
		<f a="a:b">
			<x path="Int"/>
			<x path="haxe.Int32"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</intSub>
	<toFloat get="inline" set="null" line="249" static="1">
		<f a="this">
			<x path="Int"/>
			<x path="Float"/>
		</f>
		<meta><m n=":to"/></meta>
	</toFloat>
	<ucompare public="1" set="method" line="254" static="1">
		<f a="a:b">
			<x path="haxe.Int32"/>
			<x path="haxe.Int32"/>
			<x path="Int"/>
		</f>
		<haxe_doc>Compare `a` and `b` in unsigned mode.</haxe_doc>
	</ucompare>
	<clamp get="inline" set="null" line="267" static="1"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></clamp>
</class></impl>
	</abstract>
	<class path="haxe._Int32.Int32_Impl_" params="" file="/home/travis/haxe/std/haxe/Int32.hx" private="1" module="haxe.Int32" final="1">
		<negate get="inline" set="null" line="32" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":op"><e>-A</e></m></meta>
		</negate>
		<preIncrement get="inline" set="null" line="35" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":op"><e>++A</e></m></meta>
		</preIncrement>
		<postIncrement get="inline" set="null" line="37" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":op"><e>A++</e></m></meta>
		</postIncrement>
		<preDecrement get="inline" set="null" line="44" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":op"><e>--A</e></m></meta>
		</preDecrement>
		<postDecrement get="inline" set="null" line="46" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":op"><e>A--</e></m></meta>
		</postDecrement>
		<add get="inline" set="null" line="53" static="1">
			<f a="a:b">
				<x path="haxe.Int32"/>
				<x path="haxe.Int32"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
		</add>
		<addInt get="inline" set="null" line="56" static="1">
			<f a="a:b">
				<x path="haxe.Int32"/>
				<x path="Int"/>
				<x path="haxe.Int32"/>
			</f>
			<meta>
				<m n=":op"><e>A + B</e></m>
				<m n=":commutative"/>
			</meta>
		</addInt>
		<sub get="inline" set="null" line="61" static="1">
			<f a="a:b">
				<x path="haxe.Int32"/>
				<x path="haxe.Int32"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</sub>
		<subInt get="inline" set="null" line="64" static="1">
			<f a="a:b">
				<x path="haxe.Int32"/>
				<x path="Int"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</subInt>
		<intSub get="inline" set="null" line="67" static="1">
			<f a="a:b">
				<x path="Int"/>
				<x path="haxe.Int32"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</intSub>
		<toFloat get="inline" set="null" line="249" static="1">
			<f a="this">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<meta><m n=":to"/></meta>
		</toFloat>
		<ucompare public="1" set="method" line="254" static="1">
			<f a="a:b">
				<x path="haxe.Int32"/>
				<x path="haxe.Int32"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compare `a` and `b` in unsigned mode.</haxe_doc>
		</ucompare>
		<clamp get="inline" set="null" line="267" static="1"><f a="x">
	<x path="Int"/>
	<x path="Int"/>
</f></clamp>
	</class>
	<abstract path="haxe.Int64" params="" file="/home/travis/haxe/std/haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<haxe_doc>A cross-platform signed 64-bit integer.
	Int64 instances can be created from two 32-bit words using `Int64.make()`.</haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="/home/travis/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64" final="1">
	<_new get="inline" set="null" line="36" static="1">
		<f a="x">
			<t path="haxe._Int64.__Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<copy public="1" get="inline" set="null" line="43" static="1">
		<f a="this">
			<t path="haxe._Int64.__Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<haxe_doc>Makes a copy of `this` Int64.</haxe_doc>
	</copy>
	<make public="1" get="inline" set="null" line="49" static="1">
		<f a="high:low">
			<x path="haxe.Int32"/>
			<x path="haxe.Int32"/>
			<x path="haxe.Int64"/>
		</f>
		<haxe_doc>Construct an Int64 from two 32-bit words `high` and `low`.</haxe_doc>
	</make>
	<ofInt public="1" get="inline" set="null" line="56" static="1">
		<f a="x">
			<x path="Int"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":from"/></meta>
		<haxe_doc>Returns an Int64 with the value of the Int `x`.
		`x` is sign-extended to fill 64 bits.</haxe_doc>
	</ofInt>
	<toInt public="1" get="inline" set="null" line="62" static="1">
		<f a="x">
			<x path="haxe.Int64"/>
			<x path="Int"/>
		</f>
		<haxe_doc>Returns an Int with the value of the Int64 `x`.
		Throws an exception  if `x` cannot be represented in 32 bits.</haxe_doc>
	</toInt>
	<is public="1" get="inline" set="null" line="70" static="1">
		<f a="val">
			<d/>
			<x path="Bool"/>
		</f>
		<meta><m n=":deprecated"><e>"haxe.Int64.is() is deprecated. Use haxe.Int64.isInt64() instead"</e></m></meta>
	</is>
	<isInt64 public="1" get="inline" set="null" line="78" static="1">
		<f a="val">
			<d/>
			<x path="Bool"/>
		</f>
		<haxe_doc>Returns whether the value `val` is of type `haxe.Int64`</haxe_doc>
	</isInt64>
	<getHigh public="1" get="inline" set="null" line="85" static="1">
		<f a="x">
			<x path="haxe.Int64"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":deprecated"><e>"Use high instead"</e></m></meta>
		<haxe_doc>Returns the high 32-bit word of `x`.</haxe_doc>
	</getHigh>
	<getLow public="1" get="inline" set="null" line="92" static="1">
		<f a="x">
			<x path="haxe.Int64"/>
			<x path="haxe.Int32"/>
		</f>
		<meta><m n=":deprecated"><e>"Use low instead"</e></m></meta>
		<haxe_doc>Returns the low 32-bit word of `x`.</haxe_doc>
	</getLow>
	<isNeg public="1" get="inline" set="null" line="98" static="1">
		<f a="x">
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<haxe_doc>Returns `true` if `x` is less than zero.</haxe_doc>
	</isNeg>
	<isZero public="1" get="inline" set="null" line="104" static="1">
		<f a="x">
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<haxe_doc>Returns `true` if `x` is exactly zero.</haxe_doc>
	</isZero>
	<compare public="1" get="inline" set="null" line="111" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="Int"/>
		</f>
		<haxe_doc><![CDATA[Compares `a` and `b` in signed mode.
		Returns a negative value if `a < b`, positive if `a > b`,
		or 0 if `a == b`.]]></haxe_doc>
	</compare>
	<ucompare public="1" get="inline" set="null" line="122" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="Int"/>
		</f>
		<haxe_doc><![CDATA[Compares `a` and `b` in unsigned mode.
		Returns a negative value if `a < b`, positive if `a > b`,
		or 0 if `a == b`.]]></haxe_doc>
	</ucompare>
	<toStr public="1" get="inline" set="null" line="131" static="1">
		<f a="x">
			<x path="haxe.Int64"/>
			<c path="String"/>
		</f>
		<haxe_doc>Returns a signed decimal `String` representation of `x`.</haxe_doc>
	</toStr>
	<toString set="method" line="133" static="1"><f a="this">
	<t path="haxe._Int64.__Int64"/>
	<c path="String"/>
</f></toString>
	<parseString public="1" get="inline" set="null" line="159" static="1"><f a="sParam">
	<c path="String"/>
	<x path="haxe.Int64"/>
</f></parseString>
	<fromFloat public="1" get="inline" set="null" line="163" static="1"><f a="f">
	<x path="Float"/>
	<x path="haxe.Int64"/>
</f></fromFloat>
	<divMod public="1" set="method" line="171" static="1">
		<f a="dividend:divisor">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<a>
				<quotient><x path="haxe.Int64"/></quotient>
				<modulus><x path="haxe.Int64"/></modulus>
			</a>
		</f>
		<haxe_doc>Performs signed integer divison of `dividend` by `divisor`.
		Returns `{ quotient : Int64, modulus : Int64 }`.</haxe_doc>
	</divMod>
	<neg public="1" get="inline" set="null" line="221" static="1">
		<f a="x">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>-A</e></m></meta>
		<haxe_doc>Returns the negative of `x`.</haxe_doc>
	</neg>
	<preIncrement get="inline" set="null" line="229" static="1">
		<f a="this">
			<t path="haxe._Int64.__Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>++A</e></m></meta>
	</preIncrement>
	<postIncrement get="inline" set="null" line="237" static="1">
		<f a="this">
			<t path="haxe._Int64.__Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A++</e></m></meta>
	</postIncrement>
	<preDecrement get="inline" set="null" line="243" static="1">
		<f a="this">
			<t path="haxe._Int64.__Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>--A</e></m></meta>
	</preDecrement>
	<postDecrement get="inline" set="null" line="251" static="1">
		<f a="this">
			<t path="haxe._Int64.__Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A--</e></m></meta>
	</postDecrement>
	<add public="1" get="inline" set="null" line="260" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A + B</e></m></meta>
		<haxe_doc>Returns the sum of `a` and `b`.</haxe_doc>
	</add>
	<addInt get="inline" set="null" line="269" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="haxe.Int64"/>
		</f>
		<meta>
			<m n=":op"><e>A + B</e></m>
			<m n=":commutative"/>
		</meta>
	</addInt>
	<sub public="1" get="inline" set="null" line="274" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
		<haxe_doc>Returns `a` minus `b`.</haxe_doc>
	</sub>
	<subInt get="inline" set="null" line="283" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</subInt>
	<intSub get="inline" set="null" line="286" static="1">
		<f a="a:b">
			<x path="Int"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A - B</e></m></meta>
	</intSub>
	<mul public="1" get="inline" set="null" line="292" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A * B</e></m></meta>
		<haxe_doc>Returns the product of `a` and `b`.</haxe_doc>
	</mul>
	<mulInt get="inline" set="null" line="315" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="haxe.Int64"/>
		</f>
		<meta>
			<m n=":op"><e>A * B</e></m>
			<m n=":commutative"/>
		</meta>
	</mulInt>
	<div public="1" get="inline" set="null" line="321" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A / B</e></m></meta>
		<haxe_doc>Returns the quotient of `a` divided by `b`.</haxe_doc>
	</div>
	<divInt get="inline" set="null" line="324" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A / B</e></m></meta>
	</divInt>
	<intDiv get="inline" set="null" line="327" static="1">
		<f a="a:b">
			<x path="Int"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A / B</e></m></meta>
	</intDiv>
	<mod public="1" get="inline" set="null" line="333" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A % B</e></m></meta>
		<haxe_doc>Returns the modulus of `a` divided by `b`.</haxe_doc>
	</mod>
	<modInt get="inline" set="null" line="336" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A % B</e></m></meta>
	</modInt>
	<intMod get="inline" set="null" line="339" static="1">
		<f a="a:b">
			<x path="Int"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A % B</e></m></meta>
	</intMod>
	<eq public="1" get="inline" set="null" line="345" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A == B</e></m></meta>
		<haxe_doc>Returns `true` if `a` is equal to `b`.</haxe_doc>
	</eq>
	<eqInt get="inline" set="null" line="348" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":op"><e>A == B</e></m>
			<m n=":commutative"/>
		</meta>
	</eqInt>
	<neq public="1" get="inline" set="null" line="354" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e>A != B</e></m></meta>
		<haxe_doc>Returns `true` if `a` is not equal to `b`.</haxe_doc>
	</neq>
	<neqInt get="inline" set="null" line="357" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta>
			<m n=":op"><e>A != B</e></m>
			<m n=":commutative"/>
		</meta>
	</neqInt>
	<lt get="inline" set="null" line="360" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</lt>
	<ltInt get="inline" set="null" line="363" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</ltInt>
	<intLt get="inline" set="null" line="366" static="1">
		<f a="a:b">
			<x path="Int"/>
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
	</intLt>
	<lte get="inline" set="null" line="369" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</lte>
	<lteInt get="inline" set="null" line="372" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</lteInt>
	<intLte get="inline" set="null" line="375" static="1">
		<f a="a:b">
			<x path="Int"/>
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
	</intLte>
	<gt get="inline" set="null" line="378" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</gt>
	<gtInt get="inline" set="null" line="381" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</gtInt>
	<intGt get="inline" set="null" line="384" static="1">
		<f a="a:b">
			<x path="Int"/>
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
	</intGt>
	<gte get="inline" set="null" line="387" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</gte>
	<gteInt get="inline" set="null" line="390" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</gteInt>
	<intGte get="inline" set="null" line="393" static="1">
		<f a="a:b">
			<x path="Int"/>
			<x path="haxe.Int64"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
	</intGte>
	<complement get="inline" set="null" line="399" static="1">
		<f a="a">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>~A</e></m></meta>
		<haxe_doc>Returns the bitwise NOT of `a`.</haxe_doc>
	</complement>
	<and public="1" get="inline" set="null" line="405" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A & B]]></e></m></meta>
		<haxe_doc>Returns the bitwise AND of `a` and `b`.</haxe_doc>
	</and>
	<or public="1" get="inline" set="null" line="411" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A | B</e></m></meta>
		<haxe_doc>Returns the bitwise OR of `a` and `b`.</haxe_doc>
	</or>
	<xor public="1" get="inline" set="null" line="417" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e>A ^ B</e></m></meta>
		<haxe_doc>Returns the bitwise XOR of `a` and `b`.</haxe_doc>
	</xor>
	<shl public="1" get="inline" set="null" line="422" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A << B]]></e></m></meta>
		<haxe_doc>Returns `a` left-shifted by `b` bits.</haxe_doc>
	</shl>
	<shr public="1" get="inline" set="null" line="431" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >> B]]></e></m></meta>
		<haxe_doc>Returns `a` right-shifted by `b` bits in signed mode.
		`a` is sign-extended.</haxe_doc>
	</shr>
	<ushr public="1" get="inline" set="null" line="440" static="1">
		<f a="a:b">
			<x path="haxe.Int64"/>
			<x path="Int"/>
			<x path="haxe.Int64"/>
		</f>
		<meta><m n=":op"><e><![CDATA[A >>> B]]></e></m></meta>
		<haxe_doc>Returns `a` right-shifted by `b` bits in unsigned mode.
		`a` is padded with zeroes.</haxe_doc>
	</ushr>
	<high public="1" get="accessor" set="null" static="1"><x path="haxe.Int32"/></high>
	<get_high get="inline" set="null" line="448" static="1"><f a="this">
	<t path="haxe._Int64.__Int64"/>
	<x path="haxe.Int32"/>
</f></get_high>
	<set_high get="inline" set="null" line="451" static="1"><f a="this:x">
	<t path="haxe._Int64.__Int64"/>
	<x path="haxe.Int32"/>
	<x path="haxe.Int32"/>
</f></set_high>
	<low public="1" get="accessor" set="null" static="1"><x path="haxe.Int32"/></low>
	<get_low get="inline" set="null" line="456" static="1"><f a="this">
	<t path="haxe._Int64.__Int64"/>
	<x path="haxe.Int32"/>
</f></get_low>
	<set_low get="inline" set="null" line="459" static="1"><f a="this:x">
	<t path="haxe._Int64.__Int64"/>
	<x path="haxe.Int32"/>
	<x path="haxe.Int32"/>
</f></set_low>
</class></impl>
	</abstract>
	<class path="haxe._Int64.Int64_Impl_" params="" file="/home/travis/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64" final="1">
		<_new get="inline" set="null" line="36" static="1">
			<f a="x">
				<t path="haxe._Int64.__Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<copy public="1" get="inline" set="null" line="43" static="1">
			<f a="this">
				<t path="haxe._Int64.__Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<haxe_doc>Makes a copy of `this` Int64.</haxe_doc>
		</copy>
		<make public="1" get="inline" set="null" line="49" static="1">
			<f a="high:low">
				<x path="haxe.Int32"/>
				<x path="haxe.Int32"/>
				<x path="haxe.Int64"/>
			</f>
			<haxe_doc>Construct an Int64 from two 32-bit words `high` and `low`.</haxe_doc>
		</make>
		<ofInt public="1" get="inline" set="null" line="56" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":from"/></meta>
			<haxe_doc>Returns an Int64 with the value of the Int `x`.
		`x` is sign-extended to fill 64 bits.</haxe_doc>
		</ofInt>
		<toInt public="1" get="inline" set="null" line="62" static="1">
			<f a="x">
				<x path="haxe.Int64"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns an Int with the value of the Int64 `x`.
		Throws an exception  if `x` cannot be represented in 32 bits.</haxe_doc>
		</toInt>
		<is public="1" get="inline" set="null" line="70" static="1">
			<f a="val">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":deprecated"><e>"haxe.Int64.is() is deprecated. Use haxe.Int64.isInt64() instead"</e></m></meta>
		</is>
		<isInt64 public="1" get="inline" set="null" line="78" static="1">
			<f a="val">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whether the value `val` is of type `haxe.Int64`</haxe_doc>
		</isInt64>
		<getHigh public="1" get="inline" set="null" line="85" static="1">
			<f a="x">
				<x path="haxe.Int64"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":deprecated"><e>"Use high instead"</e></m></meta>
			<haxe_doc>Returns the high 32-bit word of `x`.</haxe_doc>
		</getHigh>
		<getLow public="1" get="inline" set="null" line="92" static="1">
			<f a="x">
				<x path="haxe.Int64"/>
				<x path="haxe.Int32"/>
			</f>
			<meta><m n=":deprecated"><e>"Use low instead"</e></m></meta>
			<haxe_doc>Returns the low 32-bit word of `x`.</haxe_doc>
		</getLow>
		<isNeg public="1" get="inline" set="null" line="98" static="1">
			<f a="x">
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if `x` is less than zero.</haxe_doc>
		</isNeg>
		<isZero public="1" get="inline" set="null" line="104" static="1">
			<f a="x">
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if `x` is exactly zero.</haxe_doc>
		</isZero>
		<compare public="1" get="inline" set="null" line="111" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[Compares `a` and `b` in signed mode.
		Returns a negative value if `a < b`, positive if `a > b`,
		or 0 if `a == b`.]]></haxe_doc>
		</compare>
		<ucompare public="1" get="inline" set="null" line="122" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[Compares `a` and `b` in unsigned mode.
		Returns a negative value if `a < b`, positive if `a > b`,
		or 0 if `a == b`.]]></haxe_doc>
		</ucompare>
		<toStr public="1" get="inline" set="null" line="131" static="1">
			<f a="x">
				<x path="haxe.Int64"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a signed decimal `String` representation of `x`.</haxe_doc>
		</toStr>
		<toString set="method" line="133" static="1"><f a="this">
	<t path="haxe._Int64.__Int64"/>
	<c path="String"/>
</f></toString>
		<parseString public="1" get="inline" set="null" line="159" static="1"><f a="sParam">
	<c path="String"/>
	<x path="haxe.Int64"/>
</f></parseString>
		<fromFloat public="1" get="inline" set="null" line="163" static="1"><f a="f">
	<x path="Float"/>
	<x path="haxe.Int64"/>
</f></fromFloat>
		<divMod public="1" set="method" line="171" static="1">
			<f a="dividend:divisor">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<a>
					<quotient><x path="haxe.Int64"/></quotient>
					<modulus><x path="haxe.Int64"/></modulus>
				</a>
			</f>
			<haxe_doc>Performs signed integer divison of `dividend` by `divisor`.
		Returns `{ quotient : Int64, modulus : Int64 }`.</haxe_doc>
		</divMod>
		<neg public="1" get="inline" set="null" line="221" static="1">
			<f a="x">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>-A</e></m></meta>
			<haxe_doc>Returns the negative of `x`.</haxe_doc>
		</neg>
		<preIncrement get="inline" set="null" line="229" static="1">
			<f a="this">
				<t path="haxe._Int64.__Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>++A</e></m></meta>
		</preIncrement>
		<postIncrement get="inline" set="null" line="237" static="1">
			<f a="this">
				<t path="haxe._Int64.__Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A++</e></m></meta>
		</postIncrement>
		<preDecrement get="inline" set="null" line="243" static="1">
			<f a="this">
				<t path="haxe._Int64.__Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>--A</e></m></meta>
		</preDecrement>
		<postDecrement get="inline" set="null" line="251" static="1">
			<f a="this">
				<t path="haxe._Int64.__Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A--</e></m></meta>
		</postDecrement>
		<add public="1" get="inline" set="null" line="260" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A + B</e></m></meta>
			<haxe_doc>Returns the sum of `a` and `b`.</haxe_doc>
		</add>
		<addInt get="inline" set="null" line="269" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="haxe.Int64"/>
			</f>
			<meta>
				<m n=":op"><e>A + B</e></m>
				<m n=":commutative"/>
			</meta>
		</addInt>
		<sub public="1" get="inline" set="null" line="274" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
			<haxe_doc>Returns `a` minus `b`.</haxe_doc>
		</sub>
		<subInt get="inline" set="null" line="283" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</subInt>
		<intSub get="inline" set="null" line="286" static="1">
			<f a="a:b">
				<x path="Int"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A - B</e></m></meta>
		</intSub>
		<mul public="1" get="inline" set="null" line="292" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A * B</e></m></meta>
			<haxe_doc>Returns the product of `a` and `b`.</haxe_doc>
		</mul>
		<mulInt get="inline" set="null" line="315" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="haxe.Int64"/>
			</f>
			<meta>
				<m n=":op"><e>A * B</e></m>
				<m n=":commutative"/>
			</meta>
		</mulInt>
		<div public="1" get="inline" set="null" line="321" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A / B</e></m></meta>
			<haxe_doc>Returns the quotient of `a` divided by `b`.</haxe_doc>
		</div>
		<divInt get="inline" set="null" line="324" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A / B</e></m></meta>
		</divInt>
		<intDiv get="inline" set="null" line="327" static="1">
			<f a="a:b">
				<x path="Int"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A / B</e></m></meta>
		</intDiv>
		<mod public="1" get="inline" set="null" line="333" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A % B</e></m></meta>
			<haxe_doc>Returns the modulus of `a` divided by `b`.</haxe_doc>
		</mod>
		<modInt get="inline" set="null" line="336" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A % B</e></m></meta>
		</modInt>
		<intMod get="inline" set="null" line="339" static="1">
			<f a="a:b">
				<x path="Int"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A % B</e></m></meta>
		</intMod>
		<eq public="1" get="inline" set="null" line="345" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A == B</e></m></meta>
			<haxe_doc>Returns `true` if `a` is equal to `b`.</haxe_doc>
		</eq>
		<eqInt get="inline" set="null" line="348" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":op"><e>A == B</e></m>
				<m n=":commutative"/>
			</meta>
		</eqInt>
		<neq public="1" get="inline" set="null" line="354" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e>A != B</e></m></meta>
			<haxe_doc>Returns `true` if `a` is not equal to `b`.</haxe_doc>
		</neq>
		<neqInt get="inline" set="null" line="357" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":op"><e>A != B</e></m>
				<m n=":commutative"/>
			</meta>
		</neqInt>
		<lt get="inline" set="null" line="360" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</lt>
		<ltInt get="inline" set="null" line="363" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</ltInt>
		<intLt get="inline" set="null" line="366" static="1">
			<f a="a:b">
				<x path="Int"/>
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A < B]]></e></m></meta>
		</intLt>
		<lte get="inline" set="null" line="369" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</lte>
		<lteInt get="inline" set="null" line="372" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</lteInt>
		<intLte get="inline" set="null" line="375" static="1">
			<f a="a:b">
				<x path="Int"/>
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A <= B]]></e></m></meta>
		</intLte>
		<gt get="inline" set="null" line="378" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</gt>
		<gtInt get="inline" set="null" line="381" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</gtInt>
		<intGt get="inline" set="null" line="384" static="1">
			<f a="a:b">
				<x path="Int"/>
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A > B]]></e></m></meta>
		</intGt>
		<gte get="inline" set="null" line="387" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</gte>
		<gteInt get="inline" set="null" line="390" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</gteInt>
		<intGte get="inline" set="null" line="393" static="1">
			<f a="a:b">
				<x path="Int"/>
				<x path="haxe.Int64"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >= B]]></e></m></meta>
		</intGte>
		<complement get="inline" set="null" line="399" static="1">
			<f a="a">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>~A</e></m></meta>
			<haxe_doc>Returns the bitwise NOT of `a`.</haxe_doc>
		</complement>
		<and public="1" get="inline" set="null" line="405" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A & B]]></e></m></meta>
			<haxe_doc>Returns the bitwise AND of `a` and `b`.</haxe_doc>
		</and>
		<or public="1" get="inline" set="null" line="411" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A | B</e></m></meta>
			<haxe_doc>Returns the bitwise OR of `a` and `b`.</haxe_doc>
		</or>
		<xor public="1" get="inline" set="null" line="417" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e>A ^ B</e></m></meta>
			<haxe_doc>Returns the bitwise XOR of `a` and `b`.</haxe_doc>
		</xor>
		<shl public="1" get="inline" set="null" line="422" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A << B]]></e></m></meta>
			<haxe_doc>Returns `a` left-shifted by `b` bits.</haxe_doc>
		</shl>
		<shr public="1" get="inline" set="null" line="431" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >> B]]></e></m></meta>
			<haxe_doc>Returns `a` right-shifted by `b` bits in signed mode.
		`a` is sign-extended.</haxe_doc>
		</shr>
		<ushr public="1" get="inline" set="null" line="440" static="1">
			<f a="a:b">
				<x path="haxe.Int64"/>
				<x path="Int"/>
				<x path="haxe.Int64"/>
			</f>
			<meta><m n=":op"><e><![CDATA[A >>> B]]></e></m></meta>
			<haxe_doc>Returns `a` right-shifted by `b` bits in unsigned mode.
		`a` is padded with zeroes.</haxe_doc>
		</ushr>
		<high public="1" get="accessor" set="null" static="1"><x path="haxe.Int32"/></high>
		<get_high get="inline" set="null" line="448" static="1"><f a="this">
	<t path="haxe._Int64.__Int64"/>
	<x path="haxe.Int32"/>
</f></get_high>
		<set_high get="inline" set="null" line="451" static="1"><f a="this:x">
	<t path="haxe._Int64.__Int64"/>
	<x path="haxe.Int32"/>
	<x path="haxe.Int32"/>
</f></set_high>
		<low public="1" get="accessor" set="null" static="1"><x path="haxe.Int32"/></low>
		<get_low get="inline" set="null" line="456" static="1"><f a="this">
	<t path="haxe._Int64.__Int64"/>
	<x path="haxe.Int32"/>
</f></get_low>
		<set_low get="inline" set="null" line="459" static="1"><f a="this:x">
	<t path="haxe._Int64.__Int64"/>
	<x path="haxe.Int32"/>
	<x path="haxe.Int32"/>
</f></set_low>
	</class>
	<typedef path="haxe._Int64.__Int64" params="" file="/home/travis/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<c path="haxe._Int64.___Int64"/>
		<haxe_doc>This typedef will fool `@:coreApi` into thinking that we are using
	the same underlying type, even though it might be different on
	specific platforms.</haxe_doc>
	</typedef>
	<class path="haxe._Int64.___Int64" params="" file="/home/travis/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<high public="1"><x path="haxe.Int32"/></high>
		<low public="1"><x path="haxe.Int32"/></low>
		<toString public="1" set="method" line="484">
			<f a=""><c path="String"/></f>
			<haxe_doc>We also define toString here to ensure we always get a pretty string
		when tracing or calling `Std.string`. This tends not to happen when
		`toString` is only in the abstract.</haxe_doc>
		</toString>
		<new public="1" get="inline" set="null" line="473"><f a="high:low">
	<x path="haxe.Int32"/>
	<x path="haxe.Int32"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.Int64Helper" params="" file="/home/travis/haxe/std/haxe/Int64Helper.hx">
		<parseString public="1" set="method" line="36" static="1">
			<f a="sParam">
				<c path="String"/>
				<x path="haxe.Int64"/>
			</f>
			<haxe_doc>Create `Int64` from given string.</haxe_doc>
		</parseString>
		<fromFloat public="1" set="method" line="79" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="haxe.Int64"/>
			</f>
			<haxe_doc>Create `Int64` from given float.</haxe_doc>
		</fromFloat>
		<haxe_doc>Helper for parsing to `Int64` instances.</haxe_doc>
	</class>
	<class path="haxe.Json" params="" file="/home/travis/haxe/std/haxe/Json.hx">
		<parse public="1" get="inline" set="null" line="43" static="1">
			<f a="text">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc><![CDATA[Parses given JSON-encoded `text` and returns the resulting object.

		JSON objects are parsed into anonymous structures and JSON arrays
		are parsed into `Array<Dynamic>`.

		If given `text` is not valid JSON, an exception will be thrown.

		@see https://haxe.org/manual/std-Json-parsing.html]]></haxe_doc>
		</parse>
		<stringify public="1" get="inline" set="null" line="59" static="1">
			<f a="value:?replacer:?space">
				<d/>
				<f a="key:value">
					<d/>
					<d/>
					<d/>
				</f>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes the given `value` and returns the resulting JSON string.

		If `replacer` is given and is not null, it is used to retrieve the
		actual object to be encoded. The `replacer` function takes two parameters,
		the key and the value being encoded. Initial key value is an empty string.

		If `space` is given and is not null, the result will be pretty-printed.
		Successive levels will be indented by this string.

		@see https://haxe.org/manual/std-Json-encoding.html</haxe_doc>
		</stringify>
		<haxe_doc>Cross-platform JSON API: it will automatically use the optimized native API if available.
	Use `-D haxeJSON` to force usage of the Haxe implementation even if a native API is found:
	This will provide extra encoding features such as enums (replaced by their index) and StringMaps.

	@see https://haxe.org/manual/std-Json.html</haxe_doc>
	</class>
	<class path="haxe.NativeStackTrace" params="" file="/home/travis/haxe/std/haxe/NativeStackTrace.hx" extern="1">
		<saveStack public="1" set="method" static="1"><f a="exception">
	<x path="Any"/>
	<x path="Void"/>
</f></saveStack>
		<callStack public="1" set="method" static="1"><f a=""><x path="Any"/></f></callStack>
		<exceptionStack public="1" set="method" static="1"><f a=""><x path="Any"/></f></exceptionStack>
		<toHaxe public="1" set="method" static="1">
			<f a="nativeStackTrace:?skip" v=":0">
				<x path="Any"/>
				<x path="Int"/>
				<c path="Array"><e path="haxe.StackItem"/></c>
			</f>
			<meta><m n=":value"><e>{ skip : 0 }</e></m></meta>
		</toHaxe>
		<haxe_doc>Do not use manually.</haxe_doc>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/home/travis/haxe/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<x path="Null"><c path="Array"><d/></c></x>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>`PosInfos` is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	`(..., ?pos:haxe.PosInfos)`, each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<typedef path="haxe._Rest.NativeRest" params="T" file="/home/travis/haxe/std/haxe/Rest.hx" private="1" module="haxe.Rest"><c path="Array"><c path="haxe._Rest.NativeRest.T"/></c></typedef>
	<abstract path="haxe.Rest" params="T" file="/home/travis/haxe/std/haxe/Rest.hx">
		<from><icast field="of"><c path="Array"><c path="of.T"/></c></icast></from>
		<this><t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t></this>
		<to><icast field="toArray"><c path="Array"><c path="haxe.Rest.T"/></c></icast></to>
		<haxe_doc><![CDATA[A special type that represents a "rest" function argument.
	
	The special `...` syntax can be used for convenience and improved readability:

	```haxe
	function f(...rest:Int) {
		$type(rest); // haxe.Rest<Int>
	}

	f(1, 2, 3);

	final array = [1, 2, 3];
	f(...array);
	```

	Should be used as a type for the last argument of a method, indicating that
	an arbitrary number of arguments of the given type can be passed to that method.

	Allows to use array access by index to get values of rest arguments.
	If the index exceeds the amount of rest arguments passed, the result is unspecified.]]></haxe_doc>
		<meta><m n=":coreApi"/></meta>
		<impl><class path="haxe._Rest.Rest_Impl_" params="" file="/home/travis/haxe/std/haxe/Rest.hx" private="1" module="haxe.Rest" final="1">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<haxe_doc>Amount of arguments passed as rest arguments</haxe_doc>
	</length>
	<get_length get="inline" set="null" line="35" static="1"><f a="this">
	<t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t>
	<x path="Int"/>
</f></get_length>
	<of public="1" params="T" get="inline" set="null" line="46" static="1">
		<f a="array">
			<c path="Array"><c path="of.T"/></c>
			<x path="haxe.Rest"><c path="of.T"/></x>
		</f>
		<meta><m n=":from"/></meta>
		<haxe_doc>Create rest arguments using contents of `array`.

		WARNING:
		Depending on a target platform modifying `array` after using this method
		may affect the created `Rest` instance.
		Use `Rest.of(array.copy())` to avoid that.</haxe_doc>
	</of>
	<_new get="inline" set="null" line="48" static="1">
		<f a="array">
			<c path="Array"><c path="haxe.Rest.T"/></c>
			<x path="haxe.Rest"><c path="haxe.Rest.T"/></x>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<get get="inline" set="null" line="52" static="1">
		<f a="this:index">
			<t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t>
			<x path="Int"/>
			<c path="haxe.Rest.T"/>
		</f>
		<meta><m n=":arrayAccess"/></meta>
	</get>
	<toArray public="1" get="inline" set="null" line="58" static="1">
		<f a="this">
			<t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t>
			<c path="Array"><c path="haxe.Rest.T"/></c>
		</f>
		<meta><m n=":to"/></meta>
		<haxe_doc>Creates an array containing all the values of rest arguments.</haxe_doc>
	</toArray>
	<iterator public="1" get="inline" set="null" line="61" static="1"><f a="this">
	<t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t>
	<c path="haxe.iterators.RestIterator"><c path="haxe.Rest.T"/></c>
</f></iterator>
	<keyValueIterator public="1" get="inline" set="null" line="64" static="1"><f a="this">
	<t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t>
	<c path="haxe.iterators.RestKeyValueIterator"><c path="haxe.Rest.T"/></c>
</f></keyValueIterator>
	<append public="1" set="method" line="69" static="1">
		<f a="this:item">
			<t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t>
			<c path="haxe.Rest.T"/>
			<x path="haxe.Rest"><c path="haxe.Rest.T"/></x>
		</f>
		<haxe_doc>Create a new rest arguments collection by appending `item` to this one.</haxe_doc>
	</append>
	<prepend public="1" set="method" line="78" static="1">
		<f a="this:item">
			<t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t>
			<c path="haxe.Rest.T"/>
			<x path="haxe.Rest"><c path="haxe.Rest.T"/></x>
		</f>
		<haxe_doc>Create a new rest arguments collection by prepending this one with `item`.</haxe_doc>
	</prepend>
	<toString public="1" get="inline" set="null" line="84" static="1"><f a="this">
	<t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t>
	<c path="String"/>
</f></toString>
	<meta><m n=":coreApi"/></meta>
</class></impl>
	</abstract>
	<class path="haxe._Rest.Rest_Impl_" params="" file="/home/travis/haxe/std/haxe/Rest.hx" private="1" module="haxe.Rest" final="1">
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>Amount of arguments passed as rest arguments</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="35" static="1"><f a="this">
	<t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t>
	<x path="Int"/>
</f></get_length>
		<of public="1" params="T" get="inline" set="null" line="46" static="1">
			<f a="array">
				<c path="Array"><c path="of.T"/></c>
				<x path="haxe.Rest"><c path="of.T"/></x>
			</f>
			<meta><m n=":from"/></meta>
			<haxe_doc>Create rest arguments using contents of `array`.

		WARNING:
		Depending on a target platform modifying `array` after using this method
		may affect the created `Rest` instance.
		Use `Rest.of(array.copy())` to avoid that.</haxe_doc>
		</of>
		<_new get="inline" set="null" line="48" static="1">
			<f a="array">
				<c path="Array"><c path="haxe.Rest.T"/></c>
				<x path="haxe.Rest"><c path="haxe.Rest.T"/></x>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<get get="inline" set="null" line="52" static="1">
			<f a="this:index">
				<t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t>
				<x path="Int"/>
				<c path="haxe.Rest.T"/>
			</f>
			<meta><m n=":arrayAccess"/></meta>
		</get>
		<toArray public="1" get="inline" set="null" line="58" static="1">
			<f a="this">
				<t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t>
				<c path="Array"><c path="haxe.Rest.T"/></c>
			</f>
			<meta><m n=":to"/></meta>
			<haxe_doc>Creates an array containing all the values of rest arguments.</haxe_doc>
		</toArray>
		<iterator public="1" get="inline" set="null" line="61" static="1"><f a="this">
	<t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t>
	<c path="haxe.iterators.RestIterator"><c path="haxe.Rest.T"/></c>
</f></iterator>
		<keyValueIterator public="1" get="inline" set="null" line="64" static="1"><f a="this">
	<t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t>
	<c path="haxe.iterators.RestKeyValueIterator"><c path="haxe.Rest.T"/></c>
</f></keyValueIterator>
		<append public="1" set="method" line="69" static="1">
			<f a="this:item">
				<t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t>
				<c path="haxe.Rest.T"/>
				<x path="haxe.Rest"><c path="haxe.Rest.T"/></x>
			</f>
			<haxe_doc>Create a new rest arguments collection by appending `item` to this one.</haxe_doc>
		</append>
		<prepend public="1" set="method" line="78" static="1">
			<f a="this:item">
				<t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t>
				<c path="haxe.Rest.T"/>
				<x path="haxe.Rest"><c path="haxe.Rest.T"/></x>
			</f>
			<haxe_doc>Create a new rest arguments collection by prepending this one with `item`.</haxe_doc>
		</prepend>
		<toString public="1" get="inline" set="null" line="84" static="1"><f a="this">
	<t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t>
	<c path="String"/>
</f></toString>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="haxe.crypto.Adler32" params="" file="/home/travis/haxe/std/haxe/crypto/Adler32.hx">
		<read public="1" set="method" line="60" static="1"><f a="i">
	<c path="haxe.io.Input"/>
	<c path="haxe.crypto.Adler32"/>
</f></read>
		<make public="1" set="method" line="71" static="1"><f a="b">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
</f></make>
		<a1><x path="Int"/></a1>
		<a2><x path="Int"/></a2>
		<get public="1" set="method" line="37"><f a=""><x path="Int"/></f></get>
		<update public="1" set="method" line="41"><f a="b:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></update>
		<equals public="1" set="method" line="52"><f a="a">
	<c path="haxe.crypto.Adler32"/>
	<x path="Bool"/>
</f></equals>
		<toString public="1" set="method" line="56"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Calculates the Adler32 of the given Bytes.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.io.Bytes" params="" file="/home/travis/haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="549" static="1">
			<f a="length">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Returns a new `Bytes` instance with the given `length`. The values of the
		bytes are not initialized and may not be zero.</haxe_doc>
		</alloc>
		<ofString public="1" set="method" line="580" static="1">
			<f a="s:?encoding">
				<c path="String"/>
				<e path="haxe.io.Encoding"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Returns the `Bytes` representation of the given `String`, using the
		specified encoding (UTF-8 by default).</haxe_doc>
		</ofString>
		<ofData public="1" set="method" line="656" static="1">
			<f a="b">
				<t path="haxe.io.BytesData"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Returns the `Bytes` representation of the given `BytesData`.</haxe_doc>
		</ofData>
		<ofHex public="1" set="method" line="673" static="1">
			<f a="s">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Converts the given hexadecimal `String` to `Bytes`. `s` must be a string of
		even length consisting only of hexadecimal digits. For example:
		`"0FDA14058916052309"`.</haxe_doc>
		</ofHex>
		<fastGet public="1" get="inline" set="null" line="694" static="1">
			<f a="b:pos">
				<t path="haxe.io.BytesData"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Reads the `pos`-th byte of the given `b` bytes, in the most efficient way
		possible. Behavior when reading outside of the available data is
		unspecified.</haxe_doc>
		</fastGet>
		<length public="1" set="null"><x path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<get public="1" get="inline" set="null" line="45">
			<f a="pos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the byte at index `pos`.</haxe_doc>
		</get>
		<set public="1" get="inline" set="null" line="64">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores the given byte `v` at the given position `pos`.</haxe_doc>
		</set>
		<blit public="1" set="method" line="90">
			<f a="pos:src:srcpos:len">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies `len` bytes from `src` into this instance.
		@param pos Zero-based location in `this` instance at which to start writing
			bytes.
		@param src Source `Bytes` instance from which to copy bytes.
		@param srcpos Zero-based location at `src` from which bytes will be copied.
		@param len Number of bytes to be copied.</haxe_doc>
		</blit>
		<fill public="1" set="method" line="132">
			<f a="pos:len:value">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets `len` consecutive bytes starting from index `pos` of `this` instance
		to `value`.</haxe_doc>
		</fill>
		<sub public="1" set="method" line="155">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Returns a new `Bytes` instance that contains a copy of `len` bytes of
		`this` instance, starting at index `pos`.</haxe_doc>
		</sub>
		<compare public="1" set="method" line="194">
			<f a="other">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns `0` if the bytes of `this` instance and the bytes of `other` are
		identical.

		Returns a negative value if the `length` of `this` instance is less than
		the `length` of `other`, or a positive value if the `length` of `this`
		instance is greater than the `length` of `other`.

		In case of equal `length`s, returns a negative value if the first different
		value in `other` is greater than the corresponding value in `this`
		instance; otherwise returns a positive value.</haxe_doc>
		</compare>
		<getDouble public="1" set="method" line="246">
			<f a="pos">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the IEEE double-precision value at the given position `pos` (in
		little-endian encoding). Result is unspecified if `pos` is outside the
		bounds.</haxe_doc>
		</getDouble>
		<getFloat public="1" set="method" line="269">
			<f a="pos">
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the IEEE single-precision value at the given position `pos` (in
		little-endian encoding). Result is unspecified if `pos` is outside the
		bounds.</haxe_doc>
		</getFloat>
		<setDouble public="1" set="method" line="292">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores the given IEEE double-precision value `v` at the given position
		`pos` in little-endian encoding. Result is unspecified if writing outside
		of bounds.</haxe_doc>
		</setDouble>
		<setFloat public="1" set="method" line="319">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores the given IEEE single-precision value `v` at the given position
		`pos` in little-endian encoding. Result is unspecified if writing outside
		of bounds.</haxe_doc>
		</setFloat>
		<getUInt16 public="1" get="inline" set="null" line="340">
			<f a="pos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the 16-bit unsigned integer at the given position `pos` (in
		little-endian encoding).</haxe_doc>
		</getUInt16>
		<setUInt16 public="1" get="inline" set="null" line="352">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores the given 16-bit unsigned integer `v` at the given position `pos`
		(in little-endian encoding).</haxe_doc>
		</setUInt16>
		<getInt32 public="1" get="inline" set="null" line="365">
			<f a="pos">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the 32-bit integer at the given position `pos` (in little-endian
		encoding).</haxe_doc>
		</getInt32>
		<getInt64 public="1" get="inline" set="null" line="383">
			<f a="pos">
				<x path="Int"/>
				<x path="haxe.Int64"/>
			</f>
			<haxe_doc>Returns the 64-bit integer at the given position `pos` (in little-endian
		encoding).</haxe_doc>
		</getInt64>
		<setInt32 public="1" get="inline" set="null" line="391">
			<f a="pos:v">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores the given 32-bit integer `v` at the given position `pos` (in
		little-endian encoding).</haxe_doc>
		</setInt32>
		<setInt64 public="1" get="inline" set="null" line="406">
			<f a="pos:v">
				<x path="Int"/>
				<x path="haxe.Int64"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores the given 64-bit integer `v` at the given position `pos` (in
		little-endian encoding).</haxe_doc>
		</setInt64>
		<getString public="1" set="method" line="415">
			<f a="pos:len:?encoding">
				<x path="Int"/>
				<x path="Int"/>
				<e path="haxe.io.Encoding"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the `len`-bytes long string stored at the given position `pos`,
		interpreted with the given `encoding` (UTF-8 by default).</haxe_doc>
		</getString>
		<readString public="1" get="inline" set="null" line="495">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":deprecated"><e>"readString is deprecated, use getString instead"</e></m>
				<m n=":noCompletion"/>
			</meta>
		</readString>
		<toString public="1" set="method" line="502">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a `String` representation of the bytes interpreted as UTF-8.</haxe_doc>
		</toString>
		<toHex public="1" set="method" line="524">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a hexadecimal `String` representation of the bytes of `this`
		instance.</haxe_doc>
		</toHex>
		<getData public="1" get="inline" set="null" line="541">
			<f a=""><t path="haxe.io.BytesData"/></f>
			<haxe_doc>Returns the bytes of `this` instance as `BytesData`.</haxe_doc>
		</getData>
		<new set="method" line="34"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.crypto.Base64" params="" file="/home/travis/haxe/std/haxe/crypto/Base64.hx">
		<CHARS public="1" set="null" expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;" line="29" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</e></m></meta>
		</CHARS>
		<BYTES public="1" set="null" expr="haxe.io.Bytes.ofString(CHARS)" line="30" static="1">
			<c path="haxe.io.Bytes"/>
			<meta><m n=":value"><e>haxe.io.Bytes.ofString(CHARS)</e></m></meta>
		</BYTES>
		<URL_CHARS public="1" set="null" expr="&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_&quot;" line="32" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"</e></m></meta>
		</URL_CHARS>
		<URL_BYTES public="1" set="null" expr="haxe.io.Bytes.ofString(URL_CHARS)" line="33" static="1">
			<c path="haxe.io.Bytes"/>
			<meta><m n=":value"><e>haxe.io.Bytes.ofString(URL_CHARS)</e></m></meta>
		</URL_BYTES>
		<encode public="1" set="method" line="35" static="1">
			<f a="bytes:?complement" v=":true">
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ complement : true }</e></m></meta>
		</encode>
		<decode public="1" set="method" line="48" static="1">
			<f a="str:?complement" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ complement : true }</e></m></meta>
		</decode>
		<urlEncode public="1" set="method" line="55" static="1">
			<f a="bytes:?complement" v=":false">
				<c path="haxe.io.Bytes"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ complement : false }</e></m></meta>
		</urlEncode>
		<urlDecode public="1" set="method" line="68" static="1">
			<f a="str:?complement" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ complement : false }</e></m></meta>
		</urlDecode>
		<haxe_doc>Allows one to encode/decode String and bytes using Base64 encoding.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.crypto.BaseCode" params="" file="/home/travis/haxe/std/haxe/crypto/BaseCode.hx">
		<encode public="1" set="method" line="128" static="1"><f a="s:base">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></encode>
		<decode public="1" set="method" line="133" static="1"><f a="s:base">
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
</f></decode>
		<base><c path="haxe.io.Bytes"/></base>
		<nbits><x path="Int"/></nbits>
		<tbl><c path="Array"><x path="Int"/></c></tbl>
		<encodeBytes public="1" set="method" line="44"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></encodeBytes>
		<initTable set="method" line="72"><f a=""><x path="Void"/></f></initTable>
		<decodeBytes public="1" set="method" line="81"><f a="b">
	<c path="haxe.io.Bytes"/>
	<c path="haxe.io.Bytes"/>
</f></decodeBytes>
		<encodeString public="1" set="method" line="112"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></encodeString>
		<decodeString public="1" set="method" line="120"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></decodeString>
		<new public="1" set="method" line="33"><f a="base">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Allows one to encode/decode String and bytes using a power of two base dictionary.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.crypto.Crc32" params="" file="/home/travis/haxe/std/haxe/crypto/Crc32.hx">
		<make public="1" set="method" line="59" static="1">
			<f a="data">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Calculates the CRC32 of the given data bytes</haxe_doc>
		</make>
		<crc><x path="Int"/></crc>
		<byte public="1" get="inline" set="null" line="35"><f a="b">
	<x path="Int"/>
	<x path="Void"/>
</f></byte>
		<update public="1" get="inline" set="null" line="42"><f a="b:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></update>
		<get public="1" get="inline" set="null" line="52"><f a=""><x path="Int"/></f></get>
		<new public="1" get="inline" set="null" line="31"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Calculates the Crc32 of the given Bytes.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.ds.ArraySort" params="" file="/home/travis/haxe/std/haxe/ds/ArraySort.hx">
		<sort public="1" params="T" set="method" line="42" static="1">
			<f a="a:cmp">
				<c path="Array"><c path="sort.T"/></c>
				<f a=":">
					<c path="sort.T"/>
					<c path="sort.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts Array `a` according to the comparison function `cmp`, where
		`cmp(x,y)` returns 0 if `x == y`, a positive Int if `x > y` and a
		negative Int if `x < y`.

		This operation modifies Array `a` in place.

		This operation is stable: The order of equal elements is preserved.

		If `a` or `cmp` are null, the result is unspecified.]]></haxe_doc>
		</sort>
		<rec params="T" set="method" line="46" static="1"><f a="a:cmp:from:to">
	<c path="Array"><c path="rec.T"/></c>
	<f a=":">
		<c path="rec.T"/>
		<c path="rec.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rec>
		<doMerge params="T" set="method" line="68" static="1"><f a="a:cmp:from:pivot:to:len1:len2">
	<c path="Array"><c path="doMerge.T"/></c>
	<f a=":">
		<c path="doMerge.T"/>
		<c path="doMerge.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></doMerge>
		<rotate params="T" set="method" line="94" static="1"><f a="a:cmp:from:mid:to">
	<c path="Array"><c path="rotate.T"/></c>
	<f a=":">
		<c path="rotate.T"/>
		<c path="rotate.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></rotate>
		<gcd set="method" line="115" static="1"><f a="m:n">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></gcd>
		<upper params="T" set="method" line="124" static="1"><f a="a:cmp:from:to:val">
	<c path="Array"><c path="upper.T"/></c>
	<f a=":">
		<c path="upper.T"/>
		<c path="upper.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></upper>
		<lower params="T" set="method" line="139" static="1"><f a="a:cmp:from:to:val">
	<c path="Array"><c path="lower.T"/></c>
	<f a=":">
		<c path="lower.T"/>
		<c path="lower.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lower>
		<swap params="T" set="method" line="153" static="1"><f a="a:i:j">
	<c path="Array"><c path="swap.T"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swap>
		<compare params="T" get="inline" set="null" line="159" static="1"><f a="a:cmp:i:j">
	<c path="Array"><c path="compare.T"/></c>
	<f a=":">
		<c path="compare.T"/>
		<c path="compare.T"/>
		<x path="Int"/>
	</f>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></compare>
		<haxe_doc>ArraySort provides a stable implementation of merge sort through its `sort`
	method. It should be used instead of `Array.sort` in cases where the order
	of equal elements has to be retained on all targets.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.ds.BalancedTree" params="K:V" file="/home/travis/haxe/std/haxe/ds/BalancedTree.hx">
		<implements path="haxe.IMap">
			<c path="haxe.ds.BalancedTree.K"/>
			<c path="haxe.ds.BalancedTree.V"/>
		</implements>
		<iteratorLoop params="K:V" set="method" line="172" static="1"><f a="node:acc">
	<c path="haxe.ds.TreeNode">
		<c path="iteratorLoop.K"/>
		<c path="iteratorLoop.V"/>
	</c>
	<c path="Array"><c path="iteratorLoop.V"/></c>
	<x path="Void"/>
</f></iteratorLoop>
		<root><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</c></root>
		<set public="1" set="method" line="50">
			<f a="key:value">
				<c path="haxe.ds.BalancedTree.K"/>
				<c path="haxe.ds.BalancedTree.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Binds `key` to `value`.

		If `key` is already bound to a value, that binding disappears.

		If `key` is null, the result is unspecified.</haxe_doc>
		</set>
		<get public="1" set="method" line="61">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Null"><c path="haxe.ds.BalancedTree.V"/></x>
			</f>
			<haxe_doc>Returns the value `key` is bound to.

		If `key` is not bound to any value, `null` is returned.

		If `key` is null, the result is unspecified.</haxe_doc>
		</get>
		<remove public="1" set="method" line="85">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the current binding of `key`.

		If `key` has no binding, `this` BalancedTree is unchanged and false is
		returned.

		Otherwise the binding of `key` is removed and true is returned.

		If `key` is null, the result is unspecified.</haxe_doc>
		</remove>
		<exists public="1" set="method" line="101">
			<f a="key">
				<c path="haxe.ds.BalancedTree.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `key` is bound to a value.

		This method returns true even if `key` is bound to null.

		If `key` is null, the result is unspecified.</haxe_doc>
		</exists>
		<iterator public="1" set="method" line="120">
			<f a=""><t path="Iterator"><c path="haxe.ds.BalancedTree.V"/></t></f>
			<haxe_doc>Iterates over the bound values of `this` BalancedTree.

		This operation is performed in-order.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="129">
			<f a=""><t path="KeyValueIterator">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</t></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<keys public="1" set="method" line="138">
			<f a=""><t path="Iterator"><c path="haxe.ds.BalancedTree.K"/></t></f>
			<haxe_doc>Iterates over the keys of `this` BalancedTree.

		This operation is performed in-order.</haxe_doc>
		</keys>
		<copy public="1" set="method" line="144"><f a=""><c path="haxe.ds.BalancedTree">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
</c></f></copy>
		<setLoop set="method" line="150"><f a="k:v:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></setLoop>
		<removeLoop set="method" line="163"><f a="k:node">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></removeLoop>
		<keysLoop set="method" line="180"><f a="node:acc">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="Array"><c path="haxe.ds.BalancedTree.K"/></c>
	<x path="Void"/>
</f></keysLoop>
		<merge set="method" line="188"><f a="t1:t2">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></merge>
		<minBinding set="method" line="197"><f a="t">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></minBinding>
		<removeMinBinding set="method" line="201"><f a="t">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></removeMinBinding>
		<balance set="method" line="205"><f a="l:k:v:r">
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.V"/>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
	<c path="haxe.ds.TreeNode">
		<c path="haxe.ds.BalancedTree.K"/>
		<c path="haxe.ds.BalancedTree.V"/>
	</c>
</f></balance>
		<compare set="method" line="225"><f a="k1:k2">
	<c path="haxe.ds.BalancedTree.K"/>
	<c path="haxe.ds.BalancedTree.K"/>
	<x path="Int"/>
</f></compare>
		<toString public="1" set="method" line="229"><f a=""><c path="String"/></f></toString>
		<clear public="1" set="method" line="236">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all keys from `this` BalancedTree.</haxe_doc>
		</clear>
		<new public="1" set="method" line="41">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new BalancedTree, which is initially empty.</haxe_doc>
		</new>
		<haxe_doc>BalancedTree allows key-value mapping with arbitrary keys, as long as they
	can be ordered. By default, `Reflect.compare` is used in the `compare`
	method, which can be overridden in subclasses.

	Operations have a logarithmic average and worst-case cost.

	Iteration over keys and values, using `keys` and `iterator` respectively,
	are in-order.</haxe_doc>
	</class>
	<class path="haxe.ds.TreeNode" params="K:V" file="/home/travis/haxe/std/haxe/ds/BalancedTree.hx" module="haxe.ds.BalancedTree">
		<left public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></left>
		<right public="1"><c path="haxe.ds.TreeNode">
	<c path="haxe.ds.TreeNode.K"/>
	<c path="haxe.ds.TreeNode.V"/>
</c></right>
		<key public="1"><c path="haxe.ds.TreeNode.K"/></key>
		<value public="1"><c path="haxe.ds.TreeNode.V"/></value>
		<_height><x path="Int"/></_height>
		<get_height public="1" get="inline" set="null" line="264"><f a=""><x path="Int"/></f></get_height>
		<toString public="1" set="method" line="266"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="252">
			<f a="l:k:v:r:?h" v="::::-1">
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<c path="haxe.ds.TreeNode.K"/>
				<c path="haxe.ds.TreeNode.V"/>
				<c path="haxe.ds.TreeNode">
					<c path="haxe.ds.TreeNode.K"/>
					<c path="haxe.ds.TreeNode.V"/>
				</c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ h : -1 }</e></m></meta>
		</new>
		<haxe_doc>A tree node of `haxe.ds.BalancedTree`.</haxe_doc>
	</class>
	<class path="haxe.ds.EnumValueMap" params="K:V" file="/home/travis/haxe/std/haxe/ds/EnumValueMap.hx">
		<extends path="haxe.ds.BalancedTree">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</extends>
		<implements path="haxe.IMap">
			<c path="haxe.ds.EnumValueMap.K"/>
			<c path="haxe.ds.EnumValueMap.V"/>
		</implements>
		<compare set="method" line="32" override="1"><f a="k1:k2">
	<x path="EnumValue"/>
	<x path="EnumValue"/>
	<x path="Int"/>
</f></compare>
		<compareArgs set="method" line="43"><f a="a1:a2">
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<x path="Int"/>
</f></compareArgs>
		<compareArg set="method" line="55"><f a="v1:v2">
	<d/>
	<d/>
	<x path="Int"/>
</f></compareArg>
		<copy public="1" set="method" line="65" override="1"><f a=""><c path="haxe.ds.EnumValueMap">
	<c path="haxe.ds.EnumValueMap.K"/>
	<c path="haxe.ds.EnumValueMap.V"/>
</c></f></copy>
		<new public="1" set="method" line="31"><f a=""><x path="Void"/></f></new>
		<haxe_doc>EnumValueMap allows mapping of enum value keys to arbitrary values.

	Keys are compared by value and recursively over their parameters. If any
	parameter is not an enum value, `Reflect.compare` is used to compare them.</haxe_doc>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="/home/travis/haxe/std/haxe/ds/HashMap.hx">
		<this><c path="haxe.ds._HashMap.HashMapData">
	<c path="haxe.ds.HashMap.K"/>
	<c path="haxe.ds.HashMap.V"/>
</c></this>
		<haxe_doc>HashMap allows mapping of hashable objects to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="/home/travis/haxe/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap" final="1">
	<_new public="1" get="inline" set="null" line="38" static="1">
		<f a=""><x path="haxe.ds.HashMap">
	<c path="haxe.ds.HashMap.K"/>
	<c path="haxe.ds.HashMap.V"/>
</x></f>
		<meta><m n=":noCompletion"/></meta>
		<haxe_doc>Creates a new HashMap.</haxe_doc>
	</_new>
	<set public="1" get="inline" set="null" line="45" static="1">
		<f a="this:k:v">
			<c path="haxe.ds._HashMap.HashMapData">
				<c path="haxe.ds.HashMap.K"/>
				<c path="haxe.ds.HashMap.V"/>
			</c>
			<c path="haxe.ds.HashMap.K"/>
			<c path="haxe.ds.HashMap.V"/>
			<x path="Void"/>
		</f>
		<meta><m n=":arrayAccess"/></meta>
		<haxe_doc>See `Map.set`</haxe_doc>
	</set>
	<get public="1" get="inline" set="null" line="53" static="1">
		<f a="this:k">
			<c path="haxe.ds._HashMap.HashMapData">
				<c path="haxe.ds.HashMap.K"/>
				<c path="haxe.ds.HashMap.V"/>
			</c>
			<c path="haxe.ds.HashMap.K"/>
			<x path="Null"><c path="haxe.ds.HashMap.V"/></x>
		</f>
		<meta><m n=":arrayAccess"/></meta>
		<haxe_doc>See `Map.get`</haxe_doc>
	</get>
	<exists public="1" get="inline" set="null" line="60" static="1">
		<f a="this:k">
			<c path="haxe.ds._HashMap.HashMapData">
				<c path="haxe.ds.HashMap.K"/>
				<c path="haxe.ds.HashMap.V"/>
			</c>
			<c path="haxe.ds.HashMap.K"/>
			<x path="Bool"/>
		</f>
		<haxe_doc>See `Map.exists`</haxe_doc>
	</exists>
	<remove public="1" get="inline" set="null" line="67" static="1">
		<f a="this:k">
			<c path="haxe.ds._HashMap.HashMapData">
				<c path="haxe.ds.HashMap.K"/>
				<c path="haxe.ds.HashMap.V"/>
			</c>
			<c path="haxe.ds.HashMap.K"/>
			<x path="Bool"/>
		</f>
		<haxe_doc>See `Map.remove`</haxe_doc>
	</remove>
	<keys public="1" get="inline" set="null" line="75" static="1">
		<f a="this">
			<c path="haxe.ds._HashMap.HashMapData">
				<c path="haxe.ds.HashMap.K"/>
				<c path="haxe.ds.HashMap.V"/>
			</c>
			<t path="Iterator"><c path="haxe.ds.HashMap.K"/></t>
		</f>
		<haxe_doc>See `Map.keys`</haxe_doc>
	</keys>
	<copy public="1" set="method" line="82" static="1">
		<f a="this">
			<c path="haxe.ds._HashMap.HashMapData">
				<c path="haxe.ds.HashMap.K"/>
				<c path="haxe.ds.HashMap.V"/>
			</c>
			<x path="haxe.ds.HashMap">
				<c path="haxe.ds.HashMap.K"/>
				<c path="haxe.ds.HashMap.V"/>
			</x>
		</f>
		<haxe_doc>See `Map.copy`</haxe_doc>
	</copy>
	<iterator public="1" get="inline" set="null" line="92" static="1">
		<f a="this">
			<c path="haxe.ds._HashMap.HashMapData">
				<c path="haxe.ds.HashMap.K"/>
				<c path="haxe.ds.HashMap.V"/>
			</c>
			<t path="Iterator"><c path="haxe.ds.HashMap.V"/></t>
		</f>
		<haxe_doc>See `Map.iterator`</haxe_doc>
	</iterator>
	<keyValueIterator public="1" get="inline" set="null" line="99" static="1">
		<f a="this">
			<c path="haxe.ds._HashMap.HashMapData">
				<c path="haxe.ds.HashMap.K"/>
				<c path="haxe.ds.HashMap.V"/>
			</c>
			<c path="haxe.iterators.HashMapKeyValueIterator">
				<c path="haxe.ds.HashMap.K"/>
				<c path="haxe.ds.HashMap.V"/>
			</c>
		</f>
		<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
	</keyValueIterator>
	<clear public="1" get="inline" set="null" line="106" static="1">
		<f a="this">
			<c path="haxe.ds._HashMap.HashMapData">
				<c path="haxe.ds.HashMap.K"/>
				<c path="haxe.ds.HashMap.V"/>
			</c>
			<x path="Void"/>
		</f>
		<haxe_doc>See `Map.clear`</haxe_doc>
	</clear>
</class></impl>
	</abstract>
	<class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="/home/travis/haxe/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap" final="1">
		<_new public="1" get="inline" set="null" line="38" static="1">
			<f a=""><x path="haxe.ds.HashMap">
	<c path="haxe.ds.HashMap.K"/>
	<c path="haxe.ds.HashMap.V"/>
</x></f>
			<meta><m n=":noCompletion"/></meta>
			<haxe_doc>Creates a new HashMap.</haxe_doc>
		</_new>
		<set public="1" get="inline" set="null" line="45" static="1">
			<f a="this:k:v">
				<c path="haxe.ds._HashMap.HashMapData">
					<c path="haxe.ds.HashMap.K"/>
					<c path="haxe.ds.HashMap.V"/>
				</c>
				<c path="haxe.ds.HashMap.K"/>
				<c path="haxe.ds.HashMap.V"/>
				<x path="Void"/>
			</f>
			<meta><m n=":arrayAccess"/></meta>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" get="inline" set="null" line="53" static="1">
			<f a="this:k">
				<c path="haxe.ds._HashMap.HashMapData">
					<c path="haxe.ds.HashMap.K"/>
					<c path="haxe.ds.HashMap.V"/>
				</c>
				<c path="haxe.ds.HashMap.K"/>
				<x path="Null"><c path="haxe.ds.HashMap.V"/></x>
			</f>
			<meta><m n=":arrayAccess"/></meta>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" get="inline" set="null" line="60" static="1">
			<f a="this:k">
				<c path="haxe.ds._HashMap.HashMapData">
					<c path="haxe.ds.HashMap.K"/>
					<c path="haxe.ds.HashMap.V"/>
				</c>
				<c path="haxe.ds.HashMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" get="inline" set="null" line="67" static="1">
			<f a="this:k">
				<c path="haxe.ds._HashMap.HashMapData">
					<c path="haxe.ds.HashMap.K"/>
					<c path="haxe.ds.HashMap.V"/>
				</c>
				<c path="haxe.ds.HashMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" get="inline" set="null" line="75" static="1">
			<f a="this">
				<c path="haxe.ds._HashMap.HashMapData">
					<c path="haxe.ds.HashMap.K"/>
					<c path="haxe.ds.HashMap.V"/>
				</c>
				<t path="Iterator"><c path="haxe.ds.HashMap.K"/></t>
			</f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<copy public="1" set="method" line="82" static="1">
			<f a="this">
				<c path="haxe.ds._HashMap.HashMapData">
					<c path="haxe.ds.HashMap.K"/>
					<c path="haxe.ds.HashMap.V"/>
				</c>
				<x path="haxe.ds.HashMap">
					<c path="haxe.ds.HashMap.K"/>
					<c path="haxe.ds.HashMap.V"/>
				</x>
			</f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<iterator public="1" get="inline" set="null" line="92" static="1">
			<f a="this">
				<c path="haxe.ds._HashMap.HashMapData">
					<c path="haxe.ds.HashMap.K"/>
					<c path="haxe.ds.HashMap.V"/>
				</c>
				<t path="Iterator"><c path="haxe.ds.HashMap.V"/></t>
			</f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="99" static="1">
			<f a="this">
				<c path="haxe.ds._HashMap.HashMapData">
					<c path="haxe.ds.HashMap.K"/>
					<c path="haxe.ds.HashMap.V"/>
				</c>
				<c path="haxe.iterators.HashMapKeyValueIterator">
					<c path="haxe.ds.HashMap.K"/>
					<c path="haxe.ds.HashMap.V"/>
				</c>
			</f>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<clear public="1" get="inline" set="null" line="106" static="1">
			<f a="this">
				<c path="haxe.ds._HashMap.HashMapData">
					<c path="haxe.ds.HashMap.K"/>
					<c path="haxe.ds.HashMap.V"/>
				</c>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
	</class>
	<class path="haxe.ds._HashMap.HashMapData" params="K:V" file="/home/travis/haxe/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap">
		<keys public="1"><c path="haxe.ds.IntMap"><c path="haxe.ds._HashMap.HashMapData.K"/></c></keys>
		<values public="1"><c path="haxe.ds.IntMap"><c path="haxe.ds._HashMap.HashMapData.V"/></c></values>
		<new public="1" get="inline" set="null" line="116"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="haxe.ds.IntMap" params="T" file="/home/travis/haxe/std/haxe/ds/IntMap.hx" extern="1">
		<implements path="haxe.IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<x path="Null"><c path="haxe.ds.IntMap.T"/></x>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><x path="Int"/></t></f>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.IntMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" set="method">
			<f a=""><t path="KeyValueIterator">
	<x path="Int"/>
	<c path="haxe.ds.IntMap.T"/>
</t></f>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method">
			<f a=""><c path="haxe.ds.IntMap"><c path="haxe.ds.IntMap.T"/></c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.ds.List" params="T" file="/home/travis/haxe/std/haxe/ds/List.hx">
		<h><c path="haxe.ds._List.ListNode"><c path="haxe.ds.List.T"/></c></h>
		<q><c path="haxe.ds._List.ListNode"><c path="haxe.ds.List.T"/></c></q>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<add public="1" set="method" line="53">
			<f a="item">
				<c path="haxe.ds.List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the end of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</add>
		<push public="1" set="method" line="68">
			<f a="item">
				<c path="haxe.ds.List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the beginning of `this` List.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<first public="1" set="method" line="81">
			<f a=""><x path="Null"><c path="haxe.ds.List.T"/></x></f>
			<haxe_doc>Returns the first element of `this` List, or null if no elements exist.

		This function does not modify `this` List.</haxe_doc>
		</first>
		<last public="1" set="method" line="90">
			<f a=""><x path="Null"><c path="haxe.ds.List.T"/></x></f>
			<haxe_doc>Returns the last element of `this` List, or null if no elements exist.

		This function does not modify `this` List.</haxe_doc>
		</last>
		<pop public="1" set="method" line="99">
			<f a=""><x path="Null"><c path="haxe.ds.List.T"/></x></f>
			<haxe_doc>Returns the first element of `this` List, or null if no elements exist.

		The element is removed from `this` List.</haxe_doc>
		</pop>
		<isEmpty public="1" set="method" line="113">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Tells if `this` List is empty.</haxe_doc>
		</isEmpty>
		<clear public="1" set="method" line="123">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Empties `this` List.

		This function does not traverse the elements, but simply sets the
		internal references to null and `this.length` to 0.</haxe_doc>
		</clear>
		<remove public="1" set="method" line="137">
			<f a="v">
				<c path="haxe.ds.List.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `v` in `this` List.

		If `v` is found by checking standard equality, it is removed from `this`
		List and the function returns true.

		Otherwise, false is returned.</haxe_doc>
		</remove>
		<iterator public="1" get="inline" set="null" line="160">
			<f a=""><c path="haxe.ds._List.ListIterator"><c path="haxe.ds.List.T"/></c></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="167">
			<f a=""><c path="haxe.ds._List.ListKeyValueIterator"><c path="haxe.ds.List.T"/></c></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an iterator of the List indices and values.</haxe_doc>
		</keyValueIterator>
		<toString public="1" set="method" line="177">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` List.

		The result is enclosed in { } with the individual elements being
		separated by a comma.</haxe_doc>
		</toString>
		<join public="1" set="method" line="198">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` List, with `sep` separating
		each element.</haxe_doc>
		</join>
		<filter public="1" set="method" line="217">
			<f a="f">
				<f a="">
					<c path="haxe.ds.List.T"/>
					<x path="Bool"/>
				</f>
				<c path="haxe.ds.List"><c path="haxe.ds.List.T"/></c>
			</f>
			<haxe_doc>Returns a list filtered with `f`. The returned list will contain all
		elements for which `f(x) == true`.</haxe_doc>
		</filter>
		<map public="1" params="X" set="method" line="233">
			<f a="f">
				<f a="">
					<c path="haxe.ds.List.T"/>
					<c path="map.X"/>
				</f>
				<c path="haxe.ds.List"><c path="map.X"/></c>
			</f>
			<haxe_doc>Returns a new list where all elements have been converted by the
		function `f`.</haxe_doc>
		</map>
		<new public="1" set="method" line="44">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of element container objects
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole list content every time.

	@see https://haxe.org/manual/std-List.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.ds._List.ListNode" params="T" file="/home/travis/haxe/std/haxe/ds/List.hx" private="1" module="haxe.ds.List">
		<create public="1" params="T" get="inline" set="null" line="271" static="1"><f a="item:next">
	<c path="create.T"/>
	<c path="haxe.ds._List.ListNode"><c path="create.T"/></c>
	<c path="haxe.ds._List.ListNode"><c path="create.T"/></c>
</f></create>
		<item public="1"><c path="haxe.ds._List.ListNode.T"/></item>
		<next public="1"><c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c></next>
		<new public="1" set="method" line="266"><f a="item:next">
	<c path="haxe.ds._List.ListNode.T"/>
	<c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListNode.T"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.ds._List.ListIterator" params="T" file="/home/travis/haxe/std/haxe/ds/List.hx" private="1" module="haxe.ds.List">
		<head><c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListIterator.T"/></c></head>
		<hasNext public="1" get="inline" set="null" line="284"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="288"><f a=""><c path="haxe.ds._List.ListIterator.T"/></f></next>
		<new public="1" get="inline" set="null" line="280"><f a="head">
	<c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListIterator.T"/></c>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.ds._List.ListKeyValueIterator" params="T" file="/home/travis/haxe/std/haxe/ds/List.hx" private="1" module="haxe.ds.List">
		<idx><x path="Int"/></idx>
		<head><c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListKeyValueIterator.T"/></c></head>
		<hasNext public="1" get="inline" set="null" line="304"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="308"><f a=""><a>
	<value><c path="haxe.ds._List.ListKeyValueIterator.T"/></value>
	<key><x path="Int"/></key>
</a></f></next>
		<new public="1" get="inline" set="null" line="299"><f a="head">
	<c path="haxe.ds._List.ListNode"><c path="haxe.ds._List.ListKeyValueIterator.T"/></c>
	<x path="Void"/>
</f></new>
	</class>
	<abstract path="haxe.ds.Map" params="K:V" file="/home/travis/haxe/std/haxe/ds/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="haxe.IMap">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `[key1 => value1, key2 => value2]` syntax.

	Map is an abstract type, it is not available at runtime.

	@see https://haxe.org/manual/std-Map.html]]></haxe_doc>
		<meta>
			<m n=":transitive"/>
			<m n=":multiType"><e>@:followWithAbstracts K</e></m>
		</meta>
		<impl><class path="haxe.ds._Map.Map_Impl_" params="" file="/home/travis/haxe/std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map" final="1">
	<_new public="1" set="method" static="1">
		<f a=""><x path="haxe.ds.Map">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</x></f>
		<meta><m n=":noCompletion"/></meta>
		<haxe_doc>Creates a new Map.

		This becomes a constructor call to one of the specialization types in
		the output. The rules for that are as follows:

		1. if `K` is a `String`, `haxe.ds.StringMap` is used
		2. if `K` is an `Int`, `haxe.ds.IntMap` is used
		3. if `K` is an `EnumValue`, `haxe.ds.EnumValueMap` is used
		4. if `K` is any other class or structure, `haxe.ds.ObjectMap` is used
		5. if `K` is any other type, it causes a compile-time error

		(Cpp) Map does not use weak keys on `ObjectMap` by default.</haxe_doc>
	</_new>
	<set public="1" get="inline" set="null" line="76" static="1">
		<f a="this:key:value">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<c path="haxe.ds.Map.K"/>
			<c path="haxe.ds.Map.V"/>
			<x path="Void"/>
		</f>
		<haxe_doc>Maps `key` to `value`.

		If `key` already has a mapping, the previous value disappears.

		If `key` is `null`, the result is unspecified.</haxe_doc>
	</set>
	<get public="1" get="inline" set="null" line="94" static="1">
		<f a="this:key">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<c path="haxe.ds.Map.K"/>
			<x path="Null"><c path="haxe.ds.Map.V"/></x>
		</f>
		<meta><m n=":arrayAccess"/></meta>
		<haxe_doc>Returns the current mapping of `key`.

		If no such mapping exists, `null` is returned.

		Note that a check like `map.get(key) == null` can hold for two reasons:

		1. the map has no mapping for `key`
		2. the map has a mapping with a value of `null`

		If it is important to distinguish these cases, `exists()` should be
		used.

		If `key` is `null`, the result is unspecified.</haxe_doc>
	</get>
	<exists public="1" get="inline" set="null" line="102" static="1">
		<f a="this:key">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<c path="haxe.ds.Map.K"/>
			<x path="Bool"/>
		</f>
		<haxe_doc>Returns true if `key` has a mapping, false otherwise.

		If `key` is `null`, the result is unspecified.</haxe_doc>
	</exists>
	<remove public="1" get="inline" set="null" line="111" static="1">
		<f a="this:key">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<c path="haxe.ds.Map.K"/>
			<x path="Bool"/>
		</f>
		<haxe_doc>Removes the mapping of `key` and returns true if such a mapping existed,
		false otherwise.

		If `key` is `null`, the result is unspecified.</haxe_doc>
	</remove>
	<keys public="1" get="inline" set="null" line="118" static="1">
		<f a="this">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<t path="Iterator"><c path="haxe.ds.Map.K"/></t>
		</f>
		<haxe_doc>Returns an Iterator over the keys of `this` Map.

		The order of keys is undefined.</haxe_doc>
	</keys>
	<iterator public="1" get="inline" set="null" line="127" static="1">
		<f a="this">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<t path="Iterator"><c path="haxe.ds.Map.V"/></t>
		</f>
		<haxe_doc>Returns an Iterator over the values of `this` Map.

		The order of values is undefined.</haxe_doc>
	</iterator>
	<keyValueIterator public="1" get="inline" set="null" line="136" static="1">
		<f a="this">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<t path="KeyValueIterator">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</t>
		</f>
		<haxe_doc>Returns an Iterator over the keys and values of `this` Map.

		The order of values is undefined.</haxe_doc>
	</keyValueIterator>
	<copy public="1" get="inline" set="null" line="145" static="1">
		<f a="this">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<x path="haxe.ds.Map">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</x>
		</f>
		<haxe_doc>Returns a shallow copy of `this` map.

		The order of values is undefined.</haxe_doc>
	</copy>
	<toString public="1" get="inline" set="null" line="154" static="1">
		<f a="this">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<c path="String"/>
		</f>
		<haxe_doc>Returns a String representation of `this` Map.

		The exact representation depends on the platform and key-type.</haxe_doc>
	</toString>
	<clear public="1" get="inline" set="null" line="161" static="1">
		<f a="this">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<x path="Void"/>
		</f>
		<haxe_doc>Removes all keys from `this` Map.</haxe_doc>
	</clear>
	<arrayWrite public="1" get="inline" set="null" line="165" static="1">
		<f a="this:k:v">
			<c path="haxe.IMap">
				<c path="haxe.ds.Map.K"/>
				<c path="haxe.ds.Map.V"/>
			</c>
			<c path="haxe.ds.Map.K"/>
			<c path="haxe.ds.Map.V"/>
			<c path="haxe.ds.Map.V"/>
		</f>
		<meta>
			<m n=":arrayAccess"/>
			<m n=":noCompletion"/>
		</meta>
	</arrayWrite>
	<toStringMap params="K:V" get="inline" set="null" line="170" static="1">
		<f a="t">
			<c path="haxe.IMap">
				<c path="toStringMap.K"/>
				<c path="toStringMap.V"/>
			</c>
			<c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c>
		</f>
		<meta><m n=":to"/></meta>
	</toStringMap>
	<toIntMap params="K:V" get="inline" set="null" line="174" static="1">
		<f a="t">
			<c path="haxe.IMap">
				<c path="toIntMap.K"/>
				<c path="toIntMap.V"/>
			</c>
			<c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c>
		</f>
		<meta><m n=":to"/></meta>
	</toIntMap>
	<toEnumValueMapMap params="K:V" get="inline" set="null" line="178" static="1">
		<f a="t">
			<c path="haxe.IMap">
				<c path="toEnumValueMapMap.K"/>
				<c path="toEnumValueMapMap.V"/>
			</c>
			<c path="haxe.ds.EnumValueMap">
				<c path="toEnumValueMapMap.K"/>
				<c path="toEnumValueMapMap.V"/>
			</c>
		</f>
		<meta><m n=":to"/></meta>
	</toEnumValueMapMap>
	<toObjectMap params="K:V" get="inline" set="null" line="182" static="1">
		<f a="t">
			<c path="haxe.IMap">
				<c path="toObjectMap.K"/>
				<c path="toObjectMap.V"/>
			</c>
			<c path="haxe.ds.ObjectMap">
				<c path="toObjectMap.K"/>
				<c path="toObjectMap.V"/>
			</c>
		</f>
		<meta><m n=":to"/></meta>
	</toObjectMap>
	<fromStringMap params="V" get="inline" set="null" line="186" static="1">
		<f a="map">
			<c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c>
			<x path="haxe.ds.Map">
				<c path="String"/>
				<c path="fromStringMap.V"/>
			</x>
		</f>
		<meta><m n=":from"/></meta>
	</fromStringMap>
	<fromIntMap params="V" get="inline" set="null" line="190" static="1">
		<f a="map">
			<c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c>
			<x path="haxe.ds.Map">
				<x path="Int"/>
				<c path="fromIntMap.V"/>
			</x>
		</f>
		<meta><m n=":from"/></meta>
	</fromIntMap>
	<fromObjectMap params="K:V" get="inline" set="null" line="194" static="1">
		<f a="map">
			<c path="haxe.ds.ObjectMap">
				<c path="fromObjectMap.K"/>
				<c path="fromObjectMap.V"/>
			</c>
			<x path="haxe.ds.Map">
				<c path="fromObjectMap.K"/>
				<c path="fromObjectMap.V"/>
			</x>
		</f>
		<meta><m n=":from"/></meta>
	</fromObjectMap>
</class></impl>
	</abstract>
	<class path="haxe.ds.ObjectMap" params="K:V" file="/home/travis/haxe/std/haxe/ds/ObjectMap.hx" extern="1">
		<implements path="haxe.IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Null"><c path="haxe.ds.ObjectMap.V"/></x>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.V"/></t></f>
			<haxe_doc>See `Map.iterator`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" set="method">
			<f a=""><t path="KeyValueIterator">
	<c path="haxe.ds.ObjectMap.K"/>
	<c path="haxe.ds.ObjectMap.V"/>
</t></f>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method">
			<f a=""><c path="haxe.ds.ObjectMap">
	<c path="haxe.ds.ObjectMap.K"/>
	<c path="haxe.ds.ObjectMap.V"/>
</c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.

	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
	</class>
	<abstract path="haxe.ds.ReadOnlyArray" params="T" file="/home/travis/haxe/std/haxe/ds/ReadOnlyArray.hx">
		<from><icast><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></icast></from>
		<this><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></this>
		<to><icast><t path="Iterable"><c path="haxe.ds.ReadOnlyArray.T"/></t></icast></to>
		<haxe_doc>`ReadOnlyArray` is an abstract over an ordinary `Array` which only exposes
	APIs that don't modify the instance, hence "read-only".

	Note that this doesn't necessarily mean that the instance is *immutable*.
	Other code holding a reference to the underlying `Array` can still modify it,
	and the reference can be obtained with a `cast`.</haxe_doc>
		<meta><m n=":forward">
	<e>copy</e>
	<e>filter</e>
	<e>indexOf</e>
	<e>iterator</e>
	<e>keyValueIterator</e>
	<e>join</e>
	<e>lastIndexOf</e>
	<e>map</e>
	<e>slice</e>
	<e>contains</e>
	<e>toString</e>
</m></meta>
		<impl><class path="haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_" params="" file="/home/travis/haxe/std/haxe/ds/ReadOnlyArray.hx" private="1" module="haxe.ds.ReadOnlyArray" final="1">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<haxe_doc>The length of `this` Array.</haxe_doc>
	</length>
	<get_length get="inline" set="null" line="41" static="1"><f a="this">
	<c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c>
	<x path="Int"/>
</f></get_length>
	<get get="inline" set="null" line="44" static="1">
		<f a="this:i">
			<c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c>
			<x path="Int"/>
			<c path="haxe.ds.ReadOnlyArray.T"/>
		</f>
		<meta><m n=":arrayAccess"/></meta>
	</get>
	<concat public="1" get="inline" set="null" line="59" static="1">
		<f a="this:a">
			<c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c>
			<x path="haxe.ds.ReadOnlyArray"><c path="haxe.ds.ReadOnlyArray.T"/></x>
			<c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c>
		</f>
		<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
	</concat>
</class></impl>
	</abstract>
	<class path="haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_" params="" file="/home/travis/haxe/std/haxe/ds/ReadOnlyArray.hx" private="1" module="haxe.ds.ReadOnlyArray" final="1">
		<length public="1" get="accessor" set="null" static="1">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="41" static="1"><f a="this">
	<c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c>
	<x path="Int"/>
</f></get_length>
		<get get="inline" set="null" line="44" static="1">
			<f a="this:i">
				<c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c>
				<x path="Int"/>
				<c path="haxe.ds.ReadOnlyArray.T"/>
			</f>
			<meta><m n=":arrayAccess"/></meta>
		</get>
		<concat public="1" get="inline" set="null" line="59" static="1">
			<f a="this:a">
				<c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c>
				<x path="haxe.ds.ReadOnlyArray"><c path="haxe.ds.ReadOnlyArray.T"/></x>
				<c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
	</class>
	<class path="haxe.ds.WeakMap" params="K:V" file="/home/travis/haxe/std/haxe/ds/WeakMap.hx">
		<implements path="haxe.IMap">
			<c path="haxe.ds.WeakMap.K"/>
			<c path="haxe.ds.WeakMap.V"/>
		</implements>
		<set public="1" set="method" line="45">
			<f a="key:value">
				<c path="haxe.ds.WeakMap.K"/>
				<c path="haxe.ds.WeakMap.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method" line="50">
			<f a="key">
				<c path="haxe.ds.WeakMap.K"/>
				<x path="Null"><c path="haxe.ds.WeakMap.V"/></x>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method" line="57">
			<f a="key">
				<c path="haxe.ds.WeakMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method" line="64">
			<f a="key">
				<c path="haxe.ds.WeakMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method" line="71">
			<f a=""><t path="Iterator"><c path="haxe.ds.WeakMap.K"/></t></f>
			<haxe_doc>See `Map.keys`</haxe_doc>
		</keys>
		<iterator public="1" set="method" line="78">
			<f a=""><t path="Iterator"><c path="haxe.ds.WeakMap.V"/></t></f>
			<haxe_doc>See `Map.iterator`</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="85">
			<f a=""><t path="KeyValueIterator">
	<c path="haxe.ds.WeakMap.K"/>
	<c path="haxe.ds.WeakMap.V"/>
</t></f>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method" line="92">
			<f a=""><c path="haxe.ds.WeakMap">
	<c path="haxe.ds.WeakMap.K"/>
	<c path="haxe.ds.WeakMap.V"/>
</c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<toString public="1" set="method" line="99">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<clear public="1" set="method" line="106">
			<f a=""><x path="Void"/></f>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
		<new public="1" set="method" line="38">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new WeakMap.</haxe_doc>
		</new>
		<haxe_doc>WeakMap allows mapping of object keys to arbitrary values.

	The keys are considered to be weak references on static targets.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
	</class>
	<class path="haxe.exceptions.PosException" params="" file="/home/travis/haxe/std/haxe/exceptions/PosException.hx">
		<extends path="haxe.Exception"/>
		<posInfos final="1" public="1">
			<t path="haxe.PosInfos"/>
			<haxe_doc>Position where this exception was created.</haxe_doc>
		</posInfos>
		<toString public="1" set="method" line="24" override="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns exception message.</haxe_doc>
		</toString>
		<new public="1" set="method" line="12"><f a="message:?previous:?pos">
	<c path="String"/>
	<c path="haxe.Exception"/>
	<x path="Null"><t path="haxe.PosInfos"/></x>
	<x path="Void"/>
</f></new>
		<haxe_doc>An exception that carry position information of a place where it was created.</haxe_doc>
	</class>
	<class path="haxe.exceptions.NotImplementedException" params="" file="/home/travis/haxe/std/haxe/exceptions/NotImplementedException.hx">
		<extends path="haxe.exceptions.PosException"/>
		<new public="1" set="method" line="7">
			<f a="?message:?previous:?pos" v="&quot;Not implemented&quot;::">
				<c path="String"/>
				<c path="haxe.Exception"/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ message : "Not implemented" }</e></m></meta>
		</new>
		<haxe_doc>An exception that is thrown when requested function or operation does not have an implementation.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="haxe.extern.EitherType" params="T1:T2" file="/home/travis/haxe/std/haxe/extern/EitherType.hx">
		<from>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
		</from>
		<this><d/></this>
		<to>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
		</to>
		<haxe_doc><![CDATA[An abstract type allowing values to be either of `T1` or `T2` type.
	Supports implicit casts from/to either types.

	It is useful for interfacing with external code on dynamic platforms
	such as JavaScript or Python.

	Otherwise, use of this type is discouraged.

	@see <https://haxe.org/manual/lf-externs.html>]]></haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="haxe.extern._EitherType.EitherType_Impl_" params="" file="/home/travis/haxe/std/haxe/extern/EitherType.hx" private="1" module="haxe.extern.EitherType" extern="1" final="1"/></impl>
	</abstract>
	<class path="haxe.extern._EitherType.EitherType_Impl_" params="" file="/home/travis/haxe/std/haxe/extern/EitherType.hx" private="1" module="haxe.extern.EitherType" extern="1" final="1"/>
	<typedef path="haxe.extern.Rest" params="T" file="/home/travis/haxe/std/haxe/extern/Rest.hx">
		<x path="haxe.Rest"><c path="haxe.extern.Rest.T"/></x>
		<haxe_doc><![CDATA[DEPRECATED: use haxe.Rest instead.
	
	A special type that represents "rest" function argument.
	Should be used as a type for the last argument of an extern method,
	representing that arbitrary number of arguments of given type can be
	passed to that method.
	@see <https://haxe.org/manual/lf-externs.html>]]></haxe_doc>
	</typedef>
	<class path="haxe.format.JsonParser" params="" file="/home/travis/haxe/std/haxe/format/JsonParser.hx">
		<parse public="1" get="inline" set="null" line="44" static="1">
			<f a="str">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc><![CDATA[Parses given JSON-encoded `str` and returns the resulting object.

		JSON objects are parsed into anonymous structures and JSON arrays
		are parsed into `Array<Dynamic>`.

		If given `str` is not valid JSON, an exception will be thrown.

		If `str` is null, the result is unspecified.]]></haxe_doc>
		</parse>
		<str><c path="String"/></str>
		<pos><x path="Int"/></pos>
		<doParse set="method" line="56"><f a=""><d/></f></doParse>
		<parseRec set="method" line="70"><f a=""><d/></f></parseRec>
		<parseString set="method" line="152"><f a=""><c path="String"/></f></parseString>
		<parseNumber get="inline" set="null" line="256"><f a="c">
	<x path="Int"/>
	<d/>
</f></parseNumber>
		<nextChar get="inline" set="null" line="312"><f a=""><x path="Int"/></f></nextChar>
		<invalidChar set="method" line="316"><f a=""><x path="Void"/></f></invalidChar>
		<invalidNumber set="method" line="321"><f a="start">
	<x path="Int"/>
	<x path="Void"/>
</f></invalidNumber>
		<new set="method" line="51"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An implementation of JSON parser in Haxe.

	This class is used by `haxe.Json` when native JSON implementation
	is not available.

	@see https://haxe.org/manual/std-Json-parsing.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.format.JsonPrinter" params="" file="/home/travis/haxe/std/haxe/format/JsonPrinter.hx">
		<print public="1" set="method" line="44" static="1">
			<f a="o:?replacer:?space">
				<d/>
				<f a="key:value">
					<d/>
					<d/>
					<d/>
				</f>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encodes `o`'s value and returns the resulting JSON string.

		If `replacer` is given and is not null, it is used to retrieve
		actual object to be encoded. The `replacer` function takes two parameters,
		the key and the value being encoded. Initial key value is an empty string.

		If `space` is given and is not null, the result will be pretty-printed.
		Successive levels will be indented by this string.</haxe_doc>
		</print>
		<buf><c path="StringBuf"/></buf>
		<replacer><f a="key:value">
	<d/>
	<d/>
	<d/>
</f></replacer>
		<indent><c path="String"/></indent>
		<pretty><x path="Bool"/></pretty>
		<nind><x path="Int"/></nind>
		<ipad get="inline" set="null" line="71"><f a=""><x path="Void"/></f></ipad>
		<newl get="inline" set="null" line="76"><f a=""><x path="Void"/></f></newl>
		<write set="method" line="81"><f a="k:v">
	<d/>
	<d/>
	<x path="Void"/>
</f></write>
		<addChar get="inline" set="null" line="140"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></addChar>
		<add get="inline" set="null" line="148"><f a="v">
	<c path="String"/>
	<x path="Void"/>
</f></add>
		<classString set="method" line="157"><f a="v">
	<d/>
	<x path="Void"/>
</f></classString>
		<objString get="inline" set="null" line="161"><f a="v">
	<d/>
	<x path="Void"/>
</f></objString>
		<fieldsString set="method" line="165"><f a="v:fields">
	<d/>
	<c path="Array"><c path="String"/></c>
	<x path="Void"/>
</f></fieldsString>
		<quote set="method" line="196"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></quote>
		<new set="method" line="56"><f a="replacer:space">
	<f a="key:value">
		<d/>
		<d/>
		<d/>
	</f>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An implementation of JSON printer in Haxe.

	This class is used by `haxe.Json` when native JSON implementation
	is not available.

	@see https://haxe.org/manual/std-Json-encoding.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="haxe.http._HttpBase.StringKeyValue" params="" file="/home/travis/haxe/std/haxe/http/HttpBase.hx" private="1" module="haxe.http.HttpBase"><a>
	<value><c path="String"/></value>
	<name><c path="String"/></name>
</a></typedef>
	<class path="haxe.http.HttpBase" params="" file="/home/travis/haxe/std/haxe/http/HttpBase.hx">
		<url public="1">
			<c path="String"/>
			<haxe_doc>The url of `this` request. It is used only by the `request()` method and
		can be changed in order to send the same request to different target
		Urls.</haxe_doc>
		</url>
		<responseData public="1" get="accessor" set="null"><x path="Null"><c path="String"/></x></responseData>
		<responseBytes public="1" set="null"><x path="Null"><c path="haxe.io.Bytes"/></x></responseBytes>
		<responseAsString><x path="Null"><c path="String"/></x></responseAsString>
		<postData><x path="Null"><c path="String"/></x></postData>
		<postBytes><x path="Null"><c path="haxe.io.Bytes"/></x></postBytes>
		<headers><c path="Array"><t path="haxe.http._HttpBase.StringKeyValue"/></c></headers>
		<params><c path="Array"><t path="haxe.http._HttpBase.StringKeyValue"/></c></params>
		<emptyOnData final="1"><f a="">
	<c path="String"/>
	<x path="Void"/>
</f></emptyOnData>
		<setHeader public="1" set="method" line="85">
			<f a="name:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the header identified as `name` to value `value`.

		If `name` or `value` are null, the result is unspecified.

		This method provides a fluent interface.</haxe_doc>
		</setHeader>
		<addHeader public="1" set="method" line="98"><f a="header:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></addHeader>
		<setParameter public="1" set="method" line="112">
			<f a="name:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the parameter identified as `name` to value `value`.

		If `name` or `value` are null, the result is unspecified.

		This method provides a fluent interface.</haxe_doc>
		</setParameter>
		<addParameter public="1" set="method" line="125"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></addParameter>
		<setPostData public="1" set="method" line="142">
			<f a="data">
				<x path="Null"><c path="String"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the post data of `this` Http request to `data` string.

		There can only be one post data per request. Subsequent calls to
		this method or to `setPostBytes()` overwrite the previously set value.

		If `data` is null, the post data is considered to be absent.

		This method provides a fluent interface.</haxe_doc>
		</setPostData>
		<setPostBytes public="1" set="method" line="160">
			<f a="data">
				<x path="Null"><c path="haxe.io.Bytes"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the post data of `this` Http request to `data` bytes.

		There can only be one post data per request. Subsequent calls to
		this method or to `setPostData()` overwrite the previously set value.

		If `data` is null, the post data is considered to be absent.

		This method provides a fluent interface.</haxe_doc>
		</setPostBytes>
		<request public="1" set="method" line="185">
			<f a="?post">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sends `this` Http request to the Url specified by `this.url`.

		If `post` is true, the request is sent as POST request, otherwise it is
		sent as GET request.

		Depending on the outcome of the request, this method calls the
		`onStatus()`, `onError()`, `onData()` or `onBytes()` callback functions.

		If `this.url` is null, the result is unspecified.

		If `this.url` is an invalid or inaccessible Url, the `onError()` callback
		function is called.

		[js] If `this.async` is false, the callback functions are called before
		this method returns.</haxe_doc>
		</request>
		<onData public="1" set="dynamic" line="196">
			<f a="data">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method is called upon a successful request, with `data` containing
		the result String.

		The intended usage is to bind it to a custom function:
		`httpInstance.onData = function(data) { // handle result }`</haxe_doc>
		</onData>
		<onBytes public="1" set="dynamic" line="205">
			<f a="data">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method is called upon a successful request, with `data` containing
		the result String.

		The intended usage is to bind it to a custom function:
		`httpInstance.onBytes = function(data) { // handle result }`</haxe_doc>
		</onBytes>
		<onError public="1" set="dynamic" line="214">
			<f a="msg">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method is called upon a request error, with `msg` containing the
		error description.

		The intended usage is to bind it to a custom function:
		`httpInstance.onError = function(msg) { // handle error }`</haxe_doc>
		</onError>
		<onStatus public="1" set="dynamic" line="223">
			<f a="status">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>This method is called upon a Http status change, with `status` being the
		new status.

		The intended usage is to bind it to a custom function:
		`httpInstance.onStatus = function(status) { // handle status }`</haxe_doc>
		</onStatus>
		<hasOnData set="method" line="228">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Override this if extending `haxe.Http` with overriding `onData`</haxe_doc>
		</hasOnData>
		<success set="method" line="232"><f a="data">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></success>
		<get_responseData set="method" line="241"><f a=""><x path="Null"><c path="String"/></x></f></get_responseData>
		<new public="1" set="method" line="71">
			<f a="url">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Http instance with `url` as parameter.

		This does not do a request until `request()` is called.

		If `url` is null, the field url must be set to a value before making the
		call to `request()`, or the result is unspecified.

		(Php) Https (SSL) connections are allowed only if the OpenSSL extension
		is enabled.</haxe_doc>
		</new>
		<haxe_doc>This class can be used to handle Http requests consistently across
	platforms. There are two intended usages:

	- call `haxe.Http.requestUrl(url)` and receive the result as a `String`
	(only available on `sys` targets)
	- create a `new haxe.Http(url)`, register your callbacks for `onData`,
	`onError` and `onStatus`, then call `request()`.</haxe_doc>
	</class>
	<typedef path="haxe.io.ArrayBufferViewData" params="" file="/home/travis/haxe/std/haxe/io/ArrayBufferView.hx" module="haxe.io.ArrayBufferView"><c path="haxe.io.ArrayBufferViewImpl"/></typedef>
	<class path="haxe.io.ArrayBufferViewImpl" params="" file="/home/travis/haxe/std/haxe/io/ArrayBufferView.hx" module="haxe.io.ArrayBufferView">
		<bytes public="1"><c path="haxe.io.Bytes"/></bytes>
		<byteOffset public="1"><x path="Int"/></byteOffset>
		<byteLength public="1"><x path="Int"/></byteLength>
		<sub public="1" set="method" line="38"><f a="begin:?length">
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.ArrayBufferViewImpl"/>
</f></sub>
		<subarray public="1" set="method" line="46"><f a="?begin:?end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.ArrayBufferViewImpl"/>
</f></subarray>
		<new public="1" set="method" line="32"><f a="bytes:pos:length">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="haxe.io.ArrayBufferView" params="" file="/home/travis/haxe/std/haxe/io/ArrayBufferView.hx">
		<this><t path="haxe.io.ArrayBufferViewData"/></this>
		<impl><class path="haxe.io._ArrayBufferView.ArrayBufferView_Impl_" params="" file="/home/travis/haxe/std/haxe/io/ArrayBufferView.hx" private="1" module="haxe.io.ArrayBufferView" final="1">
	<buffer public="1" get="accessor" set="null" static="1"><c path="haxe.io.Bytes"/></buffer>
	<byteOffset public="1" get="accessor" set="null" static="1"><x path="Int"/></byteOffset>
	<byteLength public="1" get="accessor" set="null" static="1"><x path="Int"/></byteLength>
	<_new public="1" get="inline" set="null" line="60" static="1">
		<f a="size">
			<x path="Int"/>
			<x path="haxe.io.ArrayBufferView"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<get_byteOffset get="inline" set="null" line="65" static="1"><f a="this">
	<t path="haxe.io.ArrayBufferViewData"/>
	<x path="Int"/>
</f></get_byteOffset>
	<get_byteLength get="inline" set="null" line="68" static="1"><f a="this">
	<t path="haxe.io.ArrayBufferViewData"/>
	<x path="Int"/>
</f></get_byteLength>
	<get_buffer get="inline" set="null" line="71" static="1"><f a="this">
	<t path="haxe.io.ArrayBufferViewData"/>
	<c path="haxe.io.Bytes"/>
</f></get_buffer>
	<sub public="1" get="inline" set="null" line="73" static="1"><f a="this:begin:?length">
	<t path="haxe.io.ArrayBufferViewData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.io.ArrayBufferView"/>
</f></sub>
	<subarray public="1" get="inline" set="null" line="77" static="1"><f a="this:?begin:?end">
	<t path="haxe.io.ArrayBufferViewData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.io.ArrayBufferView"/>
</f></subarray>
	<getData public="1" get="inline" set="null" line="81" static="1"><f a="this">
	<t path="haxe.io.ArrayBufferViewData"/>
	<t path="haxe.io.ArrayBufferViewData"/>
</f></getData>
	<fromData public="1" get="inline" set="null" line="85" static="1"><f a="a">
	<t path="haxe.io.ArrayBufferViewData"/>
	<x path="haxe.io.ArrayBufferView"/>
</f></fromData>
	<fromBytes public="1" set="method" line="89" static="1">
		<f a="bytes:?pos:?length" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="haxe.io.ArrayBufferView"/>
		</f>
		<meta><m n=":value"><e>{ pos : 0 }</e></m></meta>
	</fromBytes>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="haxe.io._ArrayBufferView.ArrayBufferView_Impl_" params="" file="/home/travis/haxe/std/haxe/io/ArrayBufferView.hx" private="1" module="haxe.io.ArrayBufferView" final="1">
		<buffer public="1" get="accessor" set="null" static="1"><c path="haxe.io.Bytes"/></buffer>
		<byteOffset public="1" get="accessor" set="null" static="1"><x path="Int"/></byteOffset>
		<byteLength public="1" get="accessor" set="null" static="1"><x path="Int"/></byteLength>
		<_new public="1" get="inline" set="null" line="60" static="1">
			<f a="size">
				<x path="Int"/>
				<x path="haxe.io.ArrayBufferView"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<get_byteOffset get="inline" set="null" line="65" static="1"><f a="this">
	<t path="haxe.io.ArrayBufferViewData"/>
	<x path="Int"/>
</f></get_byteOffset>
		<get_byteLength get="inline" set="null" line="68" static="1"><f a="this">
	<t path="haxe.io.ArrayBufferViewData"/>
	<x path="Int"/>
</f></get_byteLength>
		<get_buffer get="inline" set="null" line="71" static="1"><f a="this">
	<t path="haxe.io.ArrayBufferViewData"/>
	<c path="haxe.io.Bytes"/>
</f></get_buffer>
		<sub public="1" get="inline" set="null" line="73" static="1"><f a="this:begin:?length">
	<t path="haxe.io.ArrayBufferViewData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.io.ArrayBufferView"/>
</f></sub>
		<subarray public="1" get="inline" set="null" line="77" static="1"><f a="this:?begin:?end">
	<t path="haxe.io.ArrayBufferViewData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.io.ArrayBufferView"/>
</f></subarray>
		<getData public="1" get="inline" set="null" line="81" static="1"><f a="this">
	<t path="haxe.io.ArrayBufferViewData"/>
	<t path="haxe.io.ArrayBufferViewData"/>
</f></getData>
		<fromData public="1" get="inline" set="null" line="85" static="1"><f a="a">
	<t path="haxe.io.ArrayBufferViewData"/>
	<x path="haxe.io.ArrayBufferView"/>
</f></fromData>
		<fromBytes public="1" set="method" line="89" static="1">
			<f a="bytes:?pos:?length" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="haxe.io.ArrayBufferView"/>
			</f>
			<meta><m n=":value"><e>{ pos : 0 }</e></m></meta>
		</fromBytes>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="/home/travis/haxe/std/haxe/io/BytesBuffer.hx">
		<b><c path="Array"><x path="Int"/></c></b>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the buffer in bytes.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="64"><f a=""><x path="Int"/></f></get_length>
		<addByte public="1" get="inline" set="null" line="76"><f a="byte">
	<x path="Int"/>
	<x path="Void"/>
</f></addByte>
		<add public="1" get="inline" set="null" line="94"><f a="src">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></add>
		<addString public="1" get="inline" set="null" line="118"><f a="v:?encoding">
	<c path="String"/>
	<e path="haxe.io.Encoding"/>
	<x path="Void"/>
</f></addString>
		<addInt32 public="1" set="method" line="133"><f a="v">
	<x path="Int"/>
	<x path="Void"/>
</f></addInt32>
		<addInt64 public="1" set="method" line="144"><f a="v">
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></addInt64>
		<addFloat public="1" get="inline" set="null" line="149"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></addFloat>
		<addDouble public="1" get="inline" set="null" line="157"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></addDouble>
		<addBytes public="1" get="inline" set="null" line="165"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addBytes>
		<getBytes public="1" set="method" line="202">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer should no longer be used.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="45"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="/home/travis/haxe/std/haxe/io/BytesData.hx"><c path="Array"><x path="Int"/></c></typedef>
	<class path="haxe.io.Input" params="" file="/home/travis/haxe/std/haxe/io/Input.hx">
		<bigEndian public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Endianness (word byte order) used when reading numbers.

		If `true`, big-endian is used, otherwise `little-endian` is used.</haxe_doc>
		</bigEndian>
		<readByte public="1" set="method" line="49">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read and return one byte.</haxe_doc>
		</readByte>
		<readBytes public="1" set="method" line="64">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Returns the actual length of read data that can be smaller than `len`.

		See `readFullBytes` that tries to read the exact amount of specified bytes.</haxe_doc>
		</readBytes>
		<close public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the input source.

		Behaviour while reading after calling this method is unspecified.</haxe_doc>
		</close>
		<set_bigEndian set="method" line="94"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_bigEndian>
		<readAll public="1" set="method" line="106">
			<f a="?bufsize">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Read and return all available data.

		The `bufsize` optional argument specifies the size of chunks by
		which data is read. Its default value is target-specific.</haxe_doc>
		</readAll>
		<readFullBytes public="1" set="method" line="132">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Read `len` bytes and write them into `s` to the position specified by `pos`.

		Unlike `readBytes`, this method tries to read the exact `len` amount of bytes.</haxe_doc>
		</readFullBytes>
		<read public="1" set="method" line="145">
			<f a="nbytes">
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Read and return `nbytes` bytes.</haxe_doc>
		</read>
		<readUntil public="1" set="method" line="163">
			<f a="end">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Read a string until a character code specified by `end` is occurred.

		The final character is not included in the resulting string.</haxe_doc>
		</readUntil>
		<readLine public="1" set="method" line="176">
			<f a=""><c path="String"/></f>
			<haxe_doc>Read a line of text separated by CR and/or LF bytes.

		The CR/LF characters are not included in the resulting string.</haxe_doc>
		</readLine>
		<readFloat public="1" set="method" line="199">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Read a 32-bit floating point number.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readFloat>
		<readDouble public="1" set="method" line="208">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Read a 64-bit double-precision floating point number.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readDouble>
		<readInt8 public="1" set="method" line="217">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 8-bit signed integer.</haxe_doc>
		</readInt8>
		<readInt16 public="1" set="method" line="229">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 16-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readInt16>
		<readUInt16 public="1" set="method" line="243">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 16-bit unsigned integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readUInt16>
		<readInt24 public="1" set="method" line="254">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 24-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readInt24>
		<readUInt24 public="1" set="method" line="269">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 24-bit unsigned integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readUInt24>
		<readInt32 public="1" set="method" line="281">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Read a 32-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</readInt32>
		<readString public="1" set="method" line="304">
			<f a="len:?encoding">
				<x path="Int"/>
				<e path="haxe.io.Encoding"/>
				<c path="String"/>
			</f>
			<haxe_doc>Read and `len` bytes as a string.</haxe_doc>
		</readString>
		<haxe_doc>An Input is an abstract reader. See other classes in the `haxe.io` package
	for several possible implementations.

	All functions which read data throw `Eof` when the end of the stream
	is reached.</haxe_doc>
	</class>
	<class path="haxe.io.BytesInput" params="" file="/home/travis/haxe/std/haxe/io/BytesInput.hx">
		<extends path="haxe.io.Input"/>
		<b><t path="haxe.io.BytesData"/></b>
		<pos><x path="Int"/></pos>
		<len><x path="Int"/></len>
		<totlen><x path="Int"/></totlen>
		<position public="1" get="accessor" set="accessor">
			<x path="Int"/>
			<haxe_doc>The current position in the stream in bytes.</haxe_doc>
		</position>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the stream in bytes.</haxe_doc>
		</length>
		<get_position get="inline" set="null" line="67"><f a=""><x path="Int"/></f></get_position>
		<get_length get="inline" set="null" line="75"><f a=""><x path="Int"/></f></get_length>
		<set_position set="method" line="83"><f a="p">
	<x path="Int"/>
	<x path="Int"/>
</f></set_position>
		<readByte public="1" set="method" line="96" override="1"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method" line="119" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<new public="1" set="method" line="39"><f a="b:?pos:?len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.io.Output" params="" file="/home/travis/haxe/std/haxe/io/Output.hx">
		<bigEndian public="1" set="accessor">
			<x path="Bool"/>
			<haxe_doc>Endianness (word byte order) used when writing numbers.

		If `true`, big-endian is used, otherwise `little-endian` is used.</haxe_doc>
		</bigEndian>
		<writeByte public="1" set="method" line="46">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write one byte.</haxe_doc>
		</writeByte>
		<writeBytes public="1" set="method" line="57">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Write `len` bytes from `s` starting by position specified by `pos`.

		Returns the actual length of written data that can differ from `len`.

		See `writeFullBytes` that tries to write the exact amount of specified bytes.</haxe_doc>
		</writeBytes>
		<flush public="1" set="method" line="85">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Flush any buffered data.</haxe_doc>
		</flush>
		<close public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Close the output.

		Behaviour while writing after calling this method is unspecified.</haxe_doc>
		</close>
		<set_bigEndian set="method" line="94"><f a="b">
	<x path="Bool"/>
	<x path="Bool"/>
</f></set_bigEndian>
		<write public="1" set="method" line="103">
			<f a="s">
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write all bytes stored in `s`.</haxe_doc>
		</write>
		<writeFullBytes public="1" set="method" line="120">
			<f a="s:pos:len">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `len` bytes from `s` starting by position specified by `pos`.

		Unlike `writeBytes`, this method tries to write the exact `len` amount of bytes.</haxe_doc>
		</writeFullBytes>
		<writeFloat public="1" set="method" line="133">
			<f a="x">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 32-bit floating point number.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeFloat>
		<writeDouble public="1" set="method" line="142">
			<f a="x">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 64-bit double-precision floating point number.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeDouble>
		<writeInt8 public="1" set="method" line="156">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 8-bit signed integer.</haxe_doc>
		</writeInt8>
		<writeInt16 public="1" set="method" line="167">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 16-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeInt16>
		<writeUInt16 public="1" set="method" line="178">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 16-bit unsigned integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeUInt16>
		<writeInt24 public="1" set="method" line="195">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 24-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeInt24>
		<writeUInt24 public="1" set="method" line="206">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 24-bit unsigned integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeUInt24>
		<writeInt32 public="1" set="method" line="225">
			<f a="x">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `x` as 32-bit signed integer.

		Endianness is specified by the `bigEndian` property.</haxe_doc>
		</writeInt32>
		<prepare public="1" set="method" line="246">
			<f a="nbytes">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inform that we are about to write at least `nbytes` bytes.

		The underlying implementation can allocate proper working space depending
		on this information, or simply ignore it. This is not a mandatory call
		but a tip and is only used in some specific cases.</haxe_doc>
		</prepare>
		<writeInput public="1" set="method" line="254">
			<f a="i:?bufsize">
				<c path="haxe.io.Input"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Read all available data from `i` and write it.

		The `bufsize` optional argument specifies the size of chunks by
		which data is read and written. Its default value is 4096.</haxe_doc>
		</writeInput>
		<writeString public="1" set="method" line="278">
			<f a="s:?encoding">
				<c path="String"/>
				<e path="haxe.io.Encoding"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write `s` string.</haxe_doc>
		</writeString>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the `writeByte` and maybe the `write`, `flush` and `close`
	methods. See `File.write` and `String.write` for two ways of creating an
	Output.</haxe_doc>
	</class>
	<class path="haxe.io.BytesOutput" params="" file="/home/travis/haxe/std/haxe/io/BytesOutput.hx">
		<extends path="haxe.io.Output"/>
		<b><c path="haxe.io.BytesBuffer"/></b>
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the stream in bytes.</haxe_doc>
		</length>
		<get_length get="inline" set="null" line="47"><f a=""><x path="Int"/></f></get_length>
		<writeByte public="1" set="method" line="51" override="1"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method" line="59" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<getBytes public="1" set="method" line="137">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Returns the `Bytes` of this output.

		This function should not be called more than once on a given
		`BytesOutput` instance.</haxe_doc>
		</getBytes>
		<new public="1" set="method" line="35"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="haxe.io.Encoding" params="" file="/home/travis/haxe/std/haxe/io/Encoding.hx">
		<UTF8/>
		<RawNative><haxe_doc>Output the string the way the platform represent it in memory. This is the most efficient but is platform-specific</haxe_doc></RawNative>
		<haxe_doc>String binary encoding supported by Haxe I/O</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="haxe.io.Eof" params="" file="/home/travis/haxe/std/haxe/io/Eof.hx">
		<toString set="method" line="32">
			<f a=""><c path="String"/></f>
			<meta><m n=":ifFeature"><e>"haxe.io.Eof.*"</e></m></meta>
		</toString>
		<new public="1" set="method" line="29"><f a=""><x path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the `haxe.io.Input`.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="haxe.io.Error" params="" file="/home/travis/haxe/std/haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="haxe.io.FPHelper" params="" file="/home/travis/haxe/std/haxe/io/FPHelper.hx">
		<i64tmp expr="Int64.ofInt(0)" line="35" static="1">
			<x path="haxe.Int64"/>
			<meta><m n=":value"><e>Int64.ofInt(0)</e></m></meta>
		</i64tmp>
		<LN2 get="inline" set="null" expr="0.6931471805599453" line="37" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.6931471805599453</e></m></meta>
		</LN2>
		<_i32ToFloat get="inline" set="null" line="39" static="1"><f a="i">
	<x path="Int"/>
	<x path="Float"/>
</f></_i32ToFloat>
		<_i64ToDouble get="inline" set="null" line="48" static="1"><f a="lo:hi">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></_i64ToDouble>
		<_floatToI32 get="inline" set="null" line="58" static="1"><f a="f">
	<x path="Float"/>
	<x path="Int"/>
</f></_floatToI32>
		<_doubleToI64 get="inline" set="null" line="76" static="1"><f a="v">
	<x path="Float"/>
	<x path="haxe.Int64"/>
</f></_doubleToI64>
		<i32ToFloat public="1" set="method" line="133" static="1"><f a="i">
	<x path="Int"/>
	<x path="Float"/>
</f></i32ToFloat>
		<floatToI32 public="1" set="method" line="177" static="1"><f a="f">
	<x path="Float"/>
	<x path="Int"/>
</f></floatToI32>
		<i64ToDouble public="1" set="method" line="214" static="1"><f a="low:high">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
</f></i64ToDouble>
		<doubleToI64 public="1" set="method" line="268" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="haxe.Int64"/>
			</f>
			<haxe_doc>Returns an Int64 representing the bytes representation of the double precision IEEE float value.
		WARNING : for performance reason, the same Int64 value might be reused every time. Copy its low/high values before calling again.
		We still ensure that this is safe to use in a multithread environment</haxe_doc>
		</doubleToI64>
		<haxe_doc>Helper that converts between floating point and binary representation.
	Always works in low-endian encoding.</haxe_doc>
	</class>
	<class path="haxe.io.Path" params="" file="/home/travis/haxe/std/haxe/io/Path.hx">
		<withoutExtension public="1" set="method" line="123" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String representation of `path` without the file extension.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</withoutExtension>
		<withoutDirectory public="1" set="method" line="134" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String representation of `path` without the directory.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</withoutDirectory>
		<directory public="1" set="method" line="147" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the directory of `path`.

		If the directory is `null`, the empty String `""` is returned.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</directory>
		<extension public="1" set="method" line="161" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the extension of `path`.

		If `path` has no extension, the empty String `""` is returned.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</extension>
		<withExtension public="1" set="method" line="175" static="1">
			<f a="path:ext">
				<c path="String"/>
				<x path="Null"><c path="String"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a String representation of `path` where the extension is `ext`.

		If `path` has no extension, `ext` is added as extension.

		If `path` or `ext` are `null`, the result is unspecified.</haxe_doc>
		</withExtension>
		<join public="1" set="method" line="189" static="1">
			<f a="paths">
				<c path="Array"><c path="String"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Joins all paths in `paths` together.

		If `paths` is empty, the empty String `""` is returned. Otherwise the
		paths are joined with a slash between them.

		If `paths` is `null`, the result is unspecified.</haxe_doc>
		</join>
		<normalize public="1" set="method" line="210" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Normalize a given `path` (e.g. turn `'/usr/local/../lib'` into `'/usr/lib'`).

		Also replaces backslashes `\` with slashes `/` and afterwards turns
		multiple slashes into a single one.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</normalize>
		<addTrailingSlash public="1" set="method" line="271" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Adds a trailing slash to `path`, if it does not have one already.

		If the last slash in `path` is a backslash, a backslash is appended to
		`path`.

		If the last slash in `path` is a slash, or if no slash is found, a slash
		is appended to `path`. In particular, this applies to the empty String
		`""`.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</addTrailingSlash>
		<removeTrailingSlashes public="1" set="method" line="299" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes trailing slashes from `path`.

		If `path` does not end with a `/` or `\`, `path` is returned unchanged.

		Otherwise the substring of `path` excluding the trailing slashes or
		backslashes is returned.

		If `path` is `null`, the result is unspecified.</haxe_doc>
		</removeTrailingSlashes>
		<isAbsolute public="1" set="method" line="314" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if the path is an absolute path, and `false` otherwise.</haxe_doc>
		</isAbsolute>
		<unescape set="method" line="324" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></unescape>
		<escape set="method" line="329" static="1">
			<f a="path:?allowSlashes" v=":false">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ allowSlashes : false }</e></m></meta>
		</escape>
		<dir public="1">
			<x path="Null"><c path="String"/></x>
			<haxe_doc>The directory.

		This is the leading part of the path that is not part of the file name
		and the extension.

		Does not end with a `/` or `\` separator.

		If the path has no directory, the value is `null`.</haxe_doc>
		</dir>
		<file public="1">
			<c path="String"/>
			<haxe_doc>The file name.

		This is the part of the part between the directory and the extension.

		If there is no file name, e.g. for `".htaccess"` or `"/dir/"`, the value
		is the empty String `""`.</haxe_doc>
		</file>
		<ext public="1">
			<x path="Null"><c path="String"/></x>
			<haxe_doc>The file extension.

		It is separated from the file name by a dot. This dot is not part of
		the extension.

		If the path has no extension, the value is `null`.</haxe_doc>
		</ext>
		<backslash public="1">
			<x path="Bool"/>
			<haxe_doc>`true` if the last directory separator is a backslash, `false` otherwise.</haxe_doc>
		</backslash>
		<toString public="1" set="method" line="114">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String representation of `this` path.

		If `this.backslash` is `true`, backslash is used as directory separator,
		otherwise slash is used. This only affects the separator between
		`this.dir` and `this.file`.

		If `this.directory` or `this.extension` is `null`, their representation
		is the empty String `""`.</haxe_doc>
		</toString>
		<new public="1" set="method" line="76">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new `Path` instance by parsing `path`.

		Path information can be retrieved by accessing the `dir`, `file` and `ext`
		properties.</haxe_doc>
		</new>
		<haxe_doc>This class provides a convenient way of working with paths. It supports the
	common path formats:

	- `directory1/directory2/filename.extension`
	- `directory1\directory2\filename.extension`</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<typedef path="haxe.io.UInt8ArrayData" params="" file="/home/travis/haxe/std/haxe/io/UInt8Array.hx" module="haxe.io.UInt8Array"><t path="haxe.io.ArrayBufferViewData"/></typedef>
	<abstract path="haxe.io.UInt8Array" params="" file="/home/travis/haxe/std/haxe/io/UInt8Array.hx">
		<this><t path="haxe.io.UInt8ArrayData"/></this>
		<impl><class path="haxe.io._UInt8Array.UInt8Array_Impl_" params="" file="/home/travis/haxe/std/haxe/io/UInt8Array.hx" private="1" module="haxe.io.UInt8Array" final="1">
	<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="28" static="1">
		<x path="Int"/>
		<meta><m n=":value"><e>1</e></m></meta>
	</BYTES_PER_ELEMENT>
	<length public="1" get="accessor" set="null" static="1"><x path="Int"/></length>
	<view public="1" get="accessor" set="null" static="1"><x path="haxe.io.ArrayBufferView"/></view>
	<_new public="1" get="inline" set="null" line="33" static="1">
		<f a="elements">
			<x path="Int"/>
			<x path="haxe.io.UInt8Array"/>
		</f>
		<meta><m n=":noCompletion"/></meta>
	</_new>
	<get_length get="inline" set="null" line="37" static="1"><f a="this">
	<t path="haxe.io.UInt8ArrayData"/>
	<x path="Int"/>
</f></get_length>
	<get_view public="1" get="inline" set="null" line="41" static="1"><f a="this">
	<t path="haxe.io.UInt8ArrayData"/>
	<x path="haxe.io.ArrayBufferView"/>
</f></get_view>
	<get public="1" get="inline" set="null" line="45" static="1">
		<f a="this:index">
			<t path="haxe.io.UInt8ArrayData"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":arrayAccess"/></meta>
	</get>
	<set public="1" get="inline" set="null" line="49" static="1">
		<f a="this:index:value">
			<t path="haxe.io.UInt8ArrayData"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="Int"/>
		</f>
		<meta><m n=":arrayAccess"/></meta>
	</set>
	<sub public="1" get="inline" set="null" line="57" static="1"><f a="this:begin:?length">
	<t path="haxe.io.UInt8ArrayData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.io.UInt8Array"/>
</f></sub>
	<subarray public="1" get="inline" set="null" line="61" static="1"><f a="this:?begin:?end">
	<t path="haxe.io.UInt8ArrayData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.io.UInt8Array"/>
</f></subarray>
	<getData public="1" get="inline" set="null" line="65" static="1"><f a="this">
	<t path="haxe.io.UInt8ArrayData"/>
	<t path="haxe.io.UInt8ArrayData"/>
</f></getData>
	<fromData public="1" set="method" line="69" static="1"><f a="d">
	<t path="haxe.io.UInt8ArrayData"/>
	<x path="haxe.io.UInt8Array"/>
</f></fromData>
	<fromArray public="1" set="method" line="73" static="1">
		<f a="a:?pos:?length" v=":0:">
			<c path="Array"><x path="Int"/></c>
			<x path="Int"/>
			<x path="Int"/>
			<x path="haxe.io.UInt8Array"/>
		</f>
		<meta><m n=":value"><e>{ pos : 0 }</e></m></meta>
	</fromArray>
	<fromBytes public="1" set="method" line="84" static="1">
		<f a="bytes:?bytePos:?length" v=":0:">
			<c path="haxe.io.Bytes"/>
			<x path="Int"/>
			<x path="Int"/>
			<x path="haxe.io.UInt8Array"/>
		</f>
		<meta><m n=":value"><e>{ bytePos : 0 }</e></m></meta>
	</fromBytes>
	<meta><m n=":directlyUsed"/></meta>
</class></impl>
	</abstract>
	<class path="haxe.io._UInt8Array.UInt8Array_Impl_" params="" file="/home/travis/haxe/std/haxe/io/UInt8Array.hx" private="1" module="haxe.io.UInt8Array" final="1">
		<BYTES_PER_ELEMENT public="1" get="inline" set="null" expr="1" line="28" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</BYTES_PER_ELEMENT>
		<length public="1" get="accessor" set="null" static="1"><x path="Int"/></length>
		<view public="1" get="accessor" set="null" static="1"><x path="haxe.io.ArrayBufferView"/></view>
		<_new public="1" get="inline" set="null" line="33" static="1">
			<f a="elements">
				<x path="Int"/>
				<x path="haxe.io.UInt8Array"/>
			</f>
			<meta><m n=":noCompletion"/></meta>
		</_new>
		<get_length get="inline" set="null" line="37" static="1"><f a="this">
	<t path="haxe.io.UInt8ArrayData"/>
	<x path="Int"/>
</f></get_length>
		<get_view public="1" get="inline" set="null" line="41" static="1"><f a="this">
	<t path="haxe.io.UInt8ArrayData"/>
	<x path="haxe.io.ArrayBufferView"/>
</f></get_view>
		<get public="1" get="inline" set="null" line="45" static="1">
			<f a="this:index">
				<t path="haxe.io.UInt8ArrayData"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":arrayAccess"/></meta>
		</get>
		<set public="1" get="inline" set="null" line="49" static="1">
			<f a="this:index:value">
				<t path="haxe.io.UInt8ArrayData"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":arrayAccess"/></meta>
		</set>
		<sub public="1" get="inline" set="null" line="57" static="1"><f a="this:begin:?length">
	<t path="haxe.io.UInt8ArrayData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.io.UInt8Array"/>
</f></sub>
		<subarray public="1" get="inline" set="null" line="61" static="1"><f a="this:?begin:?end">
	<t path="haxe.io.UInt8ArrayData"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="haxe.io.UInt8Array"/>
</f></subarray>
		<getData public="1" get="inline" set="null" line="65" static="1"><f a="this">
	<t path="haxe.io.UInt8ArrayData"/>
	<t path="haxe.io.UInt8ArrayData"/>
</f></getData>
		<fromData public="1" set="method" line="69" static="1"><f a="d">
	<t path="haxe.io.UInt8ArrayData"/>
	<x path="haxe.io.UInt8Array"/>
</f></fromData>
		<fromArray public="1" set="method" line="73" static="1">
			<f a="a:?pos:?length" v=":0:">
				<c path="Array"><x path="Int"/></c>
				<x path="Int"/>
				<x path="Int"/>
				<x path="haxe.io.UInt8Array"/>
			</f>
			<meta><m n=":value"><e>{ pos : 0 }</e></m></meta>
		</fromArray>
		<fromBytes public="1" set="method" line="84" static="1">
			<f a="bytes:?bytePos:?length" v=":0:">
				<c path="haxe.io.Bytes"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="haxe.io.UInt8Array"/>
			</f>
			<meta><m n=":value"><e>{ bytePos : 0 }</e></m></meta>
		</fromBytes>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.iterators.ArrayIterator" params="T" file="/home/travis/haxe/std/haxe/iterators/ArrayIterator.hx">
		<array final="1"><c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c></array>
		<current expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<hasNext public="1" get="inline" set="null" line="44">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="52">
			<f a=""><c path="haxe.iterators.ArrayIterator.T"/></f>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="35">
			<f a="array">
				<c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new `ArrayIterator`.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[This iterator is used only when `Array<T>` is passed to `Iterable<T>`]]></haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.iterators.ArrayKeyValueIterator" params="T" file="/home/travis/haxe/std/haxe/iterators/ArrayKeyValueIterator.hx">
		<current expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<array><c path="Array"><c path="haxe.iterators.ArrayKeyValueIterator.T"/></c></array>
		<hasNext public="1" get="inline" set="null" line="36"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="41"><f a=""><a>
	<value><c path="haxe.iterators.ArrayKeyValueIterator.T"/></value>
	<key><x path="Int"/></key>
</a></f></next>
		<new public="1" get="inline" set="null" line="30"><f a="array">
	<c path="Array"><c path="haxe.iterators.ArrayKeyValueIterator.T"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":ifFeature">
	<e>"anon_read.keyValueIterator"</e>
	<e>"dynamic_read.keyValueIterator"</e>
</m></meta>
	</class>
	<class path="haxe.iterators.HashMapKeyValueIterator" params="K:V" file="/home/travis/haxe/std/haxe/iterators/HashMapKeyValueIterator.hx">
		<map final="1"><x path="haxe.ds.HashMap">
	<c path="haxe.iterators.HashMapKeyValueIterator.K"/>
	<c path="haxe.iterators.HashMapKeyValueIterator.V"/>
</x></map>
		<keys final="1"><t path="Iterator"><c path="haxe.iterators.HashMapKeyValueIterator.K"/></t></keys>
		<hasNext public="1" get="inline" set="null" line="17">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="24">
			<f a=""><a>
	<value><c path="haxe.iterators.HashMapKeyValueIterator.V"/></value>
	<key><c path="haxe.iterators.HashMapKeyValueIterator.K"/></key>
</a></f>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="9"><f a="map">
	<x path="haxe.ds.HashMap">
		<c path="haxe.iterators.HashMapKeyValueIterator.K"/>
		<c path="haxe.iterators.HashMapKeyValueIterator.V"/>
	</x>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.iterators.MapKeyValueIterator" params="K:V" file="/home/travis/haxe/std/haxe/iterators/MapKeyValueIterator.hx">
		<map><c path="haxe.IMap">
	<c path="haxe.iterators.MapKeyValueIterator.K"/>
	<c path="haxe.iterators.MapKeyValueIterator.V"/>
</c></map>
		<keys><t path="Iterator"><c path="haxe.iterators.MapKeyValueIterator.K"/></t></keys>
		<hasNext public="1" get="inline" set="null" line="43">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="50">
			<f a=""><a>
	<value><c path="haxe.iterators.MapKeyValueIterator.V"/></value>
	<key><c path="haxe.iterators.MapKeyValueIterator.K"/></key>
</a></f>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="35"><f a="map">
	<c path="haxe.IMap">
		<c path="haxe.iterators.MapKeyValueIterator.K"/>
		<c path="haxe.iterators.MapKeyValueIterator.V"/>
	</c>
	<x path="Void"/>
</f></new>
		<haxe_doc>This Key/Value iterator can be used to iterate across maps.</haxe_doc>
		<meta><m n=":ifFeature">
	<e>"anon_read.keyValueIterator"</e>
	<e>"dynamic_read.keyValueIterator"</e>
</m></meta>
	</class>
	<class path="haxe.iterators.RestIterator" params="T" file="/home/travis/haxe/std/haxe/iterators/RestIterator.hx">
		<args final="1"><x path="haxe.Rest"><c path="haxe.iterators.RestIterator.T"/></x></args>
		<current expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<hasNext public="1" get="inline" set="null" line="12"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="16"><f a=""><c path="haxe.iterators.RestIterator.T"/></f></next>
		<new get="inline" set="null" line="8">
			<f a="args">
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>haxe.Rest</e></m></meta>
		</new>
	</class>
	<class path="haxe.iterators.RestKeyValueIterator" params="T" file="/home/travis/haxe/std/haxe/iterators/RestKeyValueIterator.hx">
		<args final="1"><x path="haxe.Rest"><c path="haxe.iterators.RestKeyValueIterator.T"/></x></args>
		<current expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<hasNext public="1" get="inline" set="null" line="12"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="16"><f a=""><a>
	<value><c path="haxe.iterators.RestKeyValueIterator.T"/></value>
	<key><x path="Int"/></key>
</a></f></next>
		<new get="inline" set="null" line="8">
			<f a="args">
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<meta><m n=":allow"><e>haxe.Rest</e></m></meta>
		</new>
	</class>
	<class path="haxe.iterators.StringIterator" params="" file="/home/travis/haxe/std/haxe/iterators/StringIterator.hx">
		<offset expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</offset>
		<s><c path="String"/></s>
		<hasNext public="1" get="inline" set="null" line="45">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="52">
			<f a=""><x path="Int"/></f>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="38">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new `StringIterator` over String `s`.</haxe_doc>
		</new>
		<haxe_doc>This iterator can be used to iterate over char codes in a string.

	Note that char codes may differ across platforms because of different
	internal encoding of strings in different of runtimes.</haxe_doc>
	</class>
	<class path="haxe.iterators.StringIteratorUnicode" params="" file="/home/travis/haxe/std/haxe/iterators/StringIteratorUnicode.hx">
		<unicodeIterator public="1" get="inline" set="null" line="70" static="1">
			<f a="s">
				<c path="String"/>
				<c path="haxe.iterators.StringIteratorUnicode"/>
			</f>
			<haxe_doc>Convenience function which can be used as a static extension.</haxe_doc>
		</unicodeIterator>
		<offset expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</offset>
		<s><c path="String"/></s>
		<hasNext public="1" get="inline" set="null" line="47">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="55">
			<f a=""><x path="Int"/></f>
			<meta><m n=":access"><e>StringTools</e></m></meta>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="40">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new `StringIteratorUnicode` over String `s`.</haxe_doc>
		</new>
		<haxe_doc>This iterator can be used to iterate across strings in a cross-platform
	way. It handles surrogate pairs on platforms that require it. On each
	iteration, it returns the next character code.

	Note that this has different semantics than a standard for-loop over the
	String's length due to the fact that it deals with surrogate pairs.</haxe_doc>
	</class>
	<class path="haxe.iterators.StringKeyValueIterator" params="" file="/home/travis/haxe/std/haxe/iterators/StringKeyValueIterator.hx">
		<offset expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</offset>
		<s><c path="String"/></s>
		<hasNext public="1" get="inline" set="null" line="45">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `KeyValueIterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="52">
			<f a=""><a>
	<value><x path="Int"/></value>
	<key><x path="Int"/></key>
</a></f>
			<haxe_doc>See `KeyValueIterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="38">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new `StringKeyValueIterator` over String `s`.</haxe_doc>
		</new>
		<haxe_doc>This iterator can be used to iterate over char indexes and char codes in a string.

	Note that char codes may differ across platforms because of different
	internal encoding of strings in different runtimes.</haxe_doc>
	</class>
	<class path="haxe.macro.Compiler" params="" file="/home/travis/haxe/std/haxe/macro/Compiler.hx">
		<getDefine public="1" set="method" static="1">
			<f a="key">
				<d/>
				<d/>
			</f>
			<haxe_doc>A conditional compilation flag can be set on the command line using
		`-D key=value`.

		Returns the value of a compiler flag.

		If the compiler flag is defined but no value is set,
		`Compiler.getDefine` returns `"1"` (e.g. `-D key`).

		If the compiler flag is not defined, `Compiler.getDefine` returns
		`null`.

		Note: This is a macro and cannot be called from within other macros. Refer
		to `haxe.macro.Context.definedValue` to obtain defined values in macro context.

		@see https://haxe.org/manual/lf-condition-compilation.html</haxe_doc>
		</getDefine>
		<haxe_doc>All these methods can be called for compiler configuration macros.</haxe_doc>
	</class>
	<abstract path="haxe.macro.IncludePosition" params="" file="/home/travis/haxe/std/haxe/macro/Compiler.hx" module="haxe.macro.Compiler">
		<from><icast><c path="String"/></icast></from>
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="haxe.macro._Compiler.IncludePosition_Impl_" params="" file="/home/travis/haxe/std/haxe/macro/Compiler.hx" private="1" module="haxe.macro.Compiler" extern="1" final="1">
	<Top public="1" get="inline" set="null" expr="cast &quot;top&quot;" line="510" static="1">
		<x path="haxe.macro.IncludePosition"/>
		<meta>
			<m n=":value"><e>cast "top"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Prepend the file content to the output file.</haxe_doc>
	</Top>
	<Closure public="1" get="inline" set="null" expr="cast &quot;closure&quot;" line="517" static="1">
		<x path="haxe.macro.IncludePosition"/>
		<meta>
			<m n=":value"><e>cast "closure"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Prepend the file content to the body of the top-level closure.

		Since the closure is in strict-mode, there may be run-time error if the input is not strict-mode-compatible.</haxe_doc>
	</Closure>
	<Inline public="1" get="inline" set="null" expr="cast &quot;inline&quot;" line="522" static="1">
		<x path="haxe.macro.IncludePosition"/>
		<meta>
			<m n=":value"><e>cast "inline"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Directly inject the file content at the call site.</haxe_doc>
	</Inline>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="haxe.macro._Compiler.IncludePosition_Impl_" params="" file="/home/travis/haxe/std/haxe/macro/Compiler.hx" private="1" module="haxe.macro.Compiler" extern="1" final="1">
		<Top public="1" get="inline" set="null" expr="cast &quot;top&quot;" line="510" static="1">
			<x path="haxe.macro.IncludePosition"/>
			<meta>
				<m n=":value"><e>cast "top"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Prepend the file content to the output file.</haxe_doc>
		</Top>
		<Closure public="1" get="inline" set="null" expr="cast &quot;closure&quot;" line="517" static="1">
			<x path="haxe.macro.IncludePosition"/>
			<meta>
				<m n=":value"><e>cast "closure"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Prepend the file content to the body of the top-level closure.

		Since the closure is in strict-mode, there may be run-time error if the input is not strict-mode-compatible.</haxe_doc>
		</Closure>
		<Inline public="1" get="inline" set="null" expr="cast &quot;inline&quot;" line="522" static="1">
			<x path="haxe.macro.IncludePosition"/>
			<meta>
				<m n=":value"><e>cast "inline"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Directly inject the file content at the call site.</haxe_doc>
		</Inline>
		<meta><m n=":enum"/></meta>
	</class>
	<abstract path="haxe.macro.NullSafetyMode" params="" file="/home/travis/haxe/std/haxe/macro/Compiler.hx" module="haxe.macro.Compiler">
		<this><c path="String"/></this>
		<to><icast><c path="String"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="haxe.macro._Compiler.NullSafetyMode_Impl_" params="" file="/home/travis/haxe/std/haxe/macro/Compiler.hx" private="1" module="haxe.macro.Compiler" extern="1" final="1">
	<Off public="1" get="inline" set="null" expr="cast &quot;Off&quot;" line="1" static="1">
		<x path="haxe.macro.NullSafetyMode"/>
		<meta>
			<m n=":value"><e>cast "Off"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Disable null safety.</haxe_doc>
	</Off>
	<Loose public="1" get="inline" set="null" expr="cast &quot;Loose&quot;" line="1" static="1">
		<x path="haxe.macro.NullSafetyMode"/>
		<meta>
			<m n=":value"><e>cast "Loose"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc><![CDATA[Loose safety.
		If an expression is checked `!= null`, then it's considered safe even if it could be modified after the check.
		E.g.
		```haxe
		function example(o:{field:Null<String>}) {
			if(o.field != null) {
				mutate(o);
				var notNullable:String = o.field; //no error
			}
		}

		function mutate(o:{field:Null<String>}) {
			o.field = null;
		}
		```]]></haxe_doc>
	</Loose>
	<Strict public="1" get="inline" set="null" expr="cast &quot;Strict&quot;" line="1" static="1">
		<x path="haxe.macro.NullSafetyMode"/>
		<meta>
			<m n=":value"><e>cast "Strict"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc><![CDATA[Full scale null safety.
		If a field is checked `!= null` it stays safe until a call is made or any field of any object is reassigned,
		because that could potentially alter an object of the checked field.
		E.g.
		```haxe
		function example(o:{field:Null<String>}, b:{o:{field:Null<String>}}) {
			if(o.field != null) {
				var notNullable:String = o.field; //no error
				someCall();
				var notNullable:String = o.field; // Error!
			}
			if(o.field != null) {
				var notNullable:String = o.field; //no error
				b.o = {field:null};
				var notNullable:String = o.field; // Error!
			}
		}
		```]]></haxe_doc>
	</Strict>
	<StrictThreaded public="1" get="inline" set="null" expr="cast &quot;StrictThreaded&quot;" line="1" static="1">
		<x path="haxe.macro.NullSafetyMode"/>
		<meta>
			<m n=":value"><e>cast "StrictThreaded"</e></m>
			<m n=":impl"/>
			<m n=":enum"/>
		</meta>
		<haxe_doc>Full scale null safety for a multi-threaded environment.
		With this mode checking a field `!= null` does not make it safe, because it could be changed from another thread
		at the same time or immediately after the check.
		The only nullable thing could be safe are local variables.</haxe_doc>
	</StrictThreaded>
	<meta><m n=":enum"/></meta>
</class></impl>
	</abstract>
	<class path="haxe.macro._Compiler.NullSafetyMode_Impl_" params="" file="/home/travis/haxe/std/haxe/macro/Compiler.hx" private="1" module="haxe.macro.Compiler" extern="1" final="1">
		<Off public="1" get="inline" set="null" expr="cast &quot;Off&quot;" line="1" static="1">
			<x path="haxe.macro.NullSafetyMode"/>
			<meta>
				<m n=":value"><e>cast "Off"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Disable null safety.</haxe_doc>
		</Off>
		<Loose public="1" get="inline" set="null" expr="cast &quot;Loose&quot;" line="1" static="1">
			<x path="haxe.macro.NullSafetyMode"/>
			<meta>
				<m n=":value"><e>cast "Loose"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc><![CDATA[Loose safety.
		If an expression is checked `!= null`, then it's considered safe even if it could be modified after the check.
		E.g.
		```haxe
		function example(o:{field:Null<String>}) {
			if(o.field != null) {
				mutate(o);
				var notNullable:String = o.field; //no error
			}
		}

		function mutate(o:{field:Null<String>}) {
			o.field = null;
		}
		```]]></haxe_doc>
		</Loose>
		<Strict public="1" get="inline" set="null" expr="cast &quot;Strict&quot;" line="1" static="1">
			<x path="haxe.macro.NullSafetyMode"/>
			<meta>
				<m n=":value"><e>cast "Strict"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc><![CDATA[Full scale null safety.
		If a field is checked `!= null` it stays safe until a call is made or any field of any object is reassigned,
		because that could potentially alter an object of the checked field.
		E.g.
		```haxe
		function example(o:{field:Null<String>}, b:{o:{field:Null<String>}}) {
			if(o.field != null) {
				var notNullable:String = o.field; //no error
				someCall();
				var notNullable:String = o.field; // Error!
			}
			if(o.field != null) {
				var notNullable:String = o.field; //no error
				b.o = {field:null};
				var notNullable:String = o.field; // Error!
			}
		}
		```]]></haxe_doc>
		</Strict>
		<StrictThreaded public="1" get="inline" set="null" expr="cast &quot;StrictThreaded&quot;" line="1" static="1">
			<x path="haxe.macro.NullSafetyMode"/>
			<meta>
				<m n=":value"><e>cast "StrictThreaded"</e></m>
				<m n=":impl"/>
				<m n=":enum"/>
			</meta>
			<haxe_doc>Full scale null safety for a multi-threaded environment.
		With this mode checking a field `!= null` does not make it safe, because it could be changed from another thread
		at the same time or immediately after the check.
		The only nullable thing could be safe are local variables.</haxe_doc>
		</StrictThreaded>
		<meta><m n=":enum"/></meta>
	</class>
	<typedef path="haxe.macro.Position" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<min>
				<x path="Int"/>
				<haxe_doc>Position of the first character.</haxe_doc>
			</min>
			<max>
				<x path="Int"/>
				<haxe_doc>Position of the last character.</haxe_doc>
			</max>
			<file>
				<c path="String"/>
				<haxe_doc>Reference to the filename.</haxe_doc>
			</file>
		</a>
		<haxe_doc>Represents a position in a file.</haxe_doc>
	</typedef>
	<enum path="haxe.macro.StringLiteralKind" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<DoubleQuotes/>
		<SingleQuotes/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="haxe.macro.Constant" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<CInt a="v">
			<c path="String"/>
			<haxe_doc>Represents an integer literal.</haxe_doc>
		</CInt>
		<CFloat a="f">
			<c path="String"/>
			<haxe_doc>Represents a float literal.</haxe_doc>
		</CFloat>
		<CString a="s:?kind">
			<c path="String"/>
			<e path="haxe.macro.StringLiteralKind"/>
			<haxe_doc>Represents a string literal.</haxe_doc>
		</CString>
		<CIdent a="s">
			<c path="String"/>
			<haxe_doc>Represents an identifier.</haxe_doc>
		</CIdent>
		<CRegexp a="r:opt">
			<c path="String"/>
			<c path="String"/>
			<haxe_doc>Represents a regular expression literal.

		Example: `~/haxe/i`

		- The first argument `haxe` is a string with regular expression pattern.
		- The second argument `i` is a string with regular expression flags.

		@see https://haxe.org/manual/std-regex.html</haxe_doc>
		</CRegexp>
		<haxe_doc>Represents a constant.
	@see https://haxe.org/manual/expression-constants.html</haxe_doc>
	</enum>
	<enum path="haxe.macro.Binop" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpAdd><haxe_doc>`+`</haxe_doc></OpAdd>
		<OpMult><haxe_doc>`*`</haxe_doc></OpMult>
		<OpDiv><haxe_doc>`/`</haxe_doc></OpDiv>
		<OpSub><haxe_doc>`-`</haxe_doc></OpSub>
		<OpAssign><haxe_doc>`=`</haxe_doc></OpAssign>
		<OpEq><haxe_doc>`==`</haxe_doc></OpEq>
		<OpNotEq><haxe_doc>`!=`</haxe_doc></OpNotEq>
		<OpGt><haxe_doc><![CDATA[`>`]]></haxe_doc></OpGt>
		<OpGte><haxe_doc><![CDATA[`>=`]]></haxe_doc></OpGte>
		<OpLt><haxe_doc><![CDATA[`<`]]></haxe_doc></OpLt>
		<OpLte><haxe_doc><![CDATA[`<=`]]></haxe_doc></OpLte>
		<OpAnd><haxe_doc><![CDATA[`&`]]></haxe_doc></OpAnd>
		<OpOr><haxe_doc>`|`</haxe_doc></OpOr>
		<OpXor><haxe_doc>`^`</haxe_doc></OpXor>
		<OpBoolAnd><haxe_doc><![CDATA[`&&`]]></haxe_doc></OpBoolAnd>
		<OpBoolOr><haxe_doc>`||`</haxe_doc></OpBoolOr>
		<OpShl><haxe_doc><![CDATA[`<<`]]></haxe_doc></OpShl>
		<OpShr><haxe_doc><![CDATA[`>>`]]></haxe_doc></OpShr>
		<OpUShr><haxe_doc><![CDATA[`>>>`]]></haxe_doc></OpUShr>
		<OpMod><haxe_doc>`%`</haxe_doc></OpMod>
		<OpAssignOp a="op">
			<e path="haxe.macro.Binop"/>
			<haxe_doc><![CDATA[`+=` `-=` `/=` `*=` `<<=` `>>=` `>>>=` `|=` `&=` `^=` `%=`]]></haxe_doc>
		</OpAssignOp>
		<OpInterval><haxe_doc>`...`</haxe_doc></OpInterval>
		<OpArrow><haxe_doc><![CDATA[`=>`]]></haxe_doc></OpArrow>
		<OpIn><haxe_doc>`in`</haxe_doc></OpIn>
		<haxe_doc>A binary operator.
	@see https://haxe.org/manual/types-numeric-operators.html</haxe_doc>
	</enum>
	<enum path="haxe.macro.Unop" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<OpIncrement><haxe_doc>`++`</haxe_doc></OpIncrement>
		<OpDecrement><haxe_doc>`--`</haxe_doc></OpDecrement>
		<OpNot><haxe_doc>`!`</haxe_doc></OpNot>
		<OpNeg><haxe_doc>`-`</haxe_doc></OpNeg>
		<OpNegBits><haxe_doc>`~`</haxe_doc></OpNegBits>
		<OpSpread><haxe_doc>`...`</haxe_doc></OpSpread>
		<haxe_doc>A unary operator.
	@see https://haxe.org/manual/types-numeric-operators.html</haxe_doc>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<typedef path="haxe.macro.Expr" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the expression.</haxe_doc>
			</pos>
			<expr>
				<e path="haxe.macro.ExprDef"/>
				<haxe_doc>The expression kind.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a node in the AST.
	@see https://haxe.org/manual/macro-reification-expression.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ExprOf" params="T" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<t path="haxe.macro.Expr"/>
		<haxe_doc>Represents a AST node identical to `Expr`, but it allows constraining the
	type of accepted expressions.
	@see https://haxe.org/manual/macro-ExprOf.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Case" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<values>
				<c path="Array"><t path="haxe.macro.Expr"/></c>
				<haxe_doc>The value expressions of the case.</haxe_doc>
			</values>
			<guard>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional guard expressions of the case, if available.</haxe_doc>
			</guard>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The expression of the case, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a switch case.
	@see https://haxe.org/manual/expression-switch.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Var" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The type-hint of the variable, if available.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the variable.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Metadata associatied with the variable, if available.</haxe_doc>
			</meta>
			<isFinal>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the variable can be assigned to.</haxe_doc>
			</isFinal>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The expression of the variable, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a variable in the AST.
	@see https://haxe.org/manual/expression-var.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Catch" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The type of the catch.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the catch variable.</haxe_doc>
			</name>
			<expr>
				<t path="haxe.macro.Expr"/>
				<haxe_doc>The expression of the catch.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a catch in the AST.
	@see https://haxe.org/manual/expression-try-catch.html</haxe_doc>
	</typedef>
	<enum path="haxe.macro.QuoteStatus" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<Unquoted><haxe_doc>No quotes</haxe_doc></Unquoted>
		<Quoted><haxe_doc>Double quotes `"`</haxe_doc></Quoted>
		<haxe_doc>Represents the way something is quoted.</haxe_doc>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<typedef path="haxe.macro.ObjectField" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<quotes>
				<x path="Null"><e path="haxe.macro.QuoteStatus"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>How the field name is quoted.</haxe_doc>
			</quotes>
			<field>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</field>
			<expr>
				<t path="haxe.macro.Expr"/>
				<haxe_doc>The field expression.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents the field of an object declaration.</haxe_doc>
	</typedef>
	<enum path="haxe.macro.FunctionKind" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<FAnonymous><haxe_doc>Anonymous function</haxe_doc></FAnonymous>
		<FNamed a="name:?inlined">
			<c path="String"/>
			<x path="Bool"/>
			<haxe_doc>Named function</haxe_doc>
		</FNamed>
		<FArrow><haxe_doc>Arrow function</haxe_doc></FArrow>
		<haxe_doc>Represents function kind in the AST</haxe_doc>
	</enum>
	<enum path="haxe.macro.ExprDef" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<EConst a="c">
			<e path="haxe.macro.Constant"/>
			<haxe_doc>A constant.</haxe_doc>
		</EConst>
		<EArray a="e1:e2">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<haxe_doc>Array access `e1[e2]`.</haxe_doc>
		</EArray>
		<EBinop a="op:e1:e2">
			<e path="haxe.macro.Binop"/>
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<haxe_doc>Binary operator `e1 op e2`.</haxe_doc>
		</EBinop>
		<EField a="e:field">
			<t path="haxe.macro.Expr"/>
			<c path="String"/>
			<haxe_doc>Field access on `e.field`.</haxe_doc>
		</EField>
		<EParenthesis a="e">
			<t path="haxe.macro.Expr"/>
			<haxe_doc>Parentheses `(e)`.</haxe_doc>
		</EParenthesis>
		<EObjectDecl a="fields">
			<c path="Array"><t path="haxe.macro.ObjectField"/></c>
			<haxe_doc>An object declaration.</haxe_doc>
		</EObjectDecl>
		<EArrayDecl a="values">
			<c path="Array"><t path="haxe.macro.Expr"/></c>
			<haxe_doc>An array declaration `[el]`.</haxe_doc>
		</EArrayDecl>
		<ECall a="e:params">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><t path="haxe.macro.Expr"/></c>
			<haxe_doc>A call `e(params)`.</haxe_doc>
		</ECall>
		<ENew a="t:params">
			<t path="haxe.macro.TypePath"/>
			<c path="Array"><t path="haxe.macro.Expr"/></c>
			<haxe_doc>A constructor call `new t(params)`.</haxe_doc>
		</ENew>
		<EUnop a="op:postFix:e">
			<e path="haxe.macro.Unop"/>
			<x path="Bool"/>
			<t path="haxe.macro.Expr"/>
			<haxe_doc>An unary operator `op` on `e`:

		- `e++` (`op = OpIncrement, postFix = true`)
		- `e--` (`op = OpDecrement, postFix = true`)
		- `++e` (`op = OpIncrement, postFix = false`)
		- `--e` (`op = OpDecrement, postFix = false`)
		- `-e` (`op = OpNeg, postFix = false`)
		- `!e` (`op = OpNot, postFix = false`)
		- `~e` (`op = OpNegBits, postFix = false`)</haxe_doc>
		</EUnop>
		<EVars a="vars">
			<c path="Array"><t path="haxe.macro.Var"/></c>
			<haxe_doc>Variable declarations.</haxe_doc>
		</EVars>
		<EFunction a="kind:f">
			<x path="Null"><e path="haxe.macro.FunctionKind"/></x>
			<t path="haxe.macro.Function"/>
			<haxe_doc>A function declaration.</haxe_doc>
		</EFunction>
		<EBlock a="exprs">
			<c path="Array"><t path="haxe.macro.Expr"/></c>
			<haxe_doc>A block of expressions `{exprs}`.</haxe_doc>
		</EBlock>
		<EFor a="it:expr">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<haxe_doc>A `for` expression.</haxe_doc>
		</EFor>
		<EIf a="econd:eif:eelse">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<x path="Null"><t path="haxe.macro.Expr"/></x>
			<haxe_doc>An `if (econd) eif` or `if (econd) eif else eelse` expression.</haxe_doc>
		</EIf>
		<EWhile a="econd:e:normalWhile">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<x path="Bool"/>
			<haxe_doc>Represents a `while` expression.

		When `normalWhile` is `true` it is `while (...)`.

		When `normalWhile` is `false` it is `do {...} while (...)`.</haxe_doc>
		</EWhile>
		<ESwitch a="e:cases:edef">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><t path="haxe.macro.Case"/></c>
			<x path="Null"><t path="haxe.macro.Expr"/></x>
			<haxe_doc>Represents a `switch` expression with related cases and an optional.
		`default` case if `edef != null`.</haxe_doc>
		</ESwitch>
		<ETry a="e:catches">
			<t path="haxe.macro.Expr"/>
			<c path="Array"><t path="haxe.macro.Catch"/></c>
			<haxe_doc>Represents a `try`-expression with related catches.</haxe_doc>
		</ETry>
		<EReturn a="?e">
			<x path="Null"><t path="haxe.macro.Expr"/></x>
			<haxe_doc>A `return` or `return e` expression.</haxe_doc>
		</EReturn>
		<EBreak><haxe_doc>A `break` expression.</haxe_doc></EBreak>
		<EContinue><haxe_doc>A `continue` expression.</haxe_doc></EContinue>
		<EUntyped a="e">
			<t path="haxe.macro.Expr"/>
			<haxe_doc>An `untyped e` source code.</haxe_doc>
		</EUntyped>
		<EThrow a="e">
			<t path="haxe.macro.Expr"/>
			<haxe_doc>A `throw e` expression.</haxe_doc>
		</EThrow>
		<ECast a="e:t">
			<t path="haxe.macro.Expr"/>
			<x path="Null"><e path="haxe.macro.ComplexType"/></x>
			<haxe_doc>A `cast e` or `cast (e, m)` expression.</haxe_doc>
		</ECast>
		<EDisplay a="e:displayKind">
			<t path="haxe.macro.Expr"/>
			<e path="haxe.macro.DisplayKind"/>
			<haxe_doc>Used internally to provide completion.</haxe_doc>
		</EDisplay>
		<EDisplayNew a="t">
			<t path="haxe.macro.TypePath"/>
			<haxe_doc>Used internally to provide completion.</haxe_doc>
		</EDisplayNew>
		<ETernary a="econd:eif:eelse">
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<t path="haxe.macro.Expr"/>
			<haxe_doc>A `(econd) ? eif : eelse` expression.</haxe_doc>
		</ETernary>
		<ECheckType a="e:t">
			<t path="haxe.macro.Expr"/>
			<e path="haxe.macro.ComplexType"/>
			<haxe_doc>A `(e:t)` expression.</haxe_doc>
		</ECheckType>
		<EMeta a="s:e">
			<t path="haxe.macro.MetadataEntry"/>
			<t path="haxe.macro.Expr"/>
			<haxe_doc>A `@m e` expression.</haxe_doc>
		</EMeta>
		<EIs a="e:t">
			<t path="haxe.macro.Expr"/>
			<e path="haxe.macro.ComplexType"/>
			<haxe_doc>An `expr is Type` expression.</haxe_doc>
		</EIs>
		<haxe_doc>Represents the kind of a node in the AST.</haxe_doc>
	</enum>
	<enum path="haxe.macro.DisplayKind" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<DKCall/>
		<DKDot/>
		<DKStructure/>
		<DKMarked/>
		<DKPattern a="outermost"><x path="Bool"/></DKPattern>
	</enum>
	<enum path="haxe.macro.ComplexType" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TPath a="p">
			<t path="haxe.macro.TypePath"/>
			<haxe_doc>Represents the type path.</haxe_doc>
		</TPath>
		<TFunction a="args:ret">
			<c path="Array"><e path="haxe.macro.ComplexType"/></c>
			<e path="haxe.macro.ComplexType"/>
			<haxe_doc>Represents a function type.
		@see https://haxe.org/manual/types-function.html</haxe_doc>
		</TFunction>
		<TAnonymous a="fields">
			<c path="Array"><t path="haxe.macro.Field"/></c>
			<haxe_doc>Represents an anonymous structure type.
		@see https://haxe.org/manual/types-anonymous-structure.html</haxe_doc>
		</TAnonymous>
		<TParent a="t">
			<e path="haxe.macro.ComplexType"/>
			<haxe_doc><![CDATA[Represents parentheses around a type, e.g. the `(Int -> Void)` part in
		`(Int -> Void) -> String`.]]></haxe_doc>
		</TParent>
		<TExtend a="p:fields">
			<c path="Array"><t path="haxe.macro.TypePath"/></c>
			<c path="Array"><t path="haxe.macro.Field"/></c>
			<haxe_doc><![CDATA[Represents typedef extensions `> Iterable<T>`.
		The array `p` holds the type paths to the given types.
		@see https://haxe.org/manual/type-system-extensions.html]]></haxe_doc>
		</TExtend>
		<TOptional a="t">
			<e path="haxe.macro.ComplexType"/>
			<haxe_doc>Represents an optional type.</haxe_doc>
		</TOptional>
		<TNamed a="n:t">
			<c path="String"/>
			<e path="haxe.macro.ComplexType"/>
			<haxe_doc>Represents a type with a name.</haxe_doc>
		</TNamed>
		<TIntersection a="tl">
			<c path="Array"><e path="haxe.macro.ComplexType"/></c>
			<haxe_doc><![CDATA[Represents an intersection type `T1 & T2 & ... & TN`.]]></haxe_doc>
		</TIntersection>
		<haxe_doc>Represents a type syntax in the AST.</haxe_doc>
	</enum>
	<typedef path="haxe.macro.TypePath" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<sub>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sub is set on module sub-type access:
		`pack.Module.Type` has `name = "Module"`, `sub = "Type"`, if available.</haxe_doc>
			</sub>
			<params>
				<x path="Null"><c path="Array"><e path="haxe.macro.TypeParam"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional parameters of the type path.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>Represents the package of the type path.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type path.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a type path in the AST.</haxe_doc>
	</typedef>
	<enum path="haxe.macro.TypeParam" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TPType a="t"><e path="haxe.macro.ComplexType"/></TPType>
		<TPExpr a="e"><t path="haxe.macro.Expr"/></TPExpr>
		<haxe_doc><![CDATA[Represents a concrete type parameter in the AST.

	Haxe allows expressions in concrete type parameters, e.g.
	`new YourType<["hello", "world"]>`. In that case the value is `TPExpr` while
	in the normal case it's `TPType`.]]></haxe_doc>
	</enum>
	<typedef path="haxe.macro.TypeParamDecl" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the type parameter.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type parameter.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the type parameter.</haxe_doc>
			</meta>
			<constraints>
				<x path="Null"><c path="Array"><e path="haxe.macro.ComplexType"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional constraints of the type parameter.</haxe_doc>
			</constraints>
		</a>
		<haxe_doc>Represents a type parameter declaration in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Function" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<ret>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The return type-hint of the function, if available.</haxe_doc>
			</ret>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional list of function parameter type declarations.</haxe_doc>
			</params>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The expression of the function body, if available.</haxe_doc>
			</expr>
			<args>
				<c path="Array"><t path="haxe.macro.FunctionArg"/></c>
				<haxe_doc>A list of function arguments.</haxe_doc>
			</args>
		</a>
		<haxe_doc>Represents a function in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<value>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional value of the function argument, if available.</haxe_doc>
			</value>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The type-hint of the function argument, if available.</haxe_doc>
			</type>
			<opt>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the function argument is optional.</haxe_doc>
			</opt>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the function argument.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the function argument.</haxe_doc>
			</meta>
		</a>
		<haxe_doc>Represents a function argument in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.MetadataEntry" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the metadata entry.</haxe_doc>
			</pos>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.Expr"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the metadata entry.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the metadata entry.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a metadata entry in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Metadata" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<c path="Array"><t path="haxe.macro.MetadataEntry"/></c>
		<haxe_doc>Represents metadata in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Field" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the field.</haxe_doc>
			</pos>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the field.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.FieldType"/>
				<haxe_doc>The kind of the field.</haxe_doc>
			</kind>
			<doc>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The documentation of the field, if available. If the field has no
		documentation, the value is `null`.</haxe_doc>
			</doc>
			<access>
				<x path="Null"><c path="Array"><e path="haxe.macro.Access"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The access modifiers of the field. By default fields have private access.
		@see https://haxe.org/manual/class-field-access-modifier.html</haxe_doc>
			</access>
		</a>
		<haxe_doc>Represents a field in the AST.</haxe_doc>
	</typedef>
	<enum path="haxe.macro.Access" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<APublic><haxe_doc>Public access modifier, grants access from anywhere.
		@see https://haxe.org/manual/class-field-visibility.html</haxe_doc></APublic>
		<APrivate><haxe_doc>Private access modifier, grants access to class and its sub-classes
		only.
		@see https://haxe.org/manual/class-field-visibility.html</haxe_doc></APrivate>
		<AStatic><haxe_doc>Static access modifier.</haxe_doc></AStatic>
		<AOverride><haxe_doc>Override access modifier.
		@see https://haxe.org/manual/class-field-override.html</haxe_doc></AOverride>
		<ADynamic><haxe_doc>Dynamic (re-)bindable access modifier.
		@see https://haxe.org/manual/class-field-dynamic.html</haxe_doc></ADynamic>
		<AInline><haxe_doc>Inline access modifier. Allows expressions to be directly inserted in
		place of calls to them.
		@see https://haxe.org/manual/class-field-inline.html</haxe_doc></AInline>
		<AMacro><haxe_doc>Macro access modifier. Allows expression macro functions. These are
		normal functions which are executed as soon as they are typed.</haxe_doc></AMacro>
		<AFinal><haxe_doc>Final access modifier. For functions, they can not be overridden. For
		variables, it means they can be assigned to only once.</haxe_doc></AFinal>
		<AExtern><haxe_doc>Extern access modifier.</haxe_doc></AExtern>
		<AAbstract><haxe_doc>Abstract access modifier.</haxe_doc></AAbstract>
		<AOverload><haxe_doc>Overload access modifier.</haxe_doc></AOverload>
		<haxe_doc>Represents an access modifier.
	@see https://haxe.org/manual/class-field-access-modifier.html</haxe_doc>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="haxe.macro.FieldType" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<FVar a="t:?e">
			<x path="Null"><e path="haxe.macro.ComplexType"/></x>
			<x path="Null"><t path="haxe.macro.Expr"/></x>
			<haxe_doc>Represents a variable field type.</haxe_doc>
		</FVar>
		<FFun a="f">
			<t path="haxe.macro.Function"/>
			<haxe_doc>Represents a function field type.</haxe_doc>
		</FFun>
		<FProp a="get:set:?t:?e">
			<c path="String"/>
			<c path="String"/>
			<e path="haxe.macro.ComplexType"/>
			<x path="Null"><t path="haxe.macro.Expr"/></x>
			<haxe_doc>Represents a property with getter and setter field type.</haxe_doc>
		</FProp>
		<haxe_doc>Represents the field type in the AST.</haxe_doc>
	</enum>
	<typedef path="haxe.macro.TypeDefinition" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position to the type definition.</haxe_doc>
			</pos>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The parameter type declarations of the type definition.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type definition.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type definition.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the type definition.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.TypeDefKind"/>
				<haxe_doc>The kind of the type definition.</haxe_doc>
			</kind>
			<isExtern>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<fields>
				<c path="Array"><t path="haxe.macro.Field"/></c>
				<haxe_doc>The fields of the type definition.</haxe_doc>
			</fields>
			<doc>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The documentation of the type, if available. If the type has no
		documentation, the value is `null`.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a type definition.</haxe_doc>
	</typedef>
	<enum path="haxe.macro.TypeDefKind" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<TDEnum><haxe_doc>Represents an enum kind.</haxe_doc></TDEnum>
		<TDStructure><haxe_doc>Represents a structure kind.</haxe_doc></TDStructure>
		<TDClass a="?superClass:?interfaces:?isInterface:?isFinal:?isAbstract">
			<x path="Null"><t path="haxe.macro.TypePath"/></x>
			<c path="Array"><t path="haxe.macro.TypePath"/></c>
			<x path="Bool"/>
			<x path="Bool"/>
			<x path="Bool"/>
			<haxe_doc>Represents a class kind.</haxe_doc>
		</TDClass>
		<TDAlias a="t">
			<e path="haxe.macro.ComplexType"/>
			<haxe_doc>Represents an alias/typedef kind.</haxe_doc>
		</TDAlias>
		<TDAbstract a="tthis:?from:?to">
			<x path="Null"><e path="haxe.macro.ComplexType"/></x>
			<c path="Array"><e path="haxe.macro.ComplexType"/></c>
			<c path="Array"><e path="haxe.macro.ComplexType"/></c>
			<haxe_doc>Represents an abstract kind.</haxe_doc>
		</TDAbstract>
		<TDField a="kind:?access">
			<e path="haxe.macro.FieldType"/>
			<c path="Array"><e path="haxe.macro.Access"/></c>
			<haxe_doc>Represents a module-level field.</haxe_doc>
		</TDField>
		<haxe_doc>Represents a type definition kind.</haxe_doc>
	</enum>
	<class path="haxe.macro.Error" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<extends path="haxe.Exception"/>
		<pos public="1">
			<t path="haxe.macro.Position"/>
			<haxe_doc>The position of the error.</haxe_doc>
		</pos>
		<new public="1" set="method" line="1000">
			<f a="message:pos:?previous">
				<c path="String"/>
				<t path="haxe.macro.Position"/>
				<c path="haxe.Exception"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Instantiates an error with given message and position.</haxe_doc>
		</new>
		<haxe_doc>This error can be used to handle or produce compilation errors in macros.</haxe_doc>
	</class>
	<enum path="haxe.macro.ImportMode" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<INormal><haxe_doc>Represents a default import `import c`.</haxe_doc></INormal>
		<IAsName a="alias">
			<c path="String"/>
			<haxe_doc>Represents the alias import `import c as alias`.</haxe_doc>
		</IAsName>
		<IAll><haxe_doc>Represents the wildcard import `import *`.</haxe_doc></IAll>
		<haxe_doc>Represents the import mode.
	@see https://haxe.org/manual/type-system-import.html</haxe_doc>
	</enum>
	<typedef path="haxe.macro.ImportExpr" params="" file="/home/travis/haxe/std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<path>
				<c path="Array"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
</a></c>
				<haxe_doc>The path to the import expression.</haxe_doc>
			</path>
			<mode>
				<e path="haxe.macro.ImportMode"/>
				<haxe_doc>The mode of the import expression.</haxe_doc>
			</mode>
		</a>
		<haxe_doc>Represents the import expression.</haxe_doc>
	</typedef>
	<class path="haxe.zip.Compress" params="" file="/home/travis/haxe/std/haxe/zip/Compress.hx">
		<run public="1" set="method" line="38" static="1"><f a="s:level">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<execute public="1" set="method" line="30"><f a="src:srcPos:dst:dstPos">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></execute>
		<setFlushMode public="1" set="method" line="34"><f a="f">
	<e path="haxe.zip.FlushMode"/>
	<x path="Void"/>
</f></setFlushMode>
		<close public="1" set="method" line="36"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="26"><f a="level">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="haxe.zip.ExtraField" params="" file="/home/travis/haxe/std/haxe/zip/Entry.hx" module="haxe.zip.Entry">
		<FUnknown a="tag:bytes">
			<x path="Int"/>
			<c path="haxe.io.Bytes"/>
		</FUnknown>
		<FInfoZipUnicodePath a="name:crc">
			<c path="String"/>
			<x path="Int"/>
		</FInfoZipUnicodePath>
		<FUtf8/>
	</enum>
	<typedef path="haxe.zip.Entry" params="" file="/home/travis/haxe/std/haxe/zip/Entry.hx"><a>
	<fileTime><c path="Date"/></fileTime>
	<fileSize><x path="Int"/></fileSize>
	<fileName><c path="String"/></fileName>
	<extraFields>
		<x path="Null"><c path="haxe.ds.List"><e path="haxe.zip.ExtraField"/></c></x>
		<meta><m n=":optional"/></meta>
	</extraFields>
	<dataSize><x path="Int"/></dataSize>
	<data><x path="Null"><c path="haxe.io.Bytes"/></x></data>
	<crc32><x path="Null"><x path="Int"/></x></crc32>
	<compressed><x path="Bool"/></compressed>
</a></typedef>
	<enum path="haxe.zip.FlushMode" params="" file="/home/travis/haxe/std/haxe/zip/FlushMode.hx">
		<NO/>
		<SYNC/>
		<FULL/>
		<FINISH/>
		<BLOCK/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="haxe.zip.Huffman" params="" file="/home/travis/haxe/std/haxe/zip/Huffman.hx">
		<Found a="i"><x path="Int"/></Found>
		<NeedBit a="left:right">
			<e path="haxe.zip.Huffman"/>
			<e path="haxe.zip.Huffman"/>
		</NeedBit>
		<NeedBits a="n:table">
			<x path="Int"/>
			<c path="Array"><e path="haxe.zip.Huffman"/></c>
		</NeedBits>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="haxe.zip.HuffTools" params="" file="/home/travis/haxe/std/haxe/zip/Huffman.hx" module="haxe.zip.Huffman">
		<treeDepth set="method" line="34"><f a="t">
	<e path="haxe.zip.Huffman"/>
	<x path="Int"/>
</f></treeDepth>
		<treeCompress set="method" line="45"><f a="t">
	<e path="haxe.zip.Huffman"/>
	<e path="haxe.zip.Huffman"/>
</f></treeCompress>
		<treeWalk set="method" line="62"><f a="table:p:cd:d:t">
	<c path="Array"><e path="haxe.zip.Huffman"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="haxe.zip.Huffman"/>
	<x path="Void"/>
</f></treeWalk>
		<treeMake set="method" line="75"><f a="bits:maxbits:v:len">
	<c path="haxe.ds.IntMap"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="haxe.zip.Huffman"/>
</f></treeMake>
		<make public="1" set="method" line="86"><f a="lengths:pos:nlengths:maxbits">
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<e path="haxe.zip.Huffman"/>
</f></make>
		<new public="1" set="method" line="32"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.zip._InflateImpl.Window" params="" file="/home/travis/haxe/std/haxe/zip/InflateImpl.hx" private="1" module="haxe.zip.InflateImpl">
		<SIZE public="1" get="inline" set="null" expr="1 &lt;&lt; 15" line="29" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e><![CDATA[1 << 15]]></e></m></meta>
		</SIZE>
		<BUFSIZE public="1" get="inline" set="null" expr="1 &lt;&lt; 16" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e><![CDATA[1 << 16]]></e></m></meta>
		</BUFSIZE>
		<buffer public="1"><c path="haxe.io.Bytes"/></buffer>
		<pos public="1"><x path="Int"/></pos>
		<crc><c path="haxe.crypto.Adler32"/></crc>
		<slide public="1" set="method" line="44"><f a=""><x path="Void"/></f></slide>
		<addBytes public="1" set="method" line="53"><f a="b:p:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addBytes>
		<addByte public="1" set="method" line="60"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></addByte>
		<getLastChar public="1" set="method" line="67"><f a=""><x path="Int"/></f></getLastChar>
		<available public="1" set="method" line="71"><f a=""><x path="Int"/></f></available>
		<checksum public="1" set="method" line="75"><f a=""><c path="haxe.crypto.Adler32"/></f></checksum>
		<new public="1" set="method" line="37"><f a="hasCrc">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="haxe.zip._InflateImpl.State" params="" file="/home/travis/haxe/std/haxe/zip/InflateImpl.hx" private="1" module="haxe.zip.InflateImpl">
		<Head/>
		<Block/>
		<CData/>
		<Flat/>
		<Crc/>
		<Dist/>
		<DistOne/>
		<Done/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="haxe.zip.InflateImpl" params="" file="/home/travis/haxe/std/haxe/zip/InflateImpl.hx">
		<LEN_EXTRA_BITS_TBL expr="[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, -1, -1]" line="97" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, -1, -1]</e></m></meta>
		</LEN_EXTRA_BITS_TBL>
		<LEN_BASE_VAL_TBL expr="[3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258]" line="100" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258]</e></m></meta>
		</LEN_BASE_VAL_TBL>
		<DIST_EXTRA_BITS_TBL expr="[0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, -1, -1]" line="103" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, -1, -1]</e></m></meta>
		</DIST_EXTRA_BITS_TBL>
		<DIST_BASE_VAL_TBL expr="[1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577]" line="106" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577]</e></m></meta>
		</DIST_BASE_VAL_TBL>
		<CODE_LENGTHS_POS expr="[16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]" line="109" static="1">
			<c path="Array"><x path="Int"/></c>
			<meta><m n=":value"><e>[16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]</e></m></meta>
		</CODE_LENGTHS_POS>
		<FIXED_HUFFMAN expr="null" line="127" static="1">
			<e path="haxe.zip.Huffman"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</FIXED_HUFFMAN>
		<run public="1" set="method" line="388" static="1">
			<f a="i:?bufsize" v=":65536">
				<c path="haxe.io.Input"/>
				<x path="Int"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<meta><m n=":value"><e>{ bufsize : 65536 }</e></m></meta>
		</run>
		<nbits><x path="Int"/></nbits>
		<bits><x path="Int"/></bits>
		<state><e path="haxe.zip._InflateImpl.State"/></state>
		<isFinal><x path="Bool"/></isFinal>
		<huffman><e path="haxe.zip.Huffman"/></huffman>
		<huffdist><x path="Null"><e path="haxe.zip.Huffman"/></x></huffdist>
		<htools><c path="haxe.zip.HuffTools"/></htools>
		<len><x path="Int"/></len>
		<dist><x path="Int"/></dist>
		<needed><x path="Int"/></needed>
		<output><c path="haxe.io.Bytes"/></output>
		<outpos><x path="Int"/></outpos>
		<input><c path="haxe.io.Input"/></input>
		<lengths><c path="Array"><x path="Int"/></c></lengths>
		<window><c path="haxe.zip._InflateImpl.Window"/></window>
		<buildFixedHuffman set="method" line="149"><f a=""><e path="haxe.zip.Huffman"/></f></buildFixedHuffman>
		<readBytes public="1" set="method" line="159"><f a="b:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<getBits set="method" line="168"><f a="n">
	<x path="Int"/>
	<x path="Int"/>
</f></getBits>
		<getBit set="method" line="179"><f a=""><x path="Bool"/></f></getBit>
		<getRevBits set="method" line="190"><f a="n">
	<x path="Int"/>
	<x path="Int"/>
</f></getRevBits>
		<resetBits set="method" line="199"><f a=""><x path="Void"/></f></resetBits>
		<addBytes set="method" line="204"><f a="b:p:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addBytes>
		<addByte set="method" line="211"><f a="b">
	<x path="Int"/>
	<x path="Void"/>
</f></addByte>
		<addDistOne set="method" line="218"><f a="n">
	<x path="Int"/>
	<x path="Void"/>
</f></addDistOne>
		<addDist set="method" line="224"><f a="d:len">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addDist>
		<applyHuffman set="method" line="228"><f a="h">
	<e path="haxe.zip.Huffman"/>
	<x path="Int"/>
</f></applyHuffman>
		<inflateLengths set="method" line="236"><f a="a:max">
	<c path="Array"><x path="Int"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></inflateLengths>
		<inflateLoop set="method" line="268"><f a=""><x path="Bool"/></f></inflateLoop>
		<new public="1" set="method" line="129">
			<f a="i:?header:?crc" v=":true:true">
				<c path="haxe.io.Input"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ crc : true, header : true }</e></m></meta>
		</new>
		<haxe_doc>A pure Haxe implementation of the ZLIB Inflate algorithm which allows reading compressed data without any platform-specific support.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.zip.Tools" params="" file="/home/travis/haxe/std/haxe/zip/Tools.hx">
		<compress public="1" set="method" line="26" static="1"><f a="f:level">
	<t path="haxe.zip.Entry"/>
	<x path="Int"/>
	<x path="Void"/>
</f></compress>
		<uncompress public="1" set="method" line="38" static="1"><f a="f">
	<t path="haxe.zip.Entry"/>
	<x path="Void"/>
</f></uncompress>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.zip.Uncompress" params="" file="/home/travis/haxe/std/haxe/zip/Uncompress.hx">
		<run public="1" set="method" line="38" static="1"><f a="src:?bufsize">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></run>
		<execute public="1" set="method" line="30"><f a="src:srcPos:dst:dstPos">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<a>
		<write><x path="Int"/></write>
		<read><x path="Int"/></read>
		<done><x path="Bool"/></done>
	</a>
</f></execute>
		<setFlushMode public="1" set="method" line="34"><f a="f">
	<e path="haxe.zip.FlushMode"/>
	<x path="Void"/>
</f></setFlushMode>
		<close public="1" set="method" line="36"><f a=""><x path="Void"/></f></close>
		<new public="1" set="method" line="26"><f a="?windowBits">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="haxe.zip.Writer" params="" file="/home/travis/haxe/std/haxe/zip/Writer.hx">
		<CENTRAL_DIRECTORY_RECORD_FIELDS_SIZE get="inline" set="null" expr="46" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>46</e></m></meta>
			<haxe_doc>The next constant is required for computing the Central
		Directory Record(CDR) size. CDR consists of some fields
		of constant size and a filename. Constant represents
		total length of all fields with constant size for each
		file in archive</haxe_doc>
		</CENTRAL_DIRECTORY_RECORD_FIELDS_SIZE>
		<LOCAL_FILE_HEADER_FIELDS_SIZE get="inline" set="null" expr="30" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>30</e></m></meta>
			<haxe_doc>The following constant is the total size of all fields
		of Local File Header. It's required for calculating
		offset of start of central directory record</haxe_doc>
		</LOCAL_FILE_HEADER_FIELDS_SIZE>
		<o><c path="haxe.io.Output"/></o>
		<files><c path="haxe.ds.List"><a>
	<size><x path="Int"/></size>
	<name><c path="String"/></name>
	<fields><c path="haxe.io.Bytes"/></fields>
	<date><c path="Date"/></date>
	<crc><x path="Int"/></crc>
	<compressed><x path="Bool"/></compressed>
	<clen><x path="Int"/></clen>
</a></c></files>
		<writeZipDate set="method" line="60"><f a="date">
	<c path="Date"/>
	<x path="Void"/>
</f></writeZipDate>
		<writeEntryHeader public="1" set="method" line="71"><f a="f">
	<t path="haxe.zip.Entry"/>
	<x path="Void"/>
</f></writeEntryHeader>
		<write public="1" set="method" line="141"><f a="files">
	<c path="haxe.ds.List"><t path="haxe.zip.Entry"/></c>
	<x path="Void"/>
</f></write>
		<writeCDR public="1" set="method" line="149"><f a=""><x path="Void"/></f></writeCDR>
		<new public="1" set="method" line="55"><f a="o">
	<c path="haxe.io.Output"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="python.Syntax" params="" file="/home/travis/haxe/std/python/Syntax.hx" extern="1">
		<importModule public="1" set="method" static="1">
			<f a="module">
				<d/>
				<d/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</importModule>
		<importAs public="1" set="method" static="1">
			<f a="module:className">
				<d/>
				<d/>
				<d/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</importAs>
		<construct public="1" params="T" set="method" static="1">
			<f a="cls:args">
				<x path="Class"><c path="construct.T"/></x>
				<t path="haxe.extern.Rest"><d/></t>
				<c path="construct.T"/>
			</f>
			<overloads><construct public="1" set="method"><f a="className:args">
	<c path="String"/>
	<t path="haxe.extern.Rest"><d/></t>
	<d/>
</f></construct></overloads>
		</construct>
		<newInstance public="1" set="method" static="1">
			<f a="c:params">
				<d/>
				<d/>
				<d/>
			</f>
			<meta>
				<m n=":noUsing"/>
				<m n=":deprecated"><e>"python.Syntax.newInstance() is deprecated. Use python.Syntax.construct() instead."</e></m>
			</meta>
		</newInstance>
		<_newInstance public="1" set="method" static="1"><f a="c:args">
	<d/>
	<c path="Array"><d/></c>
	<d/>
</f></_newInstance>
		<isIn public="1" set="method" static="1">
			<f a="a:b">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</isIn>
		<delete public="1" set="method" static="1">
			<f a="a">
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</delete>
		<binop public="1" set="method" static="1">
			<f a="a:op:b">
				<d/>
				<c path="String"/>
				<d/>
				<d/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</binop>
		<assign public="1" set="method" static="1">
			<f a="a:b">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</assign>
		<code public="1" set="method" static="1"><f a="code:args">
	<c path="String"/>
	<t path="haxe.extern.Rest"><d/></t>
	<d/>
</f></code>
		<pythonCode public="1" set="method" static="1">
			<f a="b:rest">
				<c path="String"/>
				<d/>
				<d/>
			</f>
			<meta>
				<m n=":noUsing"/>
				<m n=":deprecated"><e>"python.Syntax.pythonCode() is deprecated. Use python.Syntax.code() instead."</e></m>
			</meta>
		</pythonCode>
		<_pythonCode public="1" params="T" set="method" static="1">
			<f a="b:args">
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="_pythonCode.T"/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</_pythonCode>
		<arrayAccess public="1" set="method" static="1">
			<f a="x:rest">
				<d/>
				<d/>
				<d/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</arrayAccess>
		<arrayAccessWithTrailingColon public="1" set="method" static="1">
			<f a="x:rest">
				<d/>
				<d/>
				<d/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</arrayAccessWithTrailingColon>
		<_arrayAccess public="1" set="method" static="1">
			<f a="a:args:?trailingColon" v="::false">
				<d/>
				<c path="Array"><d/></c>
				<x path="Bool"/>
				<d/>
			</f>
			<meta><m n=":value"><e>{ trailingColon : false }</e></m></meta>
		</_arrayAccess>
		<arraySet public="1" set="method" static="1">
			<f a="a:i:v">
				<d/>
				<d/>
				<d/>
				<d/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</arraySet>
		<_foreach public="1" set="method" static="1"><f a="id:it:block">
	<d/>
	<d/>
	<d/>
	<d/>
</f></_foreach>
		<foreach public="1" params="T" set="method" static="1">
			<f a="v:it:b">
				<d/>
				<d/>
				<d/>
				<d/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</foreach>
		<importFromAs public="1" set="method" static="1">
			<f a="from:module:className">
				<d/>
				<d/>
				<d/>
				<d/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</importFromAs>
		<callField public="1" set="method" static="1">
			<f a="o:field:params">
				<d/>
				<c path="String"/>
				<d/>
				<d/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</callField>
		<call public="1" set="method" static="1"><f a="e:args">
	<d/>
	<c path="Array"><d/></c>
	<d/>
</f></call>
		<field public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</field>
		<tuple public="1" set="method" static="1">
			<f a="args">
				<d/>
				<d/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</tuple>
		<_tuple public="1" set="method" static="1"><f a="args">
	<c path="Array"><d/></c>
	<d/>
</f></_tuple>
		<varArgs public="1" set="method" static="1">
			<f a="args">
				<c path="Array"><d/></c>
				<d/>
			</f>
			<meta><m n=":noUsing"/></meta>
		</varArgs>
		<callNamedUntyped public="1" set="method" static="1"><f a="e:args">
	<d/>
	<d/>
	<d/>
</f></callNamedUntyped>
		<_callNamedUntyped public="1" set="method" static="1"><f a="e:args">
	<d/>
	<d/>
	<d/>
</f></_callNamedUntyped>
		<opPow public="1" set="method" static="1"><f a="a:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></opPow>
		<meta>
			<m n=":noPackageRestrict"/>
			<m n=":noClosure"/>
		</meta>
	</class>
	<typedef path="sys.FileStat" params="" file="/home/travis/haxe/std/sys/FileStat.hx">
		<a>
			<uid>
				<x path="Int"/>
				<haxe_doc>The user id for the file owner.</haxe_doc>
			</uid>
			<size>
				<x path="Int"/>
				<haxe_doc>The size of the file, in bytes.</haxe_doc>
			</size>
			<rdev>
				<x path="Int"/>
				<haxe_doc>The device type on which stat resides (special files only).</haxe_doc>
			</rdev>
			<nlink>
				<x path="Int"/>
				<haxe_doc>The number of hard links to stat.</haxe_doc>
			</nlink>
			<mtime>
				<c path="Date"/>
				<haxe_doc>The last modification time for the file.</haxe_doc>
			</mtime>
			<mode>
				<x path="Int"/>
				<haxe_doc>The permission bits of stat. The meaning of the bits is platform dependent.</haxe_doc>
			</mode>
			<ino>
				<x path="Int"/>
				<haxe_doc>The inode number for stat.</haxe_doc>
			</ino>
			<gid>
				<x path="Int"/>
				<haxe_doc>The user group id for the file owner.</haxe_doc>
			</gid>
			<dev>
				<x path="Int"/>
				<haxe_doc>The device on which stat resides.</haxe_doc>
			</dev>
			<ctime>
				<c path="Date"/>
				<haxe_doc>The creation time for the file (not all file systems support this).</haxe_doc>
			</ctime>
			<atime>
				<c path="Date"/>
				<haxe_doc>The last access time for the file (when enabled by the file system).</haxe_doc>
			</atime>
		</a>
		<haxe_doc>File information, as given by `sys.FileSystem.stat`.</haxe_doc>
	</typedef>
	<class path="sys.FileSystem" params="" file="/home/travis/haxe/std/sys/FileSystem.hx" extern="1">
		<exists public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if the file or directory specified by `path` exists.</haxe_doc>
		</exists>
		<rename public="1" set="method" static="1">
			<f a="path:newPath">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Renames/moves the file or directory specified by `path` to `newPath`.

		If `path` is not a valid file system entry, or if it is not accessible,
		or if `newPath` is not accessible, an exception is thrown.</haxe_doc>
		</rename>
		<stat public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<t path="sys.FileStat"/>
			</f>
			<haxe_doc>Returns `FileStat` information for the file or directory specified by
		`path`.</haxe_doc>
		</stat>
		<fullPath public="1" set="method" static="1">
			<f a="relPath">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the full path of the file or directory specified by `relPath`,
		which is relative to the current working directory. Symlinks will be
		followed and the path will be normalized.</haxe_doc>
		</fullPath>
		<absolutePath public="1" set="method" static="1">
			<f a="relPath">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the full path of the file or directory specified by `relPath`,
		which is relative to the current working directory. The path doesn't
		have to exist.</haxe_doc>
		</absolutePath>
		<isDirectory public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if the file or directory specified by `path` is a directory.

		If `path` is not a valid file system entry or if its destination is not
		accessible, an exception is thrown.</haxe_doc>
		</isDirectory>
		<createDirectory public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a directory specified by `path`.

		This method is recursive: The parent directories don't have to exist.

		If the directory cannot be created, an exception is thrown.</haxe_doc>
		</createDirectory>
		<deleteFile public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Deletes the file specified by `path`.

		If `path` does not denote a valid file, or if that file cannot be
		deleted, an exception is thrown.</haxe_doc>
		</deleteFile>
		<deleteDirectory public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Deletes the directory specified by `path`. Only empty directories can
		be deleted.

		If `path` does not denote a valid directory, or if that directory cannot
		be deleted, an exception is thrown.</haxe_doc>
		</deleteDirectory>
		<readDirectory public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the names of all files and directories in the directory specified
		by `path`. `"."` and `".."` are not included in the output.

		If `path` does not denote a valid directory, an exception is thrown.</haxe_doc>
		</readDirectory>
		<haxe_doc>This class provides information about files and directories.

	If `null` is passed as a file path to any function in this class, the
	result is unspecified, and may differ from target to target.

	See `sys.io.File` for the complementary file API.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="sys.Http" params="" file="/home/travis/haxe/std/sys/Http.hx">
		<extends path="haxe.http.HttpBase"/>
		<PROXY public="1" expr="null" line="46" static="1">
			<a>
				<port><x path="Int"/></port>
				<host><c path="String"/></host>
				<auth><a>
	<user><c path="String"/></user>
	<pass><c path="String"/></pass>
</a></auth>
			</a>
			<meta><m n=":value"><e>null</e></m></meta>
		</PROXY>
		<requestUrl public="1" set="method" line="488" static="1">
			<f a="url">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Makes a synchronous request to `url`.

	This creates a new Http instance and makes a GET request by calling its
	`request(false)` method.

	If `url` is null, the result is unspecified.</haxe_doc>
		</requestUrl>
		<noShutdown public="1"><x path="Bool"/></noShutdown>
		<cnxTimeout public="1"><x path="Float"/></cnxTimeout>
		<responseHeaders public="1"><t path="Map">
	<c path="String"/>
	<c path="String"/>
</t></responseHeaders>
		<chunk_size><x path="Null"><x path="Int"/></x></chunk_size>
		<chunk_buf><c path="haxe.io.Bytes"/></chunk_buf>
		<file><a>
	<size><x path="Int"/></size>
	<param><c path="String"/></param>
	<mimeType><c path="String"/></mimeType>
	<io><c path="haxe.io.Input"/></io>
	<filename><c path="String"/></filename>
</a></file>
		<request public="1" set="method" line="56" override="1"><f a="?post">
	<x path="Bool"/>
	<x path="Void"/>
</f></request>
		<fileTransfert public="1" get="inline" set="null" line="76">
			<f a="argname:filename:file:size:?mimeType" v="::::&quot;application/octet-stream&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="haxe.io.Input"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ mimeType : "application/octet-stream" }</e></m>
				<m n=":noCompletion"/>
				<m n=":deprecated"><e>"Use fileTransfer instead"</e></m>
			</meta>
		</fileTransfert>
		<fileTransfer public="1" set="method" line="80">
			<f a="argname:filename:file:size:?mimeType" v="::::&quot;application/octet-stream&quot;">
				<c path="String"/>
				<c path="String"/>
				<c path="haxe.io.Input"/>
				<x path="Int"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ mimeType : "application/octet-stream" }</e></m></meta>
		</fileTransfer>
		<customRequest public="1" set="method" line="90"><f a="post:api:?sock:?method">
	<x path="Bool"/>
	<c path="haxe.io.Output"/>
	<c path="sys.net.Socket"/>
	<c path="String"/>
	<x path="Void"/>
</f></customRequest>
		<writeBody set="method" line="255"><f a="body:fileInput:fileSize:boundary:sock">
	<x path="Null"><c path="haxe.io.BytesOutput"/></x>
	<x path="Null"><c path="haxe.io.Input"/></x>
	<x path="Int"/>
	<x path="Null"><c path="String"/></x>
	<c path="sys.net.Socket"/>
	<x path="Void"/>
</f></writeBody>
		<readHttpResponse set="method" line="280"><f a="api:sock">
	<c path="haxe.io.Output"/>
	<c path="sys.net.Socket"/>
	<x path="Void"/>
</f></readHttpResponse>
		<readChunk set="method" line="422"><f a="chunk_re:api:buf:len">
	<c path="EReg"/>
	<c path="haxe.io.Output"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></readChunk>
		<new public="1" set="method" line="48"><f a="url">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="sys.io.File" params="" file="/home/travis/haxe/std/sys/io/File.hx" extern="1">
		<getContent public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Retrieves the content of the file specified by `path` as a String.

		If the file does not exist or can not be read, an exception is thrown.

		`sys.FileSystem.exists` can be used to check for existence.

		If `path` is null, the result is unspecified.</haxe_doc>
		</getContent>
		<saveContent public="1" set="method" static="1">
			<f a="path:content">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores `content` in the file specified by `path`.

		If the file cannot be written to, an exception is thrown.

		If `path` or `content` are null, the result is unspecified.</haxe_doc>
		</saveContent>
		<getBytes public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Retrieves the binary content of the file specified by `path`.

		If the file does not exist or can not be read, an exception is thrown.

		`sys.FileSystem.exists` can be used to check for existence.

		If `path` is null, the result is unspecified.</haxe_doc>
		</getBytes>
		<saveBytes public="1" set="method" static="1">
			<f a="path:bytes">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stores `bytes` in the file specified by `path` in binary mode.

		If the file cannot be written to, an exception is thrown.

		If `path` or `bytes` are null, the result is unspecified.</haxe_doc>
		</saveBytes>
		<read public="1" set="method" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileInput"/>
			</f>
			<meta><m n=":value"><e>{ binary : true }</e></m></meta>
			<haxe_doc>Returns an `FileInput` handle to the file specified by `path`.

		If `binary` is true, the file is opened in binary mode. Otherwise it is
		opened in non-binary mode.

		If the file does not exist or can not be read, an exception is thrown.

		Operations on the returned `FileInput` handle read on the opened file.

		File handles should be closed via `FileInput.close` once the operation
		is complete.

		If `path` is null, the result is unspecified.</haxe_doc>
		</read>
		<write public="1" set="method" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileOutput"/>
			</f>
			<meta><m n=":value"><e>{ binary : true }</e></m></meta>
			<haxe_doc>Returns an `FileOutput` handle to the file specified by `path`.

		If `binary` is true, the file is opened in binary mode. Otherwise it is
		opened in non-binary mode.

		If the file cannot be written to, an exception is thrown.

		Operations on the returned `FileOutput` handle write to the opened file.
		If the file existed, its previous content is overwritten.

		File handles should be closed via `FileOutput.close` once the operation
		is complete.

		If `path` is null, the result is unspecified.</haxe_doc>
		</write>
		<append public="1" set="method" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileOutput"/>
			</f>
			<meta><m n=":value"><e>{ binary : true }</e></m></meta>
			<haxe_doc>Similar to `sys.io.File.write`, but appends to the file if it exists
		instead of overwriting its contents.</haxe_doc>
		</append>
		<update public="1" set="method" static="1">
			<f a="path:?binary" v=":true">
				<c path="String"/>
				<x path="Bool"/>
				<c path="sys.io.FileOutput"/>
			</f>
			<meta><m n=":value"><e>{ binary : true }</e></m></meta>
			<haxe_doc>Similar to `sys.io.File.append`. While `append` can only seek or write
		starting from the end of the file's previous contents, `update` can
		seek to any position, so the file's previous contents can be
		selectively overwritten.</haxe_doc>
		</update>
		<copy public="1" set="method" static="1">
			<f a="srcPath:dstPath">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies the contents of the file specified by `srcPath` to the file
		specified by `dstPath`.

		If the `srcPath` does not exist or cannot be read, or if the `dstPath`
		file cannot be written to, an exception is thrown.

		If the file at `dstPath` exists, its contents are overwritten.

		If `srcPath` or `dstPath` are null, the result is unspecified.</haxe_doc>
		</copy>
		<haxe_doc>API for reading and writing files.

	See `sys.FileSystem` for the complementary file system API.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="sys.io.FileInput" params="" file="/home/travis/haxe/std/sys/io/FileInput.hx" extern="1">
		<extends path="haxe.io.Input"/>
		<seek public="1" set="method"><f a="p:pos">
	<x path="Int"/>
	<e path="sys.io.FileSeek"/>
	<x path="Void"/>
</f></seek>
		<tell public="1" set="method"><f a=""><x path="Int"/></f></tell>
		<eof public="1" set="method"><f a=""><x path="Bool"/></f></eof>
		<haxe_doc>Use `sys.io.File.read` to create a `FileInput`.</haxe_doc>
	</class>
	<class path="sys.io.FileOutput" params="" file="/home/travis/haxe/std/sys/io/FileOutput.hx" extern="1">
		<extends path="haxe.io.Output"/>
		<seek public="1" set="method"><f a="p:pos">
	<x path="Int"/>
	<e path="sys.io.FileSeek"/>
	<x path="Void"/>
</f></seek>
		<tell public="1" set="method"><f a=""><x path="Int"/></f></tell>
		<haxe_doc>Use `sys.io.File.write` to create a `FileOutput`.</haxe_doc>
	</class>
	<enum path="sys.io.FileSeek" params="" file="/home/travis/haxe/std/sys/io/FileSeek.hx">
		<SeekBegin/>
		<SeekCur/>
		<SeekEnd/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="sys.net.Host" params="" file="/home/travis/haxe/std/sys/net/Host.hx" extern="1">
		<localhost public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the local computer host name</haxe_doc>
		</localhost>
		<host public="1" set="null">
			<c path="String"/>
			<haxe_doc>The provided host string.</haxe_doc>
		</host>
		<ip public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The actual IP corresponding to the host.</haxe_doc>
		</ip>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the IP representation of the host</haxe_doc>
		</toString>
		<reverse public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Perform a reverse-DNS query to resolve a host name from an IP.</haxe_doc>
		</reverse>
		<new public="1" set="method">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new Host : the name can be an IP in the form "127.0.0.1" or an host name such as "google.com", in which case
		the corresponding IP address is resolved using DNS. An exception occur if the host name could not be found.</haxe_doc>
		</new>
		<haxe_doc>A given IP host name.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="sys.net.Socket" params="" file="/home/travis/haxe/std/sys/net/Socket.hx" extern="1">
		<select public="1" set="method" static="1">
			<f a="read:write:others:?timeout">
				<c path="Array"><c path="sys.net.Socket"/></c>
				<c path="Array"><c path="sys.net.Socket"/></c>
				<c path="Array"><c path="sys.net.Socket"/></c>
				<x path="Float"/>
				<a>
					<write><c path="Array"><c path="sys.net.Socket"/></c></write>
					<read><c path="Array"><c path="sys.net.Socket"/></c></read>
					<others><c path="Array"><c path="sys.net.Socket"/></c></others>
				</a>
			</f>
			<haxe_doc>Wait until one of the sockets group is ready for the given operation:

		 - `read` contains sockets on which we want to wait for available data to be read,
		 - `write` contains sockets on which we want to wait until we are allowed to write some data to their output buffers,
		 - `others` contains sockets on which we want to wait for exceptional conditions.
		 - `select` will block until one of the condition is met, in which case it will return the sockets for which the condition was true.

		In case a `timeout` (in seconds) is specified, select might wait at worst until the timeout expires.</haxe_doc>
		</select>
		<input public="1" set="null">
			<c path="haxe.io.Input"/>
			<haxe_doc>The stream on which you can read available data. By default the stream is blocking until the requested data is available,
		use `setBlocking(false)` or `setTimeout` to prevent infinite waiting.</haxe_doc>
		</input>
		<output public="1" set="null">
			<c path="haxe.io.Output"/>
			<haxe_doc>The stream on which you can send data. Please note that in case the output buffer you will block while writing the data, use `setBlocking(false)` or `setTimeout` to prevent that.</haxe_doc>
		</output>
		<custom public="1">
			<d/>
			<haxe_doc>A custom value that can be associated with the socket. Can be used to retrieve your custom infos after a `select`.
	*</haxe_doc>
		</custom>
		<close public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Closes the socket : make sure to properly close all your sockets or you will crash when you run out of file descriptors.</haxe_doc>
		</close>
		<read public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Read the whole data available on the socket.

		*Note*: this is **not** meant to be used together with `setBlocking(false)`,
		as it will always throw `haxe.io.Error.Blocked`. `input` methods should be used directly instead.</haxe_doc>
		</read>
		<write public="1" set="method">
			<f a="content">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Write the whole data to the socket output.

		*Note*: this is **not** meant to be used together with `setBlocking(false)`, as
		`haxe.io.Error.Blocked` may be thrown mid-write with no indication of how many bytes have been written.
		`output.writeBytes()` should be used instead as it returns this information.</haxe_doc>
		</write>
		<connect public="1" set="method">
			<f a="host:port">
				<c path="sys.net.Host"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Connect to the given server host/port. Throw an exception in case we couldn't successfully connect.</haxe_doc>
		</connect>
		<listen public="1" set="method">
			<f a="connections">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allow the socket to listen for incoming questions. The parameter tells how many pending connections we can have until they get refused. Use `accept()` to accept incoming connections.</haxe_doc>
		</listen>
		<shutdown public="1" set="method">
			<f a="read:write">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Shutdown the socket, either for reading or writing.</haxe_doc>
		</shutdown>
		<bind public="1" set="method">
			<f a="host:port">
				<c path="sys.net.Host"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Bind the socket to the given host/port so it can afterwards listen for connections there.</haxe_doc>
		</bind>
		<accept public="1" set="method">
			<f a=""><c path="sys.net.Socket"/></f>
			<haxe_doc>Accept a new connected client. This will return a connected socket on which you can read/write some data.</haxe_doc>
		</accept>
		<peer public="1" set="method">
			<f a=""><a>
	<port><x path="Int"/></port>
	<host><c path="sys.net.Host"/></host>
</a></f>
			<haxe_doc>Return the information about the other side of a connected socket.</haxe_doc>
		</peer>
		<host public="1" set="method">
			<f a=""><a>
	<port><x path="Int"/></port>
	<host><c path="sys.net.Host"/></host>
</a></f>
			<haxe_doc>Return the information about our side of a connected socket.</haxe_doc>
		</host>
		<setTimeout public="1" set="method">
			<f a="timeout">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Gives a timeout (in seconds) after which blocking socket operations (such as reading and writing) will abort and throw an exception.</haxe_doc>
		</setTimeout>
		<waitForRead public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Block until some data is available for read on the socket.</haxe_doc>
		</waitForRead>
		<setBlocking public="1" set="method">
			<f a="b">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Change the blocking mode of the socket. A blocking socket is the default behavior. A non-blocking socket will abort blocking operations immediately by throwing a haxe.io.Error.Blocked value.</haxe_doc>
		</setBlocking>
		<setFastSend public="1" set="method">
			<f a="b">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allows the socket to immediately send the data when written to its output : this will cause less ping but might increase the number of packets / data size, especially when doing a lot of small writes.</haxe_doc>
		</setFastSend>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new unconnected socket.</haxe_doc>
		</new>
		<haxe_doc>A TCP socket class : allow you to both connect to a given server and exchange messages or start your own server and wait for connections.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
</haxe>